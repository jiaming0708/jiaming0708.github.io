{"meta":{"title":"Secret Note","subtitle":"機密檔案","description":"記錄一些自己記不住的東西","author":"Jimmy Ho","url":"http://jiaming0708.github.io","root":"/"},"pages":[{"title":"Privacy Policy","date":"2020-09-07T14:36:45.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"Privacy-Policy/index.html","permalink":"http://jiaming0708.github.io/Privacy-Policy/index.html","excerpt":"","text":"非常歡迎您光臨「機密檔案」（以下簡稱本網站），為了讓您能夠安心的使用本網站的各項服務與資訊，特此向您說明本網站的隱私權保護政策，以保障您的權益，請您詳閱下列內容： 一、隱私權保護政策的適用範圍隱私權保護政策內容，包括本網站如何處理在您使用網站服務時收集到的個人識別資料。隱私權保護政策不適用於本網站以外的相關連結網站，也不適用於非本網站所委託或參與管理的人員。 二、個人資料的蒐集、處理及利用方式當您造訪本網站或使用本網站所提供之功能服務時，我們將視該服務功能性質，請您提供必要的個人資料，並在該特定目的範圍內處理及利用您的個人資料；非經您書面同意，本網站不會將個人資料用於其他用途。本網站在您使用服務信箱、問卷調查等互動性功能時，會保留您所提供的姓名、電子郵件地址、聯絡方式及使用時間等。於一般瀏覽時，伺服器會自行記錄相關行徑，包括您使用連線設備的IP位址、使用時間、使用的瀏覽器、瀏覽及點選資料記錄等，做為我們增進網站服務的參考依據，此記錄為內部應用，決不對外公佈。為提供精確的服務，我們會將收集的問卷調查內容進行統計與分析，分析結果之統計數據或說明文字呈現，除供內部研究外，我們會視需要公佈統計數據及說明文字，但不涉及特定個人之資料。三、資料之保護本網站主機均設有防火牆、防毒系統等相關的各項資訊安全設備及必要的安全防護措施，加以保護網站及您的個人資料採用嚴格的保護措施，只由經過授權的人員才能接觸您的個人資料，相關處理人員皆簽有保密合約，如有違反保密義務者，將會受到相關的法律處分。如因業務需要有必要委託其他單位提供服務時，本網站亦會嚴格要求其遵守保密義務，並且採取必要檢查程序以確定其將確實遵守。四、網站對外的相關連結本網站的網頁提供其他網站的網路連結，您也可經由本網站所提供的連結，點選進入其他網站。但該連結網站不適用本網站的隱私權保護政策，您必須參考該連結網站中的隱私權保護政策。 五、與第三人共用個人資料之政策本網站絕不會提供、交換、出租或出售任何您的個人資料給其他個人、團體、私人企業或公務機關，但有法律依據或合約義務者，不在此限。 前項但書之情形包括不限於： 經由您書面同意。法律明文規定。為免除您生命、身體、自由或財產上之危險。與公務機關或學術研究機構合作，基於公共利益為統計或學術研究而有必要，且資料經過提供者處理或蒐集者依其揭露方式無從識別特定之當事人。當您在網站的行為，違反服務條款或可能損害或妨礙網站與其他使用者權益或導致任何人遭受損害時，經網站管理單位研析揭露您的個人資料是為了辨識、聯絡或採取法律行動所必要者。有利於您的權益。本網站委託廠商協助蒐集、處理或利用您的個人資料時，將對委外廠商或個人善盡監督管理之責。六、Cookie之使用為了提供您最佳的服務，本網站會在您的電腦中放置並取用我們的Cookie，若您不願接受Cookie的寫入，您可在您使用的瀏覽器功能項中設定隱私權等級為高，即可拒絕Cookie的寫入，但可能會導致網站某些功能無法正常執行 。 七、隱私權保護政策之修正本網站隱私權保護政策將因應需求隨時進行修正，修正後的條款將刊登於網站上。"},{"title":"關於我","date":"2023-03-09T14:18:38.795Z","updated":"2023-03-09T14:18:38.795Z","comments":false,"path":"about/index.html","permalink":"http://jiaming0708.github.io/about/index.html","excerpt":"","text":"The member of Angular Taiwan Group, and become a speaker of the group Like to face end-user to know their true requirements Skill set: C#, Asp.Net(MVC), .Net Core, MS SQL, Oracle, Azure, Angular Love jogging &amp; Occasionally being a Marathon runner Speaker Experience 28, March 2018 Angular online study group (1 hr) Development tip with PrimeNG 19, Oct 2017 Angular online study group (1 hr) Introduction Jasmine &amp; Protractor 14, Oct 2017 Study 4 Conf. - light talk(5 min) TypeScript Feature Summary 19, July 2017Angular online study group (1 hr) How to use RxJS 19, Jun 2017 Angular Taiwan Group meetup - light talk (15 min) How to use i18n in Angular 05, Apr 2017 Angular online study group (1 hr) HostBinding &amp; HostListener"}],"posts":[{"title":"WSL空間擴增問題排除","slug":"wsl-disk-space-move-location","date":"2023-03-09T12:47:23.000Z","updated":"2023-03-09T14:18:38.795Z","comments":true,"path":"2023/03/09/wsl-disk-space-move-location/","link":"","permalink":"http://jiaming0708.github.io/2023/03/09/wsl-disk-space-move-location/","excerpt":"最近發現工作電腦的c槽突然間快滿了，查了一下被哪些東西吃掉，才發現一個噁心的怪獸，就是 WSL 的虛擬硬碟 vhdx 吃掉了 30G，底下會說明該怎麼解決這個問題。","text":"最近發現工作電腦的c槽突然間快滿了，查了一下被哪些東西吃掉，才發現一個噁心的怪獸，就是 WSL 的虛擬硬碟 vhdx 吃掉了 30G，底下會說明該怎麼解決這個問題。 在 Windows 安裝 WSL 大多是為了使用 Docker Desktop 這個軟體，WSL 的虛擬硬碟檔案則是放在使用者資料夾下的 AppData\\Local\\Docker\\wsl\\data，可以看到一個叫做 ext4.vhdx 的檔案。有另外安裝 ubuntu 之類的系統的話，檔案路徑則不一樣的是在 Packges 並且根據你安裝的系統後面加上一些獨立的名稱， AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc\\LocalState 。 當我們使用完畢 container 關閉後，vhdx 的檔案並不會因此而釋放掉所使用到的空間，每次使用就會吃掉一點，不斷的擴增並且是沒有限制！！這個問題從 2019 年就有人開 issue，但都還沒有辦法解決，裡面有些人提出一些作法是把檔案路徑搬走，至少不要讓系統c槽的空間被吃光。 底下是根據裡面討論到的有效解法，蠻建議安裝完後就移動這個位置，讓自己的 windows 不會因此有空間不足而產生的效能問題。 記得要使用系統管理員的權限執行，不然最後連結檔案的步驟會失敗 123456789101112# 其他槽的位置$newLocation = &quot;E:\\WSL2\\&quot;cd &quot;~\\AppData\\Local\\Docker\\wsl\\data&quot;# cd &quot;~\\AppData\\Local\\Packages\\&#123;distro folder name&#125;\\LocalState&quot;wsl --shutdownmkdir $newLocation -Forcemv ext4.vhdx $newLocationcd ..rm &quot;data&quot;# 使用連結檔案的方式，讓實體是在其他指定的位置New-Item -ItemType SymbolicLink -Path &quot;data&quot; -Target $newLocation","categories":[{"name":"Windows","slug":"Windows","permalink":"http://jiaming0708.github.io/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://jiaming0708.github.io/tags/Windows/"},{"name":"Docker","slug":"Docker","permalink":"http://jiaming0708.github.io/tags/Docker/"}]},{"title":"[Flutter] SVG應用","slug":"flutter-svg","date":"2023-02-20T14:13:56.000Z","updated":"2023-03-09T14:18:38.795Z","comments":true,"path":"2023/02/20/flutter-svg/","link":"","permalink":"http://jiaming0708.github.io/2023/02/20/flutter-svg/","excerpt":"在網頁使用 icon 的時候，會想要採用 svg，主要原因是可以渲染並且不會失真，而且可以做動態渲染的效果，接下來看看如何在 flutter 使用 svg 來開發。","text":"在網頁使用 icon 的時候，會想要採用 svg，主要原因是可以渲染並且不會失真，而且可以做動態渲染的效果，接下來看看如何在 flutter 使用 svg 來開發。 安裝使用執行以下的指令安裝套件 flutter_svg 1flutter pub add flutter_svg 在 pubspec.yml 可以看到增加這行（若沒有請自己加上）。 12dependencies: flutter_svg: ^2.0.0+1 安裝後，在程式裡面引用並且使用 SvgPicture 這個類別。 1import &#x27;package:flutter_svg/flutter_svg.dart&#x27;; 檔案在本地當 icon 檔案在本地的時候，要使用的是 SvgPicture.asset 這個方法。 1var icon = SvgPicture.asset(&#x27;assets/add.svg&#x27;); 直接放路徑是最基本的用法，若是希望指定元件的大小，則可以加上 width 及 height 兩個參數。 1var icon = SvgPicture.asset(&#x27;assets/add.svg&#x27;, width: 16, height: 16); 檔案在網路使用上跟前面差不多，主要是方法改成 network。 1var icon = SvgPicture.network(path); 要指定大小的話，一樣可以加上 width 及 height 兩個參數。 改變顏色把 add 改成紅色，只需要加上 color 這個參數。 123456final Widget svgIcon = SvgPicture.asset( &#x27;assets/add.svg&#x27;, width: 16, height: 16, color: const Color(0xFFFF0000),); 內縮效果如果 icon 是需要有 padding 的話，就可以搭配 Container 這個物件來完成。 12345678var icon = SvgPicture.asset(&#x27;assets/add.svg&#x27;);// icon 最終的寬高為 16var iconWithPadding = Container( margin: const EdgeInsets.symmetric(horizontal: 8.0), height: 32, width: 16, child: icon,); 在 flutter 的世界中，效果都是透過疊加的方式做呈現，很少有一個元件就能達成全部的效果。如果你跟我一樣平常主要接觸是網頁開發，這個地方要稍微習慣一下。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://jiaming0708.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://jiaming0708.github.io/tags/Flutter/"}]},{"title":"Gitea 資料庫遷移","slug":"gitea-database-migration","date":"2023-02-20T03:06:21.000Z","updated":"2023-03-09T14:18:38.795Z","comments":true,"path":"2023/02/20/gitea-database-migration/","link":"","permalink":"http://jiaming0708.github.io/2023/02/20/gitea-database-migration/","excerpt":"公司的 Gitea 原本資料庫是用 SQLServer，那台 Server 本身也比較舊，在有些操作下也會覺得不順，剛好有機會可以停機可以轉成 Postgres，這邊來記錄一下我的操作步驟。","text":"公司的 Gitea 原本資料庫是用 SQLServer，那台 Server 本身也比較舊，在有些操作下也會覺得不順，剛好有機會可以停機可以轉成 Postgres，這邊來記錄一下我的操作步驟。 備份指令介紹我們可以透過指令的方式針對 Gitea 來做備份和還原，備份功能本身能夠支援輸出成不同資料庫，詳細的指令的話在文件上就沒看到，我是透過 Migrate Gitea DB from MariaDB to PostgreSQL - Support - Gitea 這篇的討論和 Source code 來找到需要的指令。 對於 Gitea 來說，備份的內容包含 sql file、log、repository，需要做的只有資料庫的部分，省略其他的輸出可以讓備份的速度加快，最終的指令如下: 1/app/gitea/gitea dump -d postgres -R -L -c /data/gitea/conf/app.ini database(d)，可以指定輸出的資料庫類型 PostgreSQL, MySQL , SQLite, MSSQL skip-repository(R)，略過 repository 備份 skip-log(L)，略過 log 備份 config(c)，指定 app.ini 檔案的路徑 執行備份接著就要實際的下指令囉，在公司的環境中，是用 Docker 來做安裝，因此要先連到 Gitea 的 Container 中。 1docker exec -it gitea bash 執行前面所介紹的指令，這邊會收到一個 permission 的錯誤，主要是不能使用 root 來做 dump 的指令。 12023/02/20 11:43:31 ...s/setting/setting.go:1059:loadFromConf() [F] Gitea is not supposed to be run as root. Sorry. If you need to use privileged TCP ports please instead use setcap and the `cap_net_bind_service` permission 這邊只要切換使用者為 git ，再次執行前面的指令。 1su git 就可以看到開始備份的訊息，完成的時候會看到一個 gitea-dump-*.zip 的檔案名稱在你執行的目錄底下。 123452023/02/20 03:55:26 ...dules/setting/log.go:288:newLogService() [I] Gitea v1.18.3 built with GNU Make 4.3, go1.19.5 : bindata, timetzdata, sqlite, sqlite_unlock_notify...2023/02/20 03:55:49 cmd/dump.go:405:runDump() [I] Finish dumping in file gitea-dump-1676865326.zip 那整合一下以上的作法，可以這樣下指令，一次匯出。 1docker exec -it -u git -w /data $(docker ps -qf &#x27;name=^gitea$&#x27;) bash -c &#x27;/app/gitea/gitea dump -d postgres -R -L -c /data/gitea/conf/app.ini&#x27; -w 為工作目錄，因為 data 的資料夾有跟外面的實體做對應，為了要方便拿到檔案，所以放在這邊 匯入資料庫把 dump.zip 中的 sql file 拿出來後放到 Postgres 的 container 中。 這邊我對應到 app 的資料夾中 123docker exec -it database bashsu postgrespsql 根據官方的文件 Database Preparation - Docs (gitea.io) 先建立好使用者和資料庫。 12CREATE USER &quot;gitea&quot; WITH PASSWORD &#x27;password&#x27;;CREATE DATABASE dbgitea WITH OWNER gitea TEMPLATE template0 ENCODING UTF8 LC_COLLATE &#x27;en_US.UTF-8&#x27; LC_CTYPE &#x27;en_US.UTF-8&#x27;; 接著就可以開始匯入資料。 1psql --username gitea -h localhost --set ON_ERROR_STOP=on dbgitea &lt; /app/gitea-db.sql 修改連線資料以上的步驟都做完，最後就是要修改 app.ini 裡的連線資訊，找到 database 的區塊，把資訊改成以下即可。 123456[database]DB_TYPE = postgresHOST = database:5432NAME = dbgiteaUSER = giteaPASSWD = password 把服務重新啟動，連線進去確認一下所有內容都是遷移前的狀態，那就可以收工啦!!","categories":[{"name":"Infra","slug":"Infra","permalink":"http://jiaming0708.github.io/categories/Infra/"}],"tags":[{"name":"Gitea","slug":"Gitea","permalink":"http://jiaming0708.github.io/tags/Gitea/"},{"name":"Infra","slug":"Infra","permalink":"http://jiaming0708.github.io/tags/Infra/"}]},{"title":"[flutter] 使用 16 進制定義顏色","slug":"flutter-hex-color","date":"2023-01-24T06:16:00.000Z","updated":"2023-03-09T14:18:38.795Z","comments":true,"path":"2023/01/24/flutter-hex-color/","link":"","permalink":"http://jiaming0708.github.io/2023/01/24/flutter-hex-color/","excerpt":"在 Flutter 中有提供好幾種方法可以來定義 Color 這個物件，這篇會介紹如何使用這些方法。","text":"在 Flutter 中有提供好幾種方法可以來定義 Color 這個物件，這篇會介紹如何使用這些方法。 已知的顏色 使用到的是常用的顏色，例如黑、白、紅、綠、黃等等的，可以直接使用 Colors 來找到需要的顏色。 1Color danger = Colors.red; 若是要使用 0-255 間的數字來設定顏色，則有兩種作法，主要的差異在於 opacity 1234// opacity 於最後一個參數，值介於 0-1 的浮點數Color danger = Color.fromRGBO(255, 0, 0, 1);// opacity 於第一個參數，值介於 0-255 的整數Color danger = Color.fromARGB(255, 255, 0, 0); 使用 hex 定義，組成方式為 alpha red green blue 1Color danger = Color(0xFFFF0000); 未知的顏色當顏色的不是先定義好，而是由 API 的資料來決定的話，會需要將字串做個轉換；在這個情況下，建議跟後端溝通拿到的顏色字串為 hex 格式，也就是 RRGGBB。在根據前面所說的 hex 顏色定義方法，適度的補上 alpha 值，在透過 int 的方式來宣告成 Color 物件。 123456Color hexToColor(String hexString) &#123; final buffer = StringBuffer(); if (hexString.length == 6 || hexString.length == 7) buffer.write(&#x27;ff&#x27;); buffer.write(hexString.replaceFirst(&#x27;#&#x27;, &#x27;&#x27;)); return Color(int.parse(buffer.toString(), radix: 16));&#125; 可以宣告成一個新的物件，或是擴充功能，就看怎麼用比較順手了。 123456extension ColorExtension on String &#123; Color toColor(String hexString) &#123; //... &#125;&#125;Color danger = &#x27;#ff0000&#x27;.toColor();","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://jiaming0708.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://jiaming0708.github.io/tags/Flutter/"}]},{"title":"如何建立 Oracle database image","slug":"build-oracle-database-image","date":"2023-01-16T02:46:13.000Z","updated":"2023-03-09T14:18:38.791Z","comments":true,"path":"2023/01/16/build-oracle-database-image/","link":"","permalink":"http://jiaming0708.github.io/2023/01/16/build-oracle-database-image/","excerpt":"原本 Oracle 有提供 image 在 DockerHub上，現在已經沒有再提供了，那對於習慣用 container 做開發的我來說，非常的不方便，還好 Oracle 也有提供另外的做法可以來建立 image，接下來分享該如何操作。","text":"原本 Oracle 有提供 image 在 DockerHub上，現在已經沒有再提供了，那對於習慣用 container 做開發的我來說，非常的不方便，還好 Oracle 也有提供另外的做法可以來建立 image，接下來分享該如何操作。 Oracle 已經將很多的服務寫好 dockerfile 放到 github 上，從 OracleDatabase 目錄進入，有分 SingleInstance 及 RAC 就根據自己需求去選，這邊我是要自己開發用的所以選擇是 SingleInstance，進去以後可以看到從 11g 到 21c 都有提供，就根據自己的需要去選擇，今天會使用 19c 來做為展示。 雖然我的環境是用 windows，在 mac 的環境下是沒有差的。 Sparse checkout整個 repo 很多內容，我們只需要 SingleInstance 底下的 dockerfiles 資料夾，選擇使用 sparse checkout 的做法，只拿部分的內容。 12git clone --depth 1 --sparse https://github.com/oracle/docker-images.git oracle-imagescd oracle-images 設定只取得 OracleDatabase/SingleInstance/dockerfiles。 1git sparse-checkout set &quot;OracleDatabase/SingleInstance/dockerfiles&quot; 下載dbhomeDatabase Software Downloads | Oracle 接著到 Oracle 官網下載 dbhome，選擇好版本並且點擊 linux x86_64 來下載。 下載後的檔案放到剛剛所 clone 的專案目錄底下對應的版本資料夾中。 產生image前置作業終於完成，可以來最作後一個步驟，產生 image 啦!來到 dockerfiles 的資料夾，看到 buildContainerImage.sh 檔案，Oracle 已經寫好指令，讓我們可以更為方便的產生 image。 如果是在 windows 環境下，無法直接執行 bash 的檔案，可以改用 WSL 來執行。 後面加上 -v 指定版本，-t 指定 image tag 名稱。 共有三種模式可以選擇，Enterprise Edition(-e), Standard Edition 2(-s), Express Edition(-x) 1./buildContainerImage.sh -v 19.3.0 -s -t oracle/database:19.3.0s 執行會有一陣子(我的電腦最後花費 280 秒)，最後看到這樣的訊息就代表成功囉。 12345678910 =&gt; =&gt; naming to docker.io/oracle/database:19.3.0s 0.0sUse &#x27;docker scan&#x27; to run Snyk tests against images to find vulnerabilities and learn how to fix them Oracle Database container image for &#x27;se2&#x27; version 19.3.0 is ready to be extended: --&gt; oracle/database:19.3.0s Build completed in 280 seconds. 開啟 DockerDesktop 切換到 Images 的頁面，就可以看到所產生的 image 啦!! 執行最後就是跑起來!! (還慢慢走啊，動作)如果想要保留檔案，可以使用 volumn 做對應 /opt/oracle/oradata；使用環境變數指定管理者密碼 ORACLE_PWD。 如果沒有 volumn 的話，第一次的啟動會花較多時間；有 volumn 就會蠻快的。 1docker run --name oracle -d -it --rm -p 1521:1521 -v $&#123;PWD&#125;/data19c:/opt/oracle/oradata -e ORACLE_PWD=&quot;p@ssw0rd&quot; oracle/database:19.3.0s 到了這個步驟，終於可以開始我們的開發啦，也不用擔心重灌系統還要先 dump&#x2F;import 資料，可以大大的節省時間啦!!","categories":[{"name":"Database","slug":"Database","permalink":"http://jiaming0708.github.io/categories/Database/"},{"name":"Oracle","slug":"Database/Oracle","permalink":"http://jiaming0708.github.io/categories/Database/Oracle/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://jiaming0708.github.io/tags/Docker/"},{"name":"Database","slug":"Database","permalink":"http://jiaming0708.github.io/tags/Database/"},{"name":"Oracle","slug":"Oracle","permalink":"http://jiaming0708.github.io/tags/Oracle/"}]},{"title":"[flutter] 在 GoRoute 中使用 NavigationBar","slug":"flutter-goroute-with-navigation-bar","date":"2023-01-09T02:12:05.000Z","updated":"2023-03-09T14:18:38.783Z","comments":true,"path":"2023/01/09/flutter-goroute-with-navigation-bar/","link":"","permalink":"http://jiaming0708.github.io/2023/01/09/flutter-goroute-with-navigation-bar/","excerpt":"在 App 中通常會把主要的幾個頁面放在下方 icon，讓使用者能夠方便操作，這個元件在 flutter 中稱為 BottomNavigationBar。GoRouter 是 Flutter 官方所提供的套件，可以用來整合整個專案的路由，當這兩個功能整合在一起的時候，一個不小心呈現出來的效果就會差很多。","text":"在 App 中通常會把主要的幾個頁面放在下方 icon，讓使用者能夠方便操作，這個元件在 flutter 中稱為 BottomNavigationBar。GoRouter 是 Flutter 官方所提供的套件，可以用來整合整個專案的路由，當這兩個功能整合在一起的時候，一個不小心呈現出來的效果就會差很多。 版本資訊Flutter 3.3.4go_router: ^6.0.0 先產生一個新的專案叫做 my_app 12flutter create my_appcd my_app 加入BottomNavigationBar 在 MyHomePage 元件中找到 build 的方法，在 Scaffold 加上 bottomNavigationBar 的屬性，加上兩個有 icon 的元件。 12345678910111213141516171819202122232425262728293031323334@overrideWidget build(BuildContext context) &#123; return Scaffold( bottomNavigationBar: BottomNavigationBar( items: const [ BottomNavigationBarItem( icon: Icon(Icons.search), label: &#x27;search&#x27;, ), BottomNavigationBarItem( icon: Icon(Icons.add), label: &#x27;add&#x27;, ), ], ), appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ const Text( &#x27;You have pushed the button this many times:&#x27;, ), Text( &#x27;$_counter&#x27;, style: Theme.of(context).textTheme.headline4, ), ], ), ), );&#125; 執行指令 flutter run 就可以看到畫面的下方有一個 icon 的區塊，顯示剛剛所加入的 search 和 add。 加入GoRouter接著要來加入 GoRouter 這個套件。 1flutter pub add go_router 定義Router定義兩個 route，會使用同一個元件，但是透過傳入不同 title 的內容來做識別。找到 MyApp 這個元件，在 build 裡面加上這段。 123456789101112131415161718192021var router = GoRouter( initialLocation: &#x27;/page1&#x27;, routes: [ GoRoute( path: &#x27;/page1&#x27;, name: &#x27;page1&#x27;, builder: (BuildContext context, GoRouterState state) =&gt; const MyHomePage( title: &#x27;search&#x27;, ), ), GoRoute( path: &#x27;/page2&#x27;, name: &#x27;page2&#x27;, builder: (BuildContext context, GoRouterState state) =&gt; const MyHomePage( title: &#x27;add&#x27;, ), ), ],); 接著要調整 return 的行為，原本是用 MaterialApp，現在要來改用 MaterialApp.router 才能加上路由的設定。 12345678910return MaterialApp.router( title: &#x27;Flutter Demo&#x27;, theme: ThemeData( primarySwatch: Colors.blue, ), // 把原本的 home 屬性刪除並加上這段 routeInformationProvider: router.routeInformationProvider, routeInformationParser: router.routeInformationParser, routerDelegate: router.routerDelegate,); 最後回去調整 BottomNavigationBar 的行為，監聽 onTap 的事件，來達到切換頁面的效果。 12345678910111213bottomNavigationBar: BottomNavigationBar(items: const [ BottomNavigationBarItem( icon: Icon(Icons.search), label: &#x27;search&#x27;, ), BottomNavigationBarItem( icon: Icon(Icons.add), label: &#x27;add&#x27;, ),],// 監聽點擊事件onTap: (index) =&gt; context.go(&#x27;/page$&#123;index + 1&#125;&#x27;), 改好以後回到剛剛沒有中斷的 terminal 按下 r 做個重新整理，切換的頁面的功能是正常的，但是整個頁面包含 NavigationBar 也都跟著重新載入。 請先忽略點選了第二頁但是 icon 還是停留在第一頁的問題 使用ShellRoute根據 GoRouter 的介紹，當有需要 BottomNavigationBar 的時候，應該要採用 ShellRoute 的架構，就能夠只有內容重新載入。接著就要動一個比較大的工程，要將 Scaffold 整個拉出來放到 ShellRoute 中。 建立一個新的元件，就叫他 ScaffoldWithBottomNavBar。 這邊方便就不切檔案了，直接一個 main.dart 到底。 1234567891011121314151617181920212223242526272829303132class ScaffoldWithBottomNavBar extends StatefulWidget &#123; const ScaffoldWithBottomNavBar(&#123;Key? key, required this.child&#125;) : super(key: key); final Widget child; @override State&lt;ScaffoldWithBottomNavBar&gt; createState() =&gt; _ScaffoldWithBottomNavBarState();&#125;class _ScaffoldWithBottomNavBarState extends State&lt;ScaffoldWithBottomNavBar&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( bottomNavigationBar: BottomNavigationBar( items: const [ BottomNavigationBarItem( icon: Icon(Icons.search), label: &#x27;search&#x27;, ), BottomNavigationBarItem( icon: Icon(Icons.add), label: &#x27;add&#x27;, ), ], onTap: (index) =&gt; context.go(&#x27;/page$&#123;index + 1&#125;&#x27;), ), // 內容由外面來決定 body: widget.child, ); &#125;&#125; 把這個元件加到路由的設定上面。 12345678910111213141516171819202122232425262728var router = GoRouter( initialLocation: &#x27;/page1&#x27;, routes: [ // 在原本的路由前面加上 ShellRoute 並且回傳剛剛所建立的元件 ShellRoute( builder: ((context, state, child) =&gt; ScaffoldWithBottomNavBar(child: child)), routes: [ GoRoute( path: &#x27;/page1&#x27;, name: &#x27;page1&#x27;, builder: (BuildContext context, GoRouterState state) =&gt; const MyHomePage( title: &#x27;search&#x27;, ), ), GoRoute( path: &#x27;/page2&#x27;, name: &#x27;page2&#x27;, builder: (BuildContext context, GoRouterState state) =&gt; const MyHomePage( title: &#x27;add&#x27;, ), ), ], ), ],); 前面已經將 BottomNavigationBar 抽出去放到 ShellRoute 中，回到 MyHomePage 元件將原本加上去的設定移除掉。 Scaffold 可以多次宣告，後面宣告的會疊加上去。 1234567891011121314151617181920212223@overrideWidget build(BuildContext context) &#123; return Scaffold( // 移除 bottomNavigationBar 屬性 appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ const Text( &#x27;You have pushed the button this many times:&#x27;, ), Text( &#x27;$_counter&#x27;, style: Theme.of(context).textTheme.headline4, ), ], ), ), );&#125; 都改完後一樣回到 terminal 按下 r 重新整理，BottomNavigationBar 的區塊是固定的了，只有內容頁是不同。 結論在 web 上會很習慣這種功能的存在，轉到 flutter 時，一時間沒找到也沒特別注意到問題，後來是測試的時候才被點出來。一個元件使用上的小地方，用錯方法就會讓使用者看起來沒有那麼舒服（或是習慣？）。 最後附上完整的程式碼。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://jiaming0708.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://jiaming0708.github.io/tags/Flutter/"}]},{"title":"[Debug] AjaxToolKit Calendar的時間問題","slug":"ajaxtoolkit-calendar-time-issue","date":"2023-01-05T03:49:02.000Z","updated":"2023-03-09T14:18:38.779Z","comments":true,"path":"2023/01/05/ajaxtoolkit-calendar-time-issue/","link":"","permalink":"http://jiaming0708.github.io/2023/01/05/ajaxtoolkit-calendar-time-issue/","excerpt":"在一個 Webform 的專案中，使用到 AjaxToolKit 的元件 CalendarExtender來選擇日期，設定的時間格式為 2023/01/05 23:59:59，在瀏覽器做日期的選擇後，會變成 2023/01/05 23:59:00，也沒有看到任何地方有去變更時間，同事覺得奇怪，一起追查問題以後發現這是一個 bug。","text":"在一個 Webform 的專案中，使用到 AjaxToolKit 的元件 CalendarExtender來選擇日期，設定的時間格式為 2023/01/05 23:59:59，在瀏覽器做日期的選擇後，會變成 2023/01/05 23:59:00，也沒有看到任何地方有去變更時間，同事覺得奇怪，一起追查問題以後發現這是一個 bug。 問題追查專案中的程式是這樣寫，ttbEndDate 的值是給今天的 23:59:59，沒有去接任何事件。 123456&lt;asp:TextBox ID=&quot;ttbEndDate&quot; runat=&quot;server&quot; CssClass=&quot;CSInput&quot; Width=&quot;90%&quot;&gt;&lt;/asp:TextBox&gt;&lt;ajaxToolkit:CalendarExtender ID=&quot;ttbEndDate_CalendarExtender&quot; runat=&quot;server&quot; TargetControlID=&quot;ttbEndDate&quot; PopupButtonID=&quot;ibtEndDate&quot; Format=&quot;yyyy/MM/dd HH:mm:ss&quot;&gt;&lt;/ajaxToolkit:CalendarExtender&gt;&lt;asp:ImageButton ID=&quot;ibtEndDate&quot; runat=&quot;server&quot; ImageUrl=&quot;../../Images/Calendar.JPG&quot; Height=&quot;20px&quot; /&gt; 這是 ajax 的元件，那就試著從 javascript 開始找起，開啟網頁的開發者工具，html 的內容中，搜尋 ttbEndDate_CalendarExtender 可以找到下面這段程式，確定的是這段只有做初始化，沒有塞入值之類的行為。 123Sys.Application.add_init(function() &#123; $create(Sys.Extended.UI.CalendarBehavior, &#123;&quot;button&quot;:$get(&quot;ibtEndDate&quot;),&quot;format&quot;:&quot;yyyy/MM/dd HH:mm:ss&quot;,&quot;id&quot;:&quot;ttbEndDate_CalendarExtender&quot;&#125;, null, null, $get(&quot;ttbEndDate&quot;));&#125;); 前面是從 html 去看原始碼的宣告，接著就要切換到來源找到 CalendarBehavior 的運作，開啟網頁的 aspx 可以看到裡面有滿滿的 js 宣告，可以從註解中找到 CalendarBehavior 的區塊。 這種壓縮過的程式會比較難閱讀，可以點下方的 &#123;&#125; 圖示來還原比較好讀的排版。參考 開發不難，會 Debug 就好！如何靈活運用 Chrome DevTools 來開發網站 | 五倍紅寶石・專業程式教育 (5xruby.tw) 看展開後的排版，從上到下的把一段大概看一下，猜測寫入值的部分應該是在 set_selectedDate，從這邊下個中斷點，開始一行一行的看邏輯。 d 是選擇到的日期，f 是原本選擇的日期也就是帶有時分秒的，在 4734 行開始，會把 f 的時分秒開始寫入到 d 身上，問題就在這邊，有 時Hour、分Minute、毫秒Millisecond，但是沒看到 秒Second。嘗試把這行程式在 監看 執行，可以看到 ttbEndDate 的值就是正確的了!! 1d.setUTCSeconds(e.getUTCSeconds()); 解決方法上面雖然找到問題了，但那個是元件中所產生的 js，沒辦法直接去改動到，先檢查專案 AjaxToolKit 的版本為 4.0.60919 ，在 nuget 中最新的版本為 20.1.0，在 github 上面有找到 source code，在最新版本中已經有被修正。 這個問題一直到 15.1.4 才被修正 同事是採用不升級的手法來處理，寫一個 js 的方法，把後面的時間固定。 12345function endDateSelect(ev) &#123; var calendarBehavior1 = $find(&quot;ttbEndDate_CalendarExtender&quot;); var d = calendarBehavior1._selectedDate; calendarBehavior1.get_element().value = d.format(&quot;yyyy/MM/dd&quot;) + &quot; 23:59:59&quot;;&#125; 在 CalendarExtender 的屬性宣告OnClientDateSelectionChanged，讓元件可以去呼叫剛剛所寫好的方法。 123&lt;ajaxToolkit:CalendarExtender ID=&quot;ttbEndDate_CalendarExtender&quot; runat=&quot;server&quot; TargetControlID=&quot;ttbEndDate&quot; PopupButtonID=&quot;ibtEndDate&quot; Format=&quot;yyyy/MM/dd HH:mm:ss&quot; OnClientDateSelectionChanged=&quot;endDateSelect&quot; &gt;&lt;/ajaxToolkit:CalendarExtender&gt; 結論雖然這是古老的技術，也是可以透過現代的工具來幫助我們更容易地找到問題，感謝 open source 的年代，可以更容易的去找到版本的變更，可惜的是版本的紀錄是從 15 開始，無法看到更早的變更，就不能那麼確認是否有 breaking change。","categories":[{"name":"Webform","slug":"Webform","permalink":"http://jiaming0708.github.io/categories/Webform/"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"},{"name":"Debug","slug":"Debug","permalink":"http://jiaming0708.github.io/tags/Debug/"},{"name":"Webform","slug":"Webform","permalink":"http://jiaming0708.github.io/tags/Webform/"}]},{"title":"[Blazor] 搞懂 css scope","slug":"blazor-css-scope","date":"2022-11-02T12:42:21.000Z","updated":"2023-03-09T14:18:38.775Z","comments":true,"path":"2022/11/02/blazor-css-scope/","link":"","permalink":"http://jiaming0708.github.io/2022/11/02/blazor-css-scope/","excerpt":"Blazor 的 css 作用域預設是元件內有效，那如果想要往子元件渲染的話，可以怎麼做？今天要來搞懂 Blazor 的 css scope 是怎麼樣運作，let’s go!","text":"Blazor 的 css 作用域預設是元件內有效，那如果想要往子元件渲染的話，可以怎麼做？今天要來搞懂 Blazor 的 css scope 是怎麼樣運作，let’s go! 環境:dotnet 6blazor wasm 使用 dotnet cli 來產生一個 blazor web assembly 的專案，應該可以看到以下的內容 1dotnet new blazorwasm -n blazor-css-scope 什麼都不動的情況下，有看到兩個元件有自己的 css file，一個是 MainLayout 另一個則是 NavMenu，這兩個都是基底的元件，任一個畫面都會使用到。我們就直接跑起來看看網站的 f12 是長什麼樣 1dotnet watch run 預設的行為這邊是 MainLayout.razor 內容，可以看到有 page, sidebar 這些的 class 宣告 接著打開網站開發者工具，檢視元素的部份，找到 id=&quot;app&quot; 並且打開裡面的節點，可以看到 MainLayout 這個元件，有 page, sidebar 這些的 class 宣告。 不知道你有沒有注意到一個小地方，每個元素上面都被加上了 b-jrym99nura 這個屬性，等等會用到喔！ 點到 page 的元素，看到 style 的渲染結果，原本的 page class 還被添加了一個奇怪的屬性。 1234.page[b-jrym99nura] &#123; position: relative; display: flex;&#125; blazor 為了避免各個元件的 css 互相的干擾，加上了這個機制，在該元件的每個元素上都給一個唯一的編碼作為屬性，對應的 css 也會加上這個屬性。也就是說，不同的元件，就會有不同的編碼，子元件也不會這樣就被影響到樣式。 前端三御家，其實也有差不多的作法，用來控制樣式不會互相污染 這邊我們可以用 MainLayout 裡面的 NavMenu 這個元件來看，可以發現到跟 MainLayout 的編碼不同。 跨元件渲染從前面例子可以看到 blazor 預設是不會去影響子元件，想要跨元件的話，blazor 也有提供一個關鍵字 ::deep，可以讓編譯器知道作用域是要往下影響。 寫一個元件 CssScope.razor 裡面放兩個 h1，來做為測試用。 12&lt;h1&gt;hi css&lt;/h1&gt;&lt;h1&gt;hi scope&lt;/h1&gt; 在 Index.razor 加上 CssScope 的元件。 1234567&lt;h1&gt;Hello, world!&lt;/h1&gt;Welcome to your new app.&lt;CssScope /&gt;&lt;SurveyPrompt Title=&quot;How is Blazor working for you?&quot; /&gt; 在 Index.razor.css 中去改變 h1 的顏色為紅色。 123h1 &#123; color: red;&#125; 這樣寫就如同前面所提到的只會渲染到自己的元件，底下的元件是不會理，那我們試著加上 ::deep 看看。 123::deep h1 &#123; color: red;&#125; 8bq了，底下元件沒渲染到就算，連自己都沒了，這到底有沒有實際的效果呢？不要緊張，開啟開發者工具，在 source 中可以找到專案的 css 檔案 blazor-css-scope.styles.css，屬於這個專案的樣式全部都會集中在這個檔案中。我們要從裡面來看看到底 css 被定義成什麼樣的內容，剛好第一段就是我們要找的。 1234/* /Pages/Index.razor.rz.scp.css */[b-hrxucffzsm] h1 &#123; color: red;&#125; 可以看到被編譯成擁有 b-hrxucffzsm 這個屬性底下的所有 h1 都可以套用到這個結果，那就好奇這個編碼有被套用在哪些元素身上。 只有 hellow world 的 h1 被加上編碼屬性，那依照剛剛的 css 規則來說，等於沒有任何元素是在那個編碼屬性底下。要讓 css 能應用到子元件，有幾個作法可以考慮看看 使用 ~，接在 index 編碼屬性後的 h1 都套用 這缺點就是只能是同層，如果 h1 有被其他元素包住，就沒有效果 123::deep ~ h1 &#123; color: red;&#125; 用一個元素來包住子元素，原本的 css 規則不用動 不管子元素的 h1 有幾層，都可以被套用到 1234567&lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; Welcome to your new app. &lt;CssScope /&gt;&lt;/div&gt; 這邊的觀念其實是回到了 css 規則的部份，在開發的時候善用開發者工具，可以幫助到偵錯前端的問題。 對於規則沒那麼熟悉的話，推薦可以看 Amos 的 金魚都能懂的 CSS 選取器。 Reference ASP.NET Core Blazor CSS isolation","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Blazor","slug":"Frontend/Blazor","permalink":"http://jiaming0708.github.io/categories/Frontend/Blazor/"}],"tags":[{"name":"Blazor","slug":"Blazor","permalink":"http://jiaming0708.github.io/tags/Blazor/"}]},{"title":"[dotnet framework] 如何使用 cli 執行測試","slug":"dotnet-framework-test-project-command-line","date":"2022-10-14T06:27:37.000Z","updated":"2023-03-09T14:18:38.775Z","comments":true,"path":"2022/10/14/dotnet-framework-test-project-command-line/","link":"","permalink":"http://jiaming0708.github.io/2022/10/14/dotnet-framework-test-project-command-line/","excerpt":"昨天收到同事的一個 bug，使用公司 library 所提供的方法所引發的一個錯誤，這錯誤蠻基本也蠻蝦的，雖然這個 library 已經很少再改，基於保護自己的想法，還是要幫這個方法加上測試，因為這個專案的版本還是 dotnet framework 4.5.1，希望能透過 cli 的方式在 CI 的時候跑測試。 在 cli 測試的話目前有兩種做法，第一種是新版 SDK 所提供的 dotnet cli；另一種就是 Visual Studio 的工具。","text":"昨天收到同事的一個 bug，使用公司 library 所提供的方法所引發的一個錯誤，這錯誤蠻基本也蠻蝦的，雖然這個 library 已經很少再改，基於保護自己的想法，還是要幫這個方法加上測試，因為這個專案的版本還是 dotnet framework 4.5.1，希望能透過 cli 的方式在 CI 的時候跑測試。 在 cli 測試的話目前有兩種做法，第一種是新版 SDK 所提供的 dotnet cli；另一種就是 Visual Studio 的工具。 使用 VisualStudio 的工具VS 所提供的工具其實有兩種，一個是舊的作法 mstest.exe ，另一才是 vstest.console.exe。 不管用哪一種方法，都要先編譯專案產生 dll 後才能執行。 MSTest.exe微軟已經不建議使用這個做法，找到安裝 VS 的目錄底下 Common7\\IDE\\MSTest.exe {install folder}\\Microsoft Visual Studio\\{version}\\{edition}\\Common7\\IDE\\MSTest.exe 示範的指令如下 1MSTest.exe /testcontainer:testproject\\bin\\debug\\testproject.dll 更詳細的指令介紹請參考 使用 MSTest.exe 指令來進行測試 - Yowko’s Notes VSTest.Console.exe微軟所提供比較新的做法，官方有詳細的介紹 VSTest.Console.exe command-line options - Visual Studio (Windows) | Microsoft Learn。 最後我找到的檔案目錄和官方介紹的不一樣，大家可以都試試看。 官方檔案路徑 {install folder}\\Microsoft Visual Studio\\{version}\\{edition}\\common7\\ide\\CommonExtensions\\{Platform | Microsoft} 我的檔案路徑 {install folder}\\Microsoft Visual Studio\\{version}\\{edition}\\Common7\\IDE\\Extensions\\TestPlatform 示範的指令如下 1vstest.console.exe testproject\\bin\\debug\\testproject.dll 若要指定執行的環境為 x64，可以加上參數 /platform:x64 使用 dotnet cli自從微軟推出 dotnet core 以後，也跟著推出 dotnet cli，理論上你可以使用 cli 來執行各種專案(包含 framework)，但我自己測試後發現 dotnet build&#x2F;msbuild 對於 framework 的編譯會有些錯誤，後面就沒細去看。回到這篇的主軸，可以使用 dotnet test 這個指令，來針對 framework 版本的專案進行測試，但直接執行的話什麼結果都沒，應該是專案的結構導致 dotnet cli 看不懂。 123❯ dotnet test 正在判斷要還原的專案... 所有專案都在最新狀態，可進行還原。 仔細看一下官方的文件，可以針對以下幾種來執行 [&lt;PROJECT&gt; | &lt;SOLUTION&gt; | &lt;DIRECTORY&gt; | &lt;DLL&gt; | &lt;EXE&gt;]，既然 framework 的結構讓 dotnet cli 看不懂，就跟前面一樣針對 dll 來進行測試。 12345678❯ dotnet test testproject\\bin\\Debug\\testproject.dllMicrosoft (R) Test Execution Command Line Tool 17.3.1 (x64) 版Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。正在啟動測試執行，請稍候...總共有 1 個測試檔案與指定的模式相符。已通過! - 失敗: 0，通過: 2，略過: 0，總計: 2，持續時間: 596 ms - testproject.dll (net451) 結論dotnet framework 畢竟是舊時代的產物，如果要使用新時代的東西 dotnet cli，就要稍微繞路一下，但這個前提就會是 CI server 有 dotnet cli，如果沒有的話，可以直接採用 vstest.console.exe，應該會比較好處理。 Reference 使用 MSTest.exe 指令來進行測試 - Yowko’s Notes VSTest.Console.exe command-line options - Visual Studio (Windows) | Microsoft Learn dotnet test 命令 - .NET CLI | Microsoft Learn","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"Dotnet","slug":"Backend/Dotnet","permalink":"http://jiaming0708.github.io/categories/Backend/Dotnet/"}],"tags":[{"name":"Testing","slug":"Testing","permalink":"http://jiaming0708.github.io/tags/Testing/"},{"name":"Dotnet","slug":"Dotnet","permalink":"http://jiaming0708.github.io/tags/Dotnet/"}]},{"title":"[Dotnet] 如何切換 SDK 版本","slug":"dotnet-sdk-version-swtich","date":"2022-09-06T07:00:16.000Z","updated":"2023-03-09T14:18:38.775Z","comments":true,"path":"2022/09/06/dotnet-sdk-version-swtich/","link":"","permalink":"http://jiaming0708.github.io/2022/09/06/dotnet-sdk-version-swtich/","excerpt":"DotnetCore的版本更新的很快，為了要有支援多個環境，電腦都會安裝很多的 SDK，預設 cli 會使用最新的版本，理論上新版都應該是可以支援舊版的編譯；但偏偏雨漸漸為了要測試一個功能，就安裝了 Dotnet 7 preview，結果導致原本可以編譯的專案變成失敗，而且錯誤訊息還很難看懂，還好可以指定舊版的 SDK，就可以避免掉這樣的問題。","text":"DotnetCore的版本更新的很快，為了要有支援多個環境，電腦都會安裝很多的 SDK，預設 cli 會使用最新的版本，理論上新版都應該是可以支援舊版的編譯；但偏偏雨漸漸為了要測試一個功能，就安裝了 Dotnet 7 preview，結果導致原本可以編譯的專案變成失敗，而且錯誤訊息還很難看懂，還好可以指定舊版的 SDK，就可以避免掉這樣的問題。 首先我們要先確定現在電腦中有安裝那些版本，在 cli 中下指令來取得清單，裡面包含版本號及安裝路徑。 1dotnet --list-sdks 接著可以透過 cli 來產生 global.json 的檔案，用來指定 SDK 版本。 1dotnet new globaljson 要注意的是，這個檔案會產生在你所下的目錄位置內，並不是真的在 User 底下的一個檔案，可以透過 cat 來看內容是什麼。 像是我要改成指定 6.0.300 的話，就可以開啟這個檔案，並且替換 version 的內容，存檔後可以下 dotnet --version 來確認現在版本是符合預期的。 如果只想要透過指令，也可以考慮使用 jq 這個套件來完成，或是用 vim 當然也有更快的方法，產生 global.json 時就直接指定需要的版本號。 1dotnet new globaljson --sdk-version 6.0.300 用以上的方法就可以先排除掉因為 SDK 太新導致編譯失敗的問題，不建議把這個檔案加入版控，畢竟這算是個人環境因素，另外就是如果未來專案升級，這個檔案也要砍掉或跟著調整，不然執行上就會有問題。 Reference global.json overview - .NET CLI | Microsoft Docs 如何在多個 .NET Core SDK 版本之間進行切換 (global.json) | The Will Will Web (miniasp.com)","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"DotnetCore","slug":"Backend/DotnetCore","permalink":"http://jiaming0708.github.io/categories/Backend/DotnetCore/"}],"tags":[{"name":"DotnetCore","slug":"DotnetCore","permalink":"http://jiaming0708.github.io/tags/DotnetCore/"},{"name":"SDK","slug":"SDK","permalink":"http://jiaming0708.github.io/tags/SDK/"}]},{"title":"[DotnetCore] 讀取 excel 套件整理","slug":"dotnet-core-read-excel-library","date":"2022-08-22T03:07:00.000Z","updated":"2023-03-09T14:18:38.775Z","comments":true,"path":"2022/08/22/dotnet-core-read-excel-library/","link":"","permalink":"http://jiaming0708.github.io/2022/08/22/dotnet-core-read-excel-library/","excerpt":"dotnet core 的專案現在有讀取 excel 的需求了，測試幾套後整理做法，給有需要的人。總共看了四套，其中一套在商用上是需要付費的，使用上要注意一下。","text":"dotnet core 的專案現在有讀取 excel 的需求了，測試幾套後整理做法，給有需要的人。總共看了四套，其中一套在商用上是需要付費的，使用上要注意一下。 Excel 的資料格式如下，並且定義類別。 123456class Data&#123; public string WIP &#123;get;set;&#125; public string WIP_STATUS &#123;get;set;&#125; public Detetime DEADLINE &#123;get;set;&#125;&#125; OpenXMLOfficeDev&#x2F;Open-XML-SDK: Open XML SDK by Microsoft (github.com)，由微軟自己所提供，也算是蠻成熟的套件，缺點是寫起來蠻囉嗦的；在 nuget 中搜尋 DocumentFormat.OpenXml 並且安裝到專案中。 如果是字串的話，資料會放在 ShareString Table，一開始取得的資料就會是 index。日期的話可以用 DateTime.FromOADate 做處理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var path = @&quot;D:\\Import_WIP_Example.xlsx&quot;;using var doc = SpreadsheetDocument.Open(path, false);var workbookPart = doc.WorkbookPart;var sheet = workbookPart.Workbook.Sheets.GetFirstChild&lt;Sheet&gt;();var worksheet = ((WorksheetPart)workbookPart.GetPartById(sheet.Id)).Worksheet;var sheetData = worksheet.GetFirstChild&lt;SheetData&gt;();var sharedTable = workbookPart.SharedStringTablePart.SharedStringTable;// 使用物件來承接資料var list = new List&lt;Data&gt;();// 跳過欄位名稱的 row1foreach (var row in sheetData.ChildElements.Select(x =&gt; x as Row).Skip(1))&#123; var data = new Data(); for (var i = 0; i &lt; row.ChildElements.Count; i++) &#123; var cell = row.ChildElements[i] as Cell; // 取得欄位資料 var innerText = cell.InnerText; // 只有字串的資料會在 SharedString Table，需要另外取資料 if (cell.DataType != null &amp;&amp; cell.DataType == CellValues.SharedString) &#123; SharedStringItem item = sharedTable.Elements&lt;SharedStringItem&gt;().ElementAt(Int32.Parse(innerText)); innerText = item.InnerText; &#125; // 預期 C 欄位是日期，可以用 FromOADate 來轉成 DateTime if(cell.CellReference.Value.StartsWith(&quot;C&quot;) &amp;&amp; Int32.TryParse(innerText, out var oaDate))&#123; data.DEADLINE = DateTime.FromOADate(Convert.ToInt32(oaDate)); continue; &#125; // 寫入到物件 switch (i) &#123; case 0: data.WIP = innerText; break; case 1: data.WIP_STATUS = innerText; break; &#125; &#125; // 去除空白資料 if(data.WIP == &quot;&quot; &amp;&amp; data.WIP_STATUS == &quot;&quot;) continue; list.Add(data);&#125;// 使用 LINQPad 的話可以解除註解來看資料// list.Dump(); NPOInissl-lab&#x2F;npoi: a .NET library that can read&#x2F;write Office formats without Microsoft Office installed. No COM+, no interop. (github.com)，在 nuget 搜尋 NPOI 並安裝。 相對於 OpenXML 的優點是 可以直接移除空白列 更好的日期處理 12345678910111213141516171819202122232425262728293031323334353637383940414243var path = @&quot;D:\\Import_WIP_Example.xlsx&quot;;await using FileStream fs = new(path, FileMode.Open);var xssWorkbook = new XSSFWorkbook(fs);var sheet = xssWorkbook.GetSheetAt(0);IRow headerRow = sheet.GetRow(0);int cellCount = headerRow.LastCellNum;// 使用物件來承接資料var list = new List&lt;Data&gt;();for (var i = (sheet.FirstRowNum + 2); i &lt;= sheet.LastRowNum; i++)&#123; var row = sheet.GetRow(i); if (row == null) continue; // 移除空白列 if (row.Cells.All(d =&gt; d.CellType == CellType.Blank)) continue; var data = new Data(); list.Add(data); for (var j = row.FirstCellNum; j &lt; cellCount; j++) &#123; var cell = row.GetCell(j); if (cell == null) continue; // 日期處理 if (cell.CellType == CellType.Numeric &amp;&amp; DateUtil.IsCellDateFormatted(cell)) &#123; data.DEADLINE = cell.DateCellValue; continue; &#125; switch (j) &#123; case 0: data.WIP = cell.ToString(); break; case 1: data.WIP_STATUS = cell.ToString(); break; &#125; &#125;&#125;// 使用 LINQPad 的話可以解除註解來看資料// list.Dump(); EPPlusEPPlusSoftware&#x2F;EPPlus: EPPlus 5-Excel spreadsheets for .NET (github.com)，商用需要付費；在 nuget 中搜尋 EPPlus 並且安裝。 可以快速移除空白列 資料型態可以判斷 123456789101112131415161718192021222324252627282930313233343536373839404142var path = @&quot;D:\\Import_WIP_Example.xlsx&quot;;ExcelPackage.LicenseContext = LicenseContext.Commercial;using var package = new ExcelPackage(new FileInfo(path));var sheet = package.Workbook.Worksheets[0];var startRowNumber = sheet.Dimension.Start.Row;var endRowNumber = sheet.Dimension.End.Row;var startColumn = sheet.Dimension.Start.Column;var endColumn = sheet.Dimension.End.Column;var list = new List&lt;Data&gt;();for (var currentRow = startRowNumber + 1; currentRow &lt;= endRowNumber; currentRow++)&#123; // 移除空白列 ExcelRange range = sheet.Cells[currentRow, startColumn, currentRow, endColumn]; if (range.All(c =&gt; !string.IsNullOrEmpty(c.Text)) == false) continue; var data = new Data(); list.Add(data); for (int j = startColumn; j &lt;= endColumn; j++) &#123; // 使用 Value 可以拿到日期型態 var cellValue = sheet.Cells[currentRow, j].Value; // 欄位是從 1 開始 switch (j) &#123; case 1: data.WIP = cellValue.ToString(); break; case 2: data.WIP_STATUS = cellValue.ToString(); break; case 3: data.DEADLINE = (DateTime)cellValue; break; &#125; &#125;&#125;// 使用 LINQPad 的話可以解除註解來看資料// list.Dump(); MiniExcelMiniExcel&#x2F;MiniExcel: Fast, Low-Memory, Easy Excel .NET helper to import&#x2F;export&#x2F;template spreadsheet (github.com)，在 nuget 搜尋 MiniExcel 並安裝。 算是比較新的套件，可以直接轉成物件，寫起來簡潔明瞭。 12345var path = @&quot;D:\\Import_WIP_Example.xlsx&quot;;var list = await MiniExcel.QueryAsync&lt;Data&gt;(path, startCell: &quot;A1&quot;);list = list.Where(p =&gt; p.WIP is not null &amp;&amp; p.WIP_STATUS is not null);// 使用 LINQPad 的話可以解除註解來看資料// list.Dump(); 結論以上四套，大家就看看自己的需求來使用囉，前面三套都蠻多資料可以查詢，只有最後一套 MiniExcel 就比較少，個人最後是選用 MiniExcel 這套，主要是可以搭配 EF 更快速的寫入資料庫。 Reference 使用Open XML SDK讀取Excel中的文字-黑暗執行緒 (darkthread.net) [VB] NPOI - 讀寫Excel檔案 - HackMD [C#] EPPlus 讀寫(read&#x2F;write) Excel檔案 懶人包範例程式碼 | 高級打字員的技術雲 - 點部落 (dotblogs.com.tw)","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"DotnetCore","slug":"Backend/DotnetCore","permalink":"http://jiaming0708.github.io/categories/Backend/DotnetCore/"}],"tags":[{"name":"DotnetCore","slug":"DotnetCore","permalink":"http://jiaming0708.github.io/tags/DotnetCore/"}]},{"title":"[Blazor] 上傳檔案","slug":"blazor-upload-file","date":"2022-08-11T01:18:50.000Z","updated":"2023-03-09T14:18:38.775Z","comments":true,"path":"2022/08/11/blazor-upload-file/","link":"","permalink":"http://jiaming0708.github.io/2022/08/11/blazor-upload-file/","excerpt":"本篇會介紹如何在 Blazor 使用 multipart/form-data 上傳檔案的功能，並且在 API 要如何接收。","text":"本篇會介紹如何在 Blazor 使用 multipart/form-data 上傳檔案的功能，並且在 API 要如何接收。 Blazor在 Blazor 中，有一個專門的元件叫做 InputFile 是給檔案上傳使用，其實等於 &lt;input type=&quot;file&quot;&gt;，基本上除了 OnChnage 這個是 Blazor 提供的以外，其他原生的屬性都能直接使用；像下面這個範例，就是可以選取多個 xlsx 的檔案。 1&lt;InputFile OnChange=&quot;@OnInputFileChange&quot; multiple accept=&quot;.xlsx&quot; /&gt; InputFileChangeEventArgs 對於單檔和多檔有不同做法，那不管哪一種都是會拿到 IBrowserFile 這個型別的物件。 12345private void OnInputFileChange(InputFileChangeEventArgs args)&#123; var singleFile = args.File; var multipleFiles = args.GetMultipleFiles();&#125; 接著來準備上傳的物件，要先轉成 stream 然後存到 MultipartFormDataContent 這個類別中，加入的時候記得要使用 files 作為 name；呼叫 API 時，記得要使用 PostAsync 而不是 PostAsJsonAsync，content-type 才會是正確的 multipart/form-data。 123456789101112private void OnInputFileChange(InputFileChangeEventArgs args)&#123; var singleFile = args.File; var fileContent = new StreamContent(singleFile.OpenReadStream()); fileContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType); using var formData = new MultipartFormDataContent(); // 中間的名稱記得一定要給 files formData.Add(fileContent, &quot;files&quot;, singleFile.Name); // 一定要用 PostAsync 才會是正確的 multipart/form-data await HttpClient.PostAsync(&quot;api/upload&quot;, formData);&#125; 如果要在 MultipartFormDataContent 中放入其他非檔案的資料，要先轉換成 StringContent 才行。 12using var formData = new MultipartFormDataContent();formData.Add(new StringContent(&quot;jimmy&quot;), &quot;name&quot;); Controller前端搞定以後，後端的 API 就相對的簡單，只要用 FromForm 的屬性來對應就好，檔案的話請用 List&lt;IFormFIle&gt; 作為型別也就是對應到前面所寫的 files，其他的資料則是各自對應名稱。使用 FileStream 來寫入到檔案，或是用 MemoryStream 載入到記憶體中。 123456789101112131415[HttpPost]public async Task&lt;IActionResult&gt; Upload([FromForm] List&lt;IFormFile&gt; files, [FromForm] string name)&#123; var path = $@&quot;&#123;_environment.WebRootPath&#125;\\upload\\&quot;; foreach(var file in files) &#123; // 寫入檔案 await using FileStream fs = new($&quot;&#123;path&#125;&#123;file.FileName&#125;&quot;, FileMode.Create); await file.CopyToAsync(fs); // 放在記憶體 using var ms = new MemoryStream(); await file.CopyToAsync(ms); &#125;&#125; API 後續的邏輯就看需要做些什麼，接續著做就好。 Reference ASP.NET Core Blazor file uploads | Microsoft Docs","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Blazor","slug":"Frontend/Blazor","permalink":"http://jiaming0708.github.io/categories/Frontend/Blazor/"}],"tags":[{"name":"Blazor","slug":"Blazor","permalink":"http://jiaming0708.github.io/tags/Blazor/"}]},{"title":"[c#] EF使用動態LINQ做查詢","slug":"introduce-dynamic-linq","date":"2022-08-02T06:43:07.000Z","updated":"2023-03-09T14:18:38.775Z","comments":true,"path":"2022/08/02/introduce-dynamic-linq/","link":"","permalink":"http://jiaming0708.github.io/2022/08/02/introduce-dynamic-linq/","excerpt":"LINQ 是一個好用的工具，撰寫的時候可以透過強行別的特性，讓篩選資料等的行為很輕鬆，偏偏成也強型別敗也強型別，在做查詢的時候十幾個欄位，總不可能一個一個比對，還好查到一個好用的套件 [Dynamic-LINQ](Dynamic LINQ (dynamic-linq.net))，可以解決這樣的問題。","text":"LINQ 是一個好用的工具，撰寫的時候可以透過強行別的特性，讓篩選資料等的行為很輕鬆，偏偏成也強型別敗也強型別，在做查詢的時候十幾個欄位，總不可能一個一個比對，還好查到一個好用的套件 [Dynamic-LINQ](Dynamic LINQ (dynamic-linq.net))，可以解決這樣的問題。 先來建立一個簡單的客戶類別，並產生一些資料 1234567891011121314151617181920212223242526272829303132public class Customer&#123; public int CustomerId; public string FirstName; public string LastName; public string Company;&#125;var data = new List&lt;Customer&gt;()&#123; new Customer() &#123; CustomerId = 1, FirstName = &quot;Jimmy&quot;, LastName = &quot;Ho&quot;, Company = &quot;Jimmy Company&quot;, &#125;, new Customer() &#123; CustomerId = 2, FirstName = &quot;Secret&quot;, LastName = &quot;Ho&quot;, Company = &quot;Secret note&quot;, &#125;, new Customer() &#123; CustomerId = 3, FirstName = &quot;Tina&quot;, LastName = &quot;Hu&quot;, Company = &quot;Tina Company&quot;, &#125;&#125;; 標準 Linq 的寫法，取得 Company 包含 Compnay 字樣的資料。 1var result = data.Where(p =&gt; p.Company.Contains(&quot;Ho&quot;)); 接著來安裝 Dynamic LINQ，在 Nuget 中找到 System.Linq.Dynamic.Core，並改用 Dynamic 的寫法。 如果不是 dotnet core 請直接搜尋 System.Linq.Dynamic 1var result = data.Where(&quot;Company.Contains(\\&quot;Ho\\&quot;)&quot;); 透過字串的方式，來描述原本強型別的語句，當欄位是由前端傳來只有名稱，這時候就會很好處理。使用 Dynamic LINQ 要注意的是，要參照原本 Linq 的寫法，不然就會死得不明不白。 當然這也不是沒有缺點，因為不是強型別了，所以屬性名稱寫錯的話，就要等到 runtime 才會死在旁邊。 Reference [LINQ] 使用 Dynamic LINQ 補足強型別所帶來的小遺憾 | 搞搞就懂 - 點部落 (dotblogs.com.tw) Dynamic LINQ 讓 LINQ 的世界變的更美好 | The Will Will Web (miniasp.com)","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"linq","slug":"Backend/linq","permalink":"http://jiaming0708.github.io/categories/Backend/linq/"}],"tags":[{"name":"dotnet","slug":"dotnet","permalink":"http://jiaming0708.github.io/tags/dotnet/"},{"name":"linq","slug":"linq","permalink":"http://jiaming0708.github.io/tags/linq/"}]},{"title":"[nginx] reverse proxy 在 docker compose 架構下","slug":"nginx-reverse-proxy-docker-compose","date":"2022-06-22T11:46:46.000Z","updated":"2023-03-09T14:18:38.775Z","comments":true,"path":"2022/06/22/nginx-reverse-proxy-docker-compose/","link":"","permalink":"http://jiaming0708.github.io/2022/06/22/nginx-reverse-proxy-docker-compose/","excerpt":"在非 windows 的環境下架站，nginx 會是首選，把一些服務搭配 nginx 並且使用 docker compose 作架站，也是一個不錯的選擇。今天會使用 Gitea&#x2F;Drone 這兩個服務，並且搭配 ngrok 來作為模擬。","text":"在非 windows 的環境下架站，nginx 會是首選，把一些服務搭配 nginx 並且使用 docker compose 作架站，也是一個不錯的選擇。今天會使用 Gitea&#x2F;Drone 這兩個服務，並且搭配 ngrok 來作為模擬。 前言之前寫過另一篇 在本機使用Docker架Gitea和DroneCI，用 ngrok 對應 3000 和 8000 兩個 port，如果是用 ngrok 還算方便，畢竟都還是 80&#x2F;443 的連線，但如果轉換成自己的 domain，就會變成 git.jimmy.com:3000 和 ci.jimmy.com:8000 這樣的連線方式，對於這樣的網址其實是難以接受的，那我們可以使用 reverse proxy 來達成。 之前我也是用 IIS 做 reverse proxy，gitea 相關的設定可以參考這兩篇 [IIS] 修正 reverse proxy 的 host 問題 和 [IIS] Gitea 搭配 reverse proxy 的問題排解，如果你是用 windows 10 來作為伺服器，就會遇到一個問題同時連線數過多時就會連不上的問題，這個在微軟的文件中有提到 Understanding IIS Request Restrictions on Windows Client OS | Microsoft Docs，改用 nginx 就可以忽略掉這個問題。 好啦~囉嗦完後還是要實際看看怎麼樣的實作吧! 設定使用 ngrok 作為本機架站的工具，並把 gitea&#x2F;drone 兩個服務躲在 nginx 背後，只開放 80 port 出來。 ngrok首先針對 ngrok.yml 做調整，改成設定兩個都是 80 port。 也許你會擔心不能跑，這點倒是不用擔心。 12345678authtoken: &#123;&#123;your token&#125;&#125;tunnels: gitea: addr: 80 proto: http drone: addr: 80 proto: http 執行 ngrok.exe start --all --config ngrok.yml，就可以看到以下的畫面，會有兩個 domain 都對應著 80。 docker-compose先把 domain 搞定以後，接著要來調整 docker-compose.yml 的內容，把 gitea 和 drone 對外的 port 都刪掉，改加上 nginx 並且開放 80 port 對外。 1234567891011121314151617181920212223242526272829303132333435363738394041version: &quot;3.9&quot;services: gitea: image: gitea/gitea:1.16 container_name: gitea environment: - ROOT_URL=http://1374-1-171-251-189.ngrok.io - DEFAULT_BRANCH=main restart: always volumes: - ./gitea:/data drone-server: image: drone/drone:2 container_name: drone-server volumes: - ./drone:/data restart: always environment: - DRONE_SERVER_HOST=8372-1-171-251-189.ngrok.io - DRONE_SERVER_PROTO=http - DRONE_RPC_SECRET=d733ce6f00905a05395ea8198c22234b # Gitea - DRONE_GITEA_CLIENT_ID=12d97e72-1489-4df6-a547-946ded390617 - DRONE_GITEA_CLIENT_SECRET=e7lAy3SbWAKDm5FaVIuBr6vfQQIVLXUCitkv4xLFIQIP - DRONE_GITEA_SERVER=http://1374-1-171-251-189.ngrok.io - DRONE_GIT_ALWAYS_AUTH=true nginx: image: nginx restart: always container_name: nginx ports: - &quot;80:80&quot; volumes: - ./nginx/nginx.conf:/etc/nginx/nginx.conf depends_on: - gitea - drone-servernetworks: default: name: infra nginx在 docker compose 文件 Networking in Compose | Docker Documentation 中提到，同一個 network 裡面，可以直接網內互打，不用知道另一個 container 的 ip，只要指定名稱就可以，我們就可以透過這個功能，讓 nginx 直接對應到 service。 底下是 nginx.conf 的設定。 123456789101112131415161718192021222324252627282930313233http &#123; server &#123; listen 80; listen [::]:80; server_name 1374-1-171-251-189.ngrok.io; location / &#123; proxy_pass http://gitea:3000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; &#125; server &#123; listen 80; listen [::]:80; server_name 8372-1-171-251-189.ngrok.io; location / &#123; proxy_pass http://drone-server:80; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $host; proxy_redirect off; proxy_http_version 1.1; proxy_buffering off; chunked_transfer_encoding off; &#125; &#125;&#125; Reference Usage: Reverse Proxies - Docs (gitea.io) Documentation for Drone behind SSL reverse proxy - Support - Drone Networking in Compose | Docker Documentation","categories":[{"name":"nginx","slug":"nginx","permalink":"http://jiaming0708.github.io/categories/nginx/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://jiaming0708.github.io/tags/Docker/"},{"name":"nginx","slug":"nginx","permalink":"http://jiaming0708.github.io/tags/nginx/"},{"name":"reverse-proxy","slug":"reverse-proxy","permalink":"http://jiaming0708.github.io/tags/reverse-proxy/"},{"name":"ngrok","slug":"ngrok","permalink":"http://jiaming0708.github.io/tags/ngrok/"}]},{"title":"使用 Github Action 檢查套件更新並發送 PR","slug":"github-dependabot-pr-notification","date":"2022-06-07T12:14:13.000Z","updated":"2023-03-09T14:18:38.775Z","comments":true,"path":"2022/06/07/github-dependabot-pr-notification/","link":"","permalink":"http://jiaming0708.github.io/2022/06/07/github-dependabot-pr-notification/","excerpt":"放在 Github 上面的 Repository 可以開啟相依套件的更新檢查，甚至會自動幫你發送 PR，今天來看一下怎麼樣設定並在最後發出通知。","text":"放在 Github 上面的 Repository 可以開啟相依套件的更新檢查，甚至會自動幫你發送 PR，今天來看一下怎麼樣設定並在最後發出通知。 開啟 Dependabot Github 的設定可能會改變位置，這是到目前為止的設定，如果找不到，請試著用類似的字眼去找。 到你的 Repository 中，移到 Security 頁籤，將 Dependabot alerts 啟用。 系統會帶你到 Setting 頁籤，先 Dependabot security updates 啟用，就可以看到第一個項目 Alert 也會被啟用。 接著再將 Dependabot version updates 啟用，系統會帶你去建議一個 yaml 檔案。 這邊要注意的是， package-ecosystem 是留空要自己填寫，可以在 Configuration options for the dependabot.yml file - GitHub Docs 中找到自己的套件管理，像我的是用 yarn 做管理。 做完以上的設定以後，只要 Github 檢查到相依套件中有任何危險或是更新，就會建立一個 PR。 當 PR 建立時通知當 Dependabot 建立 PR 的時候，除了上去 Github 看以外，就是要透過收信的方式，但我個人是不喜歡信件的通知，比較喜歡用通訊軟體即時的收到通知，在這時候我們就可以使用 Github Action 來做到這件事情。 剛剛啟用 Dependabot version updates 所建立的 dependabot.yml 是放在 .github 這個目錄底下，Github Action 也是一樣在這目錄底下，新增一個目錄 workflows，建立一個叫做 notify-pull-request.yml 的檔案，並將底下內容貼上。 12345678910111213141516171819202122name: Send Message on Pull Request open.on: pull_request: types: [opened, reopened]jobs: sendMessage: runs-on: ubuntu-latest steps: - uses: hmarr/debug-action@v2 - name: send telegram message uses: appleboy/telegram-action@master with: to: $&#123;&#123; secrets.TELEGRAM_CHAT_ID &#125;&#125; token: $&#123;&#123; secrets.TELEGRAM_TOKEN &#125;&#125; # 注意 tg message 長度有限制，不要放太多內容會爆掉 message: | Author: $&#123;&#123; github.event.pull_request.user.login &#125;&#125; Title: $&#123;&#123; github.event.pull_request.title &#125;&#125; Link: $&#123;&#123; github.event.pull_request.html_url &#125;&#125; 關於 Github Action 的基礎介紹，可以參考 使用 Github Action 作為 CI&#x2F;CD 將 libraray 發佈到 Github Package，或是 不僅是程式碼代管平台 - Github 能做些什麼? :: 2021 iThome 鐵人賽 根據文件 PR 預設行為是 opened, synchronize, or reopened，這邊重新設定將 synchronize 去掉。 Telegram 的設定教學可以參考 [GitHub Actions] 發送 Telegram 訊息 | 全端開發人員天梯 (fullstackladder.dev)。 接著我們要來設定 secrets，現在的設定有分為 Actions 及 Dependabot 兩個，雖然發送 PR 的通知是透過 Action，但建立 PR 的是 bot，因此兩個地方都必須要將 Telegram 的設定放進去。 都設定好以後，不管是誰建立的 PR，我們都可以在 Telegram 收到啦!! Reference Configuration options for the dependabot.yml file - GitHub Docs Events that trigger workflows - GitHub Docs [GitHub Actions] 發送 Telegram 訊息 | 全端開發人員天梯 (fullstackladder.dev) 不僅是程式碼代管平台 - Github 能做些什麼? :: 2021 iThome 鐵人賽","categories":[{"name":"Github Action","slug":"Github-Action","permalink":"http://jiaming0708.github.io/categories/Github-Action/"}],"tags":[{"name":"Github Action","slug":"Github-Action","permalink":"http://jiaming0708.github.io/tags/Github-Action/"},{"name":"Telegram","slug":"Telegram","permalink":"http://jiaming0708.github.io/tags/Telegram/"}]},{"title":"如何在 cli 快速操作 json 資料 - jq","slug":"cli-json-processor-jq","date":"2022-06-04T13:47:46.000Z","updated":"2023-03-09T14:18:38.775Z","comments":true,"path":"2022/06/04/cli-json-processor-jq/","link":"","permalink":"http://jiaming0708.github.io/2022/06/04/cli-json-processor-jq/","excerpt":"想在 cli 的環境下要對 json 的檔案做修改，如果要用一行一行讀取後處理，實在是太麻煩而且太容易改錯，還好有一套工具 jq ，可以快速的操作整個 json 資料。我把這個應用在 CI&#x2F;CD 的環節中，在當下調整一些設定檔。 jq 到哪都是強者!!!","text":"想在 cli 的環境下要對 json 的檔案做修改，如果要用一行一行讀取後處理，實在是太麻煩而且太容易改錯，還好有一套工具 jq ，可以快速的操作整個 json 資料。我把這個應用在 CI&#x2F;CD 的環節中，在當下調整一些設定檔。 jq 到哪都是強者!!! jq 可以被使用在任何一個有 cli 的 os 上 (Linux, OS X and Windows…etc.)，選取的方法是透過 filter 來進行操作，先用個簡單的範例來示範，如何取得 foo 的值。 好像看到 $jq 的影子? 12echo &#x27;&#123;&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;&#125;&#x27; | jq &#x27;.foo&#x27;&gt; 42 linux 安裝接下來將會起一個 Debian 的容器來做為示範，如何安裝並且操作。 不想安裝只是想嘗試的話可以用官方提供的線上工具 jq play 1docker run --rm -it debian 進入到容器的環境內後，開始執行安裝，記得先 update 確保安裝的時候找的到套件 12apt-get updateapt-get install -y jq 認識 filter主要會專注在介紹最後實務上要用到的功能。 根節點json 資料的格式都會有個最上層，也就是所謂的根結點，不管是陣列或是物件的形式，都是從最外層開始往內找。 12345echo &#x27;&#123;&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;&#125;&#x27; | jq &#x27;.&#x27;&gt; &#123;&gt; &quot;foo&quot;: 42,&gt; &quot;bar&quot;: &quot;less interesting data&quot;&gt; &#125; 物件操作12345678910# 單一屬性echo &#x27;&#123;&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;&#125;&#x27; | jq &#x27;.foo&#x27;&gt; 42# 屬性不存在回 nullecho &#x27;&#123;&quot;notfoo&quot;: true, &quot;alsonotfoo&quot;: false&#125;&#x27; | jq &#x27;.foo&#x27;&gt; null# 多個屬性echo &#x27;&#123;&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;&#125;&#x27; | jq &#x27;.[&quot;foo&quot;, &quot;bbb&quot;]&#x27;&gt; 42&gt; null 陣列操作12345678910# 取得整個陣列並轉成 iteratorecho &#x27;[&#123;&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true&#125;, &#123;&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false&#125;]&#x27; | jq &#x27;.[]&#x27;&gt; &#123;&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true&#125;&gt; &#123;&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false&#125;# 指定陣列位置echo &#x27;[&#123;&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true&#125;, &#123;&quot;name&quot;:&quot;XML&quot;, &quot;good&quot;:false&#125;]&#x27; | jq &#x27;.[0]&#x27;&gt; &#123;&quot;name&quot;:&quot;JSON&quot;, &quot;good&quot;:true&#125;# 切割陣列 (也可用在字串中) [start:end]echo &#x27;[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]&#x27; | jq &#x27;.[2:4]&#x27;&gt; [&quot;c&quot;, &quot;d&quot;] 資料運算+ 和 - 可以用來運算數值或是陣列&#x2F;字串的串接 12345678910111213# 運算數值echo &#x27;&#123;&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;&#125;&#x27; | jq &#x27;.foo + 3&#x27;&gt; 45echo &#x27;&#123;&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;&#125;&#x27; | jq &#x27;.foo - 2&#x27;&gt; 40# 陣列串接echo &#x27;[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]&#x27; | jq &#x27;. + [&quot;f&quot;,&quot;g&quot;]&#x27;&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;]echo &#x27;[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]&#x27; | jq &#x27;. - [&quot;a&quot;]&#x27;&gt; [&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]# 字串串接echo &#x27;&#123;&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;&#125;&#x27; | jq &#x27;.bar + &quot; concat another string&quot;&#x27;&gt; &quot;less interesting data concat another string&quot; 修改內容12echo &#x27;&#123;&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;&#125;&#x27; | jq &#x27;.foo = 44&#x27;&gt; &#123;&quot;foo&quot;: 44, &quot;bar&quot;: &quot;less interesting data&quot;&#125; 讀取檔案123echo &#x27;&#123;&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;&#125;&#x27; &gt; file.jsonjq &#x27;.foo&#x27; file.json&gt; 42 傳入參數123456# 非 json 格式echo &#x27;&#123;&quot;foo&quot;: 42, &quot;bar&quot;: &quot;less interesting data&quot;&#125;&#x27; | jq --arg concat &quot; pass from arg&quot; &#x27;.bar + $concat&#x27;&gt; &quot;less interesting data pass from arg&quot;# json 格式echo &#x27;[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]&#x27; | jq --argjson concat &#x27;[&quot;f&quot;,&quot;g&quot;]&#x27; &#x27;. + $concat&#x27;&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;] 實際修改實際上真正需要的是調整 db.json 這個檔案，先來看看資料格式。 1234567891011121314&#123; &quot;DBConfig&quot;: &#123; &quot;DefaultDB&quot;: &quot;LocalOrcl&quot;, &quot;EnableLog&quot;: true, &quot;DoNotCompleteFlag&quot;: false, &quot;DataBases&quot;: [ &#123; &quot;DBName&quot;: &quot;LocalOrcl&quot;, &quot;ConnectionString&quot;: &quot;Data Source=localhost/ORCL;USER ID=jimmy;PASSWORD=jimmy;&quot;, &quot;Provider&quot;: &quot;Oracle&quot; &#125; ] &#125;&#125; 目標是要修改 DefaultDB 的值，並且增加一組連線資訊，基本上就是把前面所提到的 filter 都用過一次。 123CONNECTION=&#x27;&#123;&quot;DBName&quot;:&quot;CI&quot;,&quot;ConnectionString&quot;:&quot;Data Source=localhost/ORCL;USER ID=CI;PASSWORD=CI;&quot;,&quot;Provider&quot;:&quot;Oracle&quot;&#125;&#x27;jq &#x27;.DBConfig.DefaultDB = &quot;CI&quot;&#x27; db.json &gt; tmp.$$.json &amp;&amp; mv tmp.$$.json db.jsonjq --arg CONNECTION &quot;$CONNECTION&quot; &#x27;.DBConfig.DataBases += $CONNECTION&#x27; db.json &gt; tmp.$$.json &amp;&amp; mv tmp.$$.json db.json 就可以看到 db.json 的內容被改成以下。 12345678910111213141516171819&#123; &quot;DBConfig&quot;: &#123; &quot;DefaultDB&quot;: &quot;CI&quot;, &quot;EnableLog&quot;: true, &quot;DoNotCompleteFlag&quot;: false, &quot;DataBases&quot;: [ &#123; &quot;DBName&quot;: &quot;LocalOrcl&quot;, &quot;ConnectionString&quot;: &quot;Data Source=localhost/ORCL;USER ID=jimmy;PASSWORD=jimmy;&quot;, &quot;Provider&quot;: &quot;Oracle&quot; &#125;, &#123; &quot;DBName&quot;: &quot;CI&quot;, &quot;ConnectionString&quot;: &quot;Data Source=localhost/ORCL;USER ID=CI;PASSWORD=CI;&quot;, &quot;Provider&quot;: &quot;Oracle&quot; &#125; ] &#125;&#125; Reference jq Manual (development version) (stedolan.github.io)","categories":[{"name":"shell","slug":"shell","permalink":"http://jiaming0708.github.io/categories/shell/"}],"tags":[{"name":"jq","slug":"jq","permalink":"http://jiaming0708.github.io/tags/jq/"},{"name":"shell","slug":"shell","permalink":"http://jiaming0708.github.io/tags/shell/"}]},{"title":"[除蟲] AngularJS button click 執行兩次","slug":"angularjs-button-ngclick-twice","date":"2022-06-02T06:39:44.000Z","updated":"2023-03-09T14:18:38.775Z","comments":true,"path":"2022/06/02/angularjs-button-ngclick-twice/","link":"","permalink":"http://jiaming0708.github.io/2022/06/02/angularjs-button-ngclick-twice/","excerpt":"同事詢問了一個 AngularJS button click 的時候會執行兩次的問題，只有在 IE 上會發生，但在 edge&#x2F;chrome 就不會。聽到這個問題，第一個反應是先去看看網路上有沒有人有類似的問題，angularjs button click execute twice ，果然我們不是孤單的，蠻多人討論過。 比較多人提到的，反而是在 safari 上會有這個行為。","text":"同事詢問了一個 AngularJS button click 的時候會執行兩次的問題，只有在 IE 上會發生，但在 edge&#x2F;chrome 就不會。聽到這個問題，第一個反應是先去看看網路上有沒有人有類似的問題，angularjs button click execute twice ，果然我們不是孤單的，蠻多人討論過。 比較多人提到的，反而是在 safari 上會有這個行為。 ngClick using ngTouch fires twice · Issue #6251 · angular&#x2F;angular.js (github.com) javascript - AngularJS ng-click fires twice - Stack Overflow javascript - Why are multiple click events fired when using ngTouch? - Stack Overflow 看到兩個方法可以解決這個問題 button 增加屬性 type=&quot;button&quot; (最後選擇這個解法) MDN 有提到 button 的 type 預設值是 submit，通常 submit 會對應到 form 的 post 行為給 API，在我們的程式中並沒有被包在 form 裡面。找到黑暗大也曾經抓過類似的問題，【茶包射手日記】當IE遇上Enter-黑暗執行緒 (darkthread.net)，提到 submit 如果沒有 form 的話會觸發 click 事件。 不管是不是 IE 或是什麼的，讓元素有正確的行為，其實是撰寫的人應該要做到的。 event.preventDefault(); event.stopPropagation(); preventDefault 或者是 stopPropagation 就很單純了，避免事件的冒泡，當然就可以解決掉重複執行的問題。 回過頭來看 angularjs 自己如何針對這個 issue 做修正，其中來看幾個原本已經改好但最後關閉的 PR fix(ngTouch): remove ngClick override by Narretz · Pull Request #13852 · angular&#x2F;angular.js (github.com) fix(ngTouch): deprecate ngClick override directive, disable it by def… by Narretz · Pull Request #13857 · angular&#x2F;angular.js (github.com) 上面兩個都是針對 ngTouch 做修改，其中還有把引入 ngClick 的檔案移除掉 (個人是蠻懷疑這是造成 submit 會重複送的原因)，最後這兩個 PR 直接被重新的調整並且放入到 1.5 的版本 AngularJS: Developer Guide: Migrating from Previous Versions。","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"AngularJS","slug":"Frontend/AngularJS","permalink":"http://jiaming0708.github.io/categories/Frontend/AngularJS/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://jiaming0708.github.io/tags/AngularJS/"},{"name":"Debug","slug":"Debug","permalink":"http://jiaming0708.github.io/tags/Debug/"}]},{"title":"[Jenkins] 環境建置 - 整合 Gitea 登入","slug":"jenkins-gitea-oauth","date":"2022-03-24T01:20:03.000Z","updated":"2023-03-09T14:18:38.775Z","comments":true,"path":"2022/03/24/jenkins-gitea-oauth/","link":"","permalink":"http://jiaming0708.github.io/2022/03/24/jenkins-gitea-oauth/","excerpt":"Jenkins 和 Gitea 的環境都建置好後，會希望登入的使用者能在一個地方控管就好， Gitea 自從 1.8 以後就開始提供 Oauth 的方法給其他系統，今天就針對這個部分來做介紹。","text":"Jenkins 和 Gitea 的環境都建置好後，會希望登入的使用者能在一個地方控管就好， Gitea 自從 1.8 以後就開始提供 Oauth 的方法給其他系統，今天就針對這個部分來做介紹。 設定 Gitea進入系統後，開啟 設定 &gt; 應用程式，拉到最下面的 管理 OAuth2 應用程式 區塊。 應用程式名稱: Jenkins 重新導向 URI: http://&#123;domain&#125;/securityRealm/finishLogin 輸入以上資訊後按下 建立應用程式。 就會拿到一組 客戶端 ID 及 密鑰 ，這個頁面先不要關閉，等一下要把這兩個資訊貼到 Jenkins 上。 建議使用公用帳號操作，避免使用者被砍掉或停用，導致後續的麻煩 設定 Jenkins安裝 PluginJenkins 的 OAuth 相關 plugin 蠻多的，但就是沒有直接對應 Gitea 的，可以選擇這套 OpenId Connect Authentication | Jenkins plugin 來作為整合的套件。進入 Manage Jenkins &gt; Plugin Manager &gt; Available，安裝套件並且重啟。 設定 Oauth安裝完套件後，進入到 Manage Jenkins &gt; Confiure Global Security，找到 Security Realm 區塊 預設應該會使用 Jenkins’ own user database ，要改成 Login with Openid Connect，並且將前面 Gitea 所產生 客戶端 ID 及 密鑰 填入，Configuration mode 選擇 Automatic confiuration 填入 Gitea 的網址。 設定完成以後，登出系統，並且回到 Jenkins 網站的跟目錄，就會發現被轉到 Gitea 網站做登入授權。 結論其實跟 DroneCI 很像，可以參考 在本機使用Docker架Gitea和DroneCI 的作法，雖然沒有直接的套件讓我們整合 Gitea，但也是能夠做到相同的事情。","categories":[],"tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"http://jiaming0708.github.io/tags/CI-CD/"},{"name":"Gitea","slug":"Gitea","permalink":"http://jiaming0708.github.io/tags/Gitea/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://jiaming0708.github.io/tags/Jenkins/"}]},{"title":"WCF AJAX 服務建置於 https","slug":"wcf-ajax-https","date":"2022-03-23T06:01:46.000Z","updated":"2023-03-09T14:18:38.771Z","comments":true,"path":"2022/03/23/wcf-ajax-https/","link":"","permalink":"http://jiaming0708.github.io/2022/03/23/wcf-ajax-https/","excerpt":"今天接到同事來的一個求救，有一個產品基於 WCF 服務建置 https 時無法正常運行，原本以為簡單，但卡了一陣子，特別來筆記一下。","text":"今天接到同事來的一個求救，有一個產品基於 WCF 服務建置 https 時無法正常運行，原本以為簡單，但卡了一陣子，特別來筆記一下。 WCF 架站於 httpsWCF 建置於 https 的資料超多超好查，微軟官方就有提供作法 How to: Configure an IIS-hosted WCF service with SSL - WCF | Microsoft Docs，看到這樣的資料立馬動手試試看。 重點是在 binding，要增加一組 basicHttpBinding ，並且設定到 endpoint 上。 123456789101112131415161718&lt;bindings&gt; &lt;basicHttpBinding&gt; &lt;binding name=&quot;secureHttpBinding&quot;&gt; &lt;security mode=&quot;Transport&quot;&gt; &lt;transport clientCredentialType=&quot;None&quot;/&gt; &lt;/security&gt; &lt;/binding&gt; &lt;/basicHttpBinding&gt;&lt;/bindings&gt;&lt;services&gt; &lt;service name=&quot;MySecureWCFService.Service1&quot;&gt; &lt;endpoint address=&quot;&quot; binding=&quot;basicHttpBinding&quot; bindingConfiguration=&quot;secureHttpBinding&quot; contract=&quot;MySecureWCFService.IService1&quot;/&gt; &lt;/service&gt;&lt;/services&gt; 設定完很開心的就打開系統，測試下去，還是一樣收到 404 的錯誤… 為了要確認問題，決定先建立一個新的 WCF 服務，並且加上同樣的設定，新的專案的確是可以順利運行。馬上回過頭檢查系統的寫法，突然發現一個不一樣的地方，服務的 endpoint 有加上 behaviorConfiguration 並且裡面的內容有 Ajax 的字樣，以及 binding webHttpBinding。 1&lt;endpoint address=&quot;&quot; behaviorConfiguration=&quot;MySecureWCFService.Service1AspNetAjaxBehavior&quot; binding=&quot;webHttpBinding&quot; contract=&quot;MySecureWCFService.Service1&quot;/&gt; 趕快拿著剛建立的專案，再新增一個檔案 WCF Service (Ajax enabled) ，馬上看到設定出現在 web.config 中。先來查詢看看官方怎麼定義 binding (System-provided bindings - WCF | Microsoft Docs)。 Binding Description BasicHttpBinding A binding that is suitable for communicating with WS-Basic Profile-conformant Web services, for example, ASP.NET Web services (ASMX)-based services. This binding uses HTTP as the transport and text&#x2F;XML as the default message encoding. WebHttpBinding A binding used to configure endpoints for WCF Web services that are exposed through HTTP requests instead of SOAP messages. 從文字描述來看，BasicHttpBinding 會回傳 xml 格式，那 WebhttpBinding 則是 json，可以確定 Ajax enabled 的意義是指這個服務 response 格式不同。 這樣就可以確定做法，要將官方給的範例調整為 WebHttpBinding ，並且設定到 endpoint 上，就可以打完收工。 12345678910111213141516171819&lt;bindings&gt; &lt;webHttpBinding&gt; &lt;binding name=&quot;secureHttpBinding&quot;&gt; &lt;security mode=&quot;Transport&quot;&gt; &lt;transport clientCredentialType=&quot;None&quot;/&gt; &lt;/security&gt; &lt;/binding&gt; &lt;/webHttpBinding&gt;&lt;/bindings&gt;&lt;services&gt; &lt;service name=&quot;MySecureWCFService.Service1&quot;&gt; &lt;endpoint address=&quot;&quot; behaviorConfiguration=&quot;MySecureWCFService.Service1AspNetAjaxBehavior&quot; binding=&quot;webHttpBinding&quot; bindingConfiguration=&quot;secureHttpBinding&quot; contract=&quot;MySecureWCFService.IService1&quot;/&gt; &lt;/service&gt;&lt;/services&gt; Reference How to: Configure an IIS-hosted WCF service with SSL - WCF | Microsoft Docs System-provided bindings - WCF | Microsoft Docs","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"}],"tags":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/tags/Backend/"},{"name":"WCF","slug":"WCF","permalink":"http://jiaming0708.github.io/tags/WCF/"},{"name":"https","slug":"https","permalink":"http://jiaming0708.github.io/tags/https/"}]},{"title":"Jenkins 與 Gitea 整合","slug":"jenkins-gitea-setup","date":"2022-03-15T07:04:59.000Z","updated":"2023-03-09T14:18:38.767Z","comments":true,"path":"2022/03/15/jenkins-gitea-setup/","link":"","permalink":"http://jiaming0708.github.io/2022/03/15/jenkins-gitea-setup/","excerpt":"Dotnet framework 的 docker image 只有 window 版本，要特別將 Docker Desktop 切換成 Windows container 才能跑，為了讓 Dotnet framework 及 Dotnet core 能同時跑在一個 CI&#x2F;CD 的平台，最後選擇了 Jenkins 這位老爺爺。 必須說老爺爺的功能很強大，但也真的很不友善…很多東西一直查資料，只好寫一篇來筆記一下orz","text":"Dotnet framework 的 docker image 只有 window 版本，要特別將 Docker Desktop 切換成 Windows container 才能跑，為了讓 Dotnet framework 及 Dotnet core 能同時跑在一個 CI&#x2F;CD 的平台，最後選擇了 Jenkins 這位老爺爺。 必須說老爺爺的功能很強大，但也真的很不友善…很多東西一直查資料，只好寫一篇來筆記一下orz 安裝 JenkinsJenkins 在 Windows 的安裝方法有兩種，第一個是透過 jenkins&#x2F;jenkins - Docker Image | Docker Hub，另一個是走標準安裝的方法，我選擇後者標準安裝的作法。 不使用 docker 是因為要 volumn 太多東西，反而造成自己困擾但很建議要先體驗的朋友，先透過 docker 環境資訊Jenkins 2.332.1 LTSWindows 11 設定使用者選完安裝目錄後，要指定一個使用者作為服務執行用，這邊我採用的是目前使用者。 輸入後得到一個錯誤訊息 This account either does not have the privilege to logon as a service or the account was unable to be verified，這表示帳號登入成功但沒有權限作為登入服務；官方的介紹在這 Windows (jenkins.io)。 接著要將登入的使用者加上可以登入服務的權限，打開 本機安全性原則(Security Configuration Management)，開啟 本機原則 &gt; 使用者權限指派 &gt; 以服務方式登入。 找到使用者後加入。 再次檢查使用者，可以往下一步了! 安裝 JAVAJenkins 需要 JAVA 的執行環境，安裝過程中會要求指定目錄，可以直接到官網下載，安裝完畢後在 Jenkins 中指向剛剛的目錄。 初始化根據安裝時所指定的 Port ，用瀏覽器開啟網站，可以看到 Unlock Jenkins 的畫面，到紅字所描述的路徑打開檔案，將裡面的密碼複製貼上。 接著要安裝 Plugin，這邊不會建議使用官方推薦的，而改用自行挑選。 裝 Jenkins 的目的是為了要可以編譯 dotnet framework，找到 Build Tools 將 MSBuild 打勾，若還有前端則需要把 NodeJS 也打勾。 往下看到 Pipelines and Continuous Delivery，整合的目標是 Gitea 因此將 Github 的兩個選項都取消。 最後，會建議將 Locale 這個套件裝起來，可以強制看到的語系不是根據瀏覽器來決定。 都挑選完畢以後，就可以開始安裝啦。 整合 Gitea都安裝完以後，進入系統，先來到 管理Jenkins &gt; 設定系統，找到 locale 的區塊將預設語言設定為 en-us，並將下面核選方塊打勾，儲存後就可以看到系統變成英文版。 我會習慣切成英文版是為了要找資料比較方便 安裝 Gitea接著要安裝 Gitea 的套件，在 Manage Jenkins &gt; Manage Plugins &gt; Available 搜尋 Gitea，打勾後選擇下方的 Download now and install after restart。 安裝後回到 Manage Jenkins &gt; Configure System，找到 Gitea Server 的區塊，點選 Add，將公司的 Gitea Server 資訊輸入進去。 官方建議勾選 Manage Hooks 並使用 Personal Token 的方式，Add &gt; Jenkins 新增 Credential Provider，Kind 選擇 Gitea Personal Access Token。 開啟 Gitea 的網站，在 設定 &gt; 應用程式 中，產生新的 Token。 複製所產生的 Token 並且回到 Jenkins 畫面貼上，最後按下儲存。 建議使用一個公用的帳號，例如: ci，來產生 Token，才可以避免權限相關的問題，也不要有人員異動後需要重新弄得問題。 連接 Repo 呼~終於要開始整合。 回到 Jenkins 主畫面，點選 NewItem，輸入名稱並選擇 Organization Folder，按下 OK。 移動到 Projects 區塊，選擇 Gitea Organization。 選擇前面所輸入的 Gitea Server 及 Credentials，Owner 輸入要納入的組織或是使用者名稱。 這邊是用自己作為設定 只要前面的所有設定都正確，系統會先掃一次整個 Owner 底下的 repo，檢查是否有 Jenkinsfile 檔案。 建立 Jenkinsfile萬事俱備，只欠東風，現在只要建立一個 Repo，並且加上 Jenkinsfile 即可。在個人使用者底下建立一個新的 Repo 叫做 JenkinsTest。 在本地開一個資料夾並且新增檔案 Jenkinsfile 將下面的內容貼上，並且 commit 後 push 上去。 123456789101112131415161718192021pipeline &#123; agent any stages &#123; stage(&#x27;Build&#x27;) &#123; steps &#123; echo &#x27;Building..&#x27; &#125; &#125; stage(&#x27;Test&#x27;) &#123; steps &#123; echo &#x27;Testing..&#x27; &#125; &#125; stage(&#x27;Deploy&#x27;) &#123; steps &#123; echo &#x27;Deploying....&#x27; &#125; &#125; &#125;&#125; 回到 Jenkins 組織的畫面，直接點選 Scan Gitea Organization Now，讓系統重新掃描一次，看到 log 就會有剛剛建立的 repo 並且發現有 Jenkinksfile 的存在。 點選左側的 Status，就可以看到 Repo 會在右側的列表中。 點進 Repo 可以看到 Branch 及 Pull Request 的狀態。 到目前這個狀態，可以確定 Gitea 及 Jenkins 的整合成功!! 寫到這邊發現篇幅有點長了，接下來的 jenkinsfile 撰寫，就挪到下一篇囉 Reference Windows (jenkins.io) Gitea | Jenkins plugin Locale | Jenkins plugin","categories":[{"name":"CI/CD","slug":"CI-CD","permalink":"http://jiaming0708.github.io/categories/CI-CD/"}],"tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"http://jiaming0708.github.io/tags/CI-CD/"},{"name":"Gitea","slug":"Gitea","permalink":"http://jiaming0708.github.io/tags/Gitea/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://jiaming0708.github.io/tags/Jenkins/"}]},{"title":"[Blazor] 元件測試 - JSRuntime、NavigationManager","slug":"blazor-testing-js-navigation","date":"2022-02-26T02:18:36.000Z","updated":"2023-03-09T14:18:38.763Z","comments":true,"path":"2022/02/26/blazor-testing-js-navigation/","link":"","permalink":"http://jiaming0708.github.io/2022/02/26/blazor-testing-js-navigation/","excerpt":"這是系列文的第四篇，今天要講的是針對 JSRuntime 及 NavigationManager 做測試。如果還沒看過前面幾篇的話，請往這邊走 [Blazor] 元件測試 - 基礎篇 [Blazor] 元件測試 - mock [Blazor] 元件測試 - Service 使用同一個 repo 接續操作","text":"這是系列文的第四篇，今天要講的是針對 JSRuntime 及 NavigationManager 做測試。如果還沒看過前面幾篇的話，請往這邊走 [Blazor] 元件測試 - 基礎篇 [Blazor] 元件測試 - mock [Blazor] 元件測試 - Service 使用同一個 repo 接續操作 JSRuntime使用 JSRuntime到目前為止，都還沒有呼叫到 JS 的部份，接著要將 Counter 的計算放到 JS 中處理。 12345678910111213141516171819202122&lt;!-- 注入JSRuntime --&gt;@inject IJSRuntime _jsRuntime;&lt;PageTitle&gt;Counter&lt;/PageTitle&gt;&lt;h1&gt;Counter&lt;/h1&gt;&lt;p role=&quot;status&quot;&gt;Current count: @CurrentCount&lt;/p&gt;&lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;&gt;Click me&lt;/button&gt;@code &#123; [Parameter] public int CurrentCount &#123; get; set; &#125; private async Task IncrementCount() &#123; // 將計算放到 JS 中，並取得回傳值 CurrentCount = await _jsRuntime.InvokeAsync&lt;int&gt;(&quot;incrementCount&quot;, CurrentCount); &#125;&#125; 建立新資料夾 js 放在 wwwroot 底下，並產生 counter.js 的檔案，準備用來寫被呼叫的函式。 1234// counter.jsfunction incrementCount(count)&#123; return count+1;&#125; 最後就是在 index.html 中引用 counter.js 即可。 1234567&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;!-- 引用剛剛寫好的檔案 --&gt; &lt;script src=&quot;js/counter.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 都寫完以後試著執行看看，確認行為是正確的就沒問題。 改寫測試案例修改後執行沒問題，試著重新測試 CounterTest.cs 的所有案例，可以看到有三個測試案例失敗。 在 bUnit 中有提供 JSInterop 來做為測試的 JSRuntime 實體，像是前面幾篇用的 mock 手法，將取代原本的函式行為。 123456789101112[Test]public void CounterShouldIncrementWhenClicked()&#123; using var ctx = new Bunit.TestContext(); // 宣告要 mock 的函式及結果 ctx.JSInterop.Setup&lt;int&gt;(&quot;incrementCount&quot;, 0).SetResult(1); var comp = ctx.RenderComponent&lt;Counter&gt;(); comp.Find(&quot;button&quot;).Click(); StringAssert.Contains(&quot;Current count: 1&quot;, comp.Markup);&#125; 也可以用另一種方法，不要馬上指定結果，而是被呼叫前再指定。 123456789101112131415161718192021222324[Test]public void CounterShouldIncrementWhenClicked_CompareWithSnapshot()&#123; using var ctx = new Bunit.TestContext(); // 先宣告好呼叫的函式 var jsruntime = ctx.JSInterop.Setup&lt;int&gt;(&quot;incrementCount&quot;, 0); var comp = ctx.RenderComponent&lt;Counter&gt;(); var button = comp.Find(&quot;button&quot;); // 使用前才給值 jsruntime.SetResult(1); button.Click(); comp.SaveSnapshot(); // 參數的部分如果不一樣，就需要重新的設定（也許有其他方法可以使用） jsruntime = ctx.JSInterop.Setup&lt;int&gt;(&quot;incrementCount&quot;, 1); jsruntime.SetResult(2); button.Click(); var diffs = comp.GetChangesSinceSnapshot(); var diff = diffs.ShouldHaveSingleChange(); diff.ShouldBeTextChange(&quot;Current count: 2&quot;);&#125; Navigation執行登入後，驗證成功後會需要導到主頁，或者是說在選單點擊了某個連結要跳轉過去，在元件的測試中，也會希望確定這樣的行為能夠被驗證。 在 blazor 中，頁面的切換是透過 NavigationManager 來操作，在 bUnit 的測試框架中，提供了 FakeNavigationManger 這個物件，來取得相關的資料。 使用 NavigationManager 做導頁在範例中，有一個元件 NavMenu.razor 提供三個頁面的連結可以點擊，將其中一個改成由 NavigationManager 來做導頁的行為。 1234567891011121314@inject NavigationManager _navMan &lt;div class=&quot;nav-item px-3&quot;&gt; &lt;NavLink class=&quot;nav-link counter&quot; @onclick=&quot;GoCounter&quot;&gt; &lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Counter &lt;/NavLink&gt; &lt;/div&gt; @code &#123; private void GoCounter() &#123; _navMan.NavigateTo(&quot;counter&quot;); &#125;&#125; 撰寫測試先寫最基本的測試案例，確保元件的內容如我們預期。 12345678[Test]public void RenderComponent()&#123; using var ctx = new Bunit.TestContext(); var comp = ctx.RenderComponent&lt;NavMenu&gt;(); StringAssert.Contains(@&quot;class=&quot;&quot;nav-link counter&quot;&quot;&quot;, comp.Markup);&#125; 接著就是來寫當按下 Counter 的連結，會透過 NavigationManager 來進行導頁的動作。 12345678910[Test]public void Navigate2CounterPage()&#123; using var ctx = new Bunit.TestContext(); var navMan = ctx.Services.GetRequiredService&lt;FakeNavigationManager&gt;(); var comp = ctx.RenderComponent&lt;NavMenu&gt;(); var menu = comp.Find(@&quot;a.counter&quot;); menu.Click(); StringAssert.Contains(&quot;/counter&quot;, navMan.Uri);&#125; Reference JSRuntime NavigationManager","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Blazor","slug":"Frontend/Blazor","permalink":"http://jiaming0708.github.io/categories/Frontend/Blazor/"}],"tags":[{"name":"Testing","slug":"Testing","permalink":"http://jiaming0708.github.io/tags/Testing/"},{"name":"Blazor","slug":"Blazor","permalink":"http://jiaming0708.github.io/tags/Blazor/"}]},{"title":"[Blazor] 元件測試 - Service","slug":"blazor-testing-service","date":"2022-01-28T01:25:36.000Z","updated":"2023-03-09T14:18:38.763Z","comments":true,"path":"2022/01/28/blazor-testing-service/","link":"","permalink":"http://jiaming0708.github.io/2022/01/28/blazor-testing-service/","excerpt":"這是系列文的第三篇，今天要講到的是針對 Service 做測試。如果還沒看過前面兩篇的話，請往這邊走 [Blazor] 元件測試 - 基礎篇、[Blazor] 元件測試 - mock。 使用上次的 repo 接續操作","text":"這是系列文的第三篇，今天要講到的是針對 Service 做測試。如果還沒看過前面兩篇的話，請往這邊走 [Blazor] 元件測試 - 基礎篇、[Blazor] 元件測試 - mock。 使用上次的 repo 接續操作 重構成 service在原本的 FetchData.razor 頁面中，是直接用 HttpClient 呼叫 API，今天的測試重點是 Service ，因此需要先將使用 HttpClient 的部分抽出成 Service。建立資料夾 Services 及檔案 IDataService.cs 。 12345678910using System.Threading.Tasks;using client.Pages;namespace client.Services&#123; public interface IDataService &#123; public Task&lt;FetchData.WeatherForecast[]?&gt; GetWeatherForecast(); &#125;&#125; 再建立一個檔案 DataService.cs 來繼承 IDataService，並且使用透過 DI 的方法取得 HttpClient。 12345678910111213141516171819202122using System.Net.Http;using System.Net.Http.Json;using System.Threading.Tasks;using client.Pages;namespace client.Services&#123; public class DataService: IDataService &#123; private HttpClient _http; public DataService(HttpClient http) &#123; _http = http; &#125; public async Task&lt;FetchData.WeatherForecast[]?&gt; GetWeatherForecast() &#123; return await _http.GetFromJsonAsync&lt;FetchData.WeatherForecast[]&gt;(&quot;sample-data/weather.json&quot;); &#125; &#125;&#125; Blazor 要用到 Service 的話需要在 Program.cs 中宣告。 12345678var builder = WebAssemblyHostBuilder.CreateDefault(args);builder.RootComponents.Add&lt;App&gt;(&quot;#app&quot;);builder.RootComponents.Add&lt;HeadOutlet&gt;(&quot;head::after&quot;);builder.Services.AddScoped&lt;IDataService, DataService&gt;(); // &lt;== 定義 DataService 及 IDataService 的關係builder.Services.AddScoped(sp =&gt; new HttpClient &#123; BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) &#125;);await builder.Build().RunAsync(); 最後一個步驟，就是將 FetchData.razor 改呼叫 Service。 12345678910111213141516@page &quot;/fetchdata&quot;@using client.Services@inject IDataService _dataService;&lt;!-- html 省略 --&gt;@code &#123; private WeatherForecast[]? forecasts; protected override async Task OnInitializedAsync() &#123; forecasts = await _dataService.GetWeatherForecast(); &#125; //...&#125; 修改測試都改完以後先執行看看，確認功能跑起來是否正確，並且檢查測試案例是否通過，不出意料測試案例果然是失敗的，因為多了一個 Service。Service 在 bUnit 中的做法跟 blazor 差不多，都是要加入 Services 的集合中。 12345678910[Test]public void RenderWithoutResponse()&#123;using var ctx = new Bunit.TestContext();ctx.Services.AddScoped&lt;IDataService, DataService&gt;(); // &lt;=== 定義 DataService 及 IDataService 的關係var mock = ctx.Services.AddMockHttpClient();var comp = ctx.RenderComponent&lt;FetchData&gt;();StringAssert.Contains(&quot;Loading...&quot;, comp.Markup);&#125; Mock ServiceDataService 是繼承 Interface，有兩種做法可以使用 建立另一個的 DataService 給測試使用 使用 MOQ &#x2F; NSubtitute 在前一篇已經安裝過 MOQ ，這邊就繼續採用他來作為測試的方法。 123456789101112131415161718[Test]public void MockService()&#123;using var ctx = new Bunit.TestContext();var mockService = new Mock&lt;IDataService&gt;();mockService .Setup(p =&gt; p.GetWeatherForecast()) .ReturnsAsync(new List&lt;FetchData.WeatherForecast&gt; &#123; new() &#123;Date = new DateTime(2022, 01, 20), TemperatureC = 15, Summary = &quot;first data&quot;&#125; &#125;.ToArray());ctx.Services.AddSingleton&lt;IDataService&gt;(mockService.Object);var comp = ctx.RenderComponent&lt;FetchData&gt;();comp.WaitForState(() =&gt; !comp.Markup.Contains(&quot;Loading...&quot;));Assert.IsNotNull(comp.Find(&quot;.table&quot;));&#125; 透過 Mock Interface 的方法搭配上使用 AddSignleton。 Reference Quickstart · moq&#x2F;moq4 Wiki (github.com) Awaiting an asynchronous state change in a component under test | bUnit","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Blazor","slug":"Frontend/Blazor","permalink":"http://jiaming0708.github.io/categories/Frontend/Blazor/"}],"tags":[{"name":"Testing","slug":"Testing","permalink":"http://jiaming0708.github.io/tags/Testing/"},{"name":"Blazor","slug":"Blazor","permalink":"http://jiaming0708.github.io/tags/Blazor/"}]},{"title":"[Blazor] 元件測試 - mock","slug":"blazor-testing-mock","date":"2022-01-21T07:40:56.000Z","updated":"2023-03-09T14:18:38.763Z","comments":true,"path":"2022/01/21/blazor-testing-mock/","link":"","permalink":"http://jiaming0708.github.io/2022/01/21/blazor-testing-mock/","excerpt":"前一篇 [Blazor] 元件測試 - 基礎篇 中已經介紹過基本的測試，今天要來介紹的是 Mock 的應用。 使用上次的 repo 接續操作","text":"前一篇 [Blazor] 元件測試 - 基礎篇 中已經介紹過基本的測試，今天要來介紹的是 Mock 的應用。 使用上次的 repo 接續操作 FetchData 頁面開啟 Pages 中的 FetchData.razor 這個元件，可以注意到 OnInitializedAsync 的部份，是透過 HttpClient 打 API 取得資料回來呈現。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@page &quot;/fetchdata&quot;@inject HttpClient Http&lt;PageTitle&gt;Weather forecast&lt;/PageTitle&gt;&lt;h1&gt;Weather forecast&lt;/h1&gt;&lt;p&gt;This component demonstrates fetching data from the server.&lt;/p&gt;@if (forecasts == null)&#123; &lt;p&gt;&lt;em&gt;Loading...&lt;/em&gt;&lt;/p&gt;&#125;else&#123; &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Date&lt;/th&gt; &lt;th&gt;Temp. (C)&lt;/th&gt; &lt;th&gt;Temp. (F)&lt;/th&gt; &lt;th&gt;Summary&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; @foreach (var forecast in forecasts) &#123; &lt;tr&gt; &lt;td&gt;@forecast.Date.ToShortDateString()&lt;/td&gt; &lt;td&gt;@forecast.TemperatureC&lt;/td&gt; &lt;td&gt;@forecast.TemperatureF&lt;/td&gt; &lt;td&gt;@forecast.Summary&lt;/td&gt; &lt;/tr&gt; &#125; &lt;/tbody&gt; &lt;/table&gt;&#125;@code &#123; private WeatherForecast[]? forecasts; protected override async Task OnInitializedAsync() &#123; forecasts = await Http.GetFromJsonAsync&lt;WeatherForecast[]&gt;(&quot;sample-data/weather.json&quot;); &#125; public class WeatherForecast &#123; public DateTime Date &#123; get; set; &#125; public int TemperatureC &#123; get; set; &#125; public string? Summary &#123; get; set; &#125; public int TemperatureF =&gt; 32 + (int)(TemperatureC / 0.5556); &#125;&#125; Mock HttpClient在測試專案中，新增一個檔案 FetchDataTest.cs，並加上一個測試案例直接針對 FetchData 這個元件的輸出來看看結果。 12345678[Test]public void RenderWithoutResponse()&#123; using var ctx = new Bunit.TestContext(); var comp = ctx.RenderComponent&lt;FetchData&gt;(); Console.WriteLine(comp.Markup);&#125; 應該會看到測試失敗，原因就是在 init 時有使用到 HttpClient。 This test requires a HttpClient to be supplied, because the component under test invokes the HttpClient during the test. The request that was sent is contained within the ‘Request’ attribute of this exception. Guidance on mocking the HttpClient is available on bUnit’s website. 要對 HttpClient 進行 mock 的話，還需要安裝另外一個 library RichardSzalay.MockHttp，打開 Nuget 管理並且加入這個套件到測試專案中。 1PM&gt; Install-Package RichardSzalay.MockHttp 建立一個檔案 MockHttpClientBunitHelpers 來實作兩個功能 註冊 HttpClient 到 Service Response 的介面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;using System.Net;using System.Net.Http;using System.Net.Http.Headers;using System.Text.Json;using Bunit;using Microsoft.Extensions.DependencyInjection;using RichardSzalay.MockHttp;namespace test;public static class MockHttpClientBunitHelpers&#123; public static MockHttpMessageHandler AddMockHttpClient(this TestServiceProvider services) &#123; var mockHttpHandler = new MockHttpMessageHandler(); var httpClient = mockHttpHandler.ToHttpClient(); httpClient.BaseAddress = new Uri(&quot;http://localhost&quot;); services.AddSingleton&lt;HttpClient&gt;(httpClient); return mockHttpHandler; &#125; public static MockedRequest RespondJson&lt;T&gt;(this MockedRequest request, T content) &#123; request.Respond(req =&gt; &#123; var response = new HttpResponseMessage(HttpStatusCode.OK); response.Content = new StringContent(JsonSerializer.Serialize(content)); response.Content.Headers.ContentType = new MediaTypeHeaderValue(&quot;application/json&quot;); return response; &#125;); return request; &#125; public static MockedRequest RespondJson&lt;T&gt;(this MockedRequest request, Func&lt;T&gt; contentProvider) &#123; request.Respond(req =&gt; &#123; var response = new HttpResponseMessage(HttpStatusCode.OK); response.Content = new StringContent(JsonSerializer.Serialize(contentProvider())); response.Content.Headers.ContentType = new MediaTypeHeaderValue(&quot;application/json&quot;); return response; &#125;); return request; &#125;&#125; 接著來修改剛剛的測試案例，在 Service 註冊 HttpClient 就可以讓測試順利通過，並且看到結果包含著 Loading… 的字串。 123456789[Test]public void RenderWithoutResponse()&#123; using var ctx = new Bunit.TestContext(); var mock = ctx.Services.AddMockHttpClient(); var comp = ctx.RenderComponent&lt;FetchData&gt;(); StringAssert.Contains(&quot;Loading...&quot;, comp.Markup);&#125; mock API使用 mock 物件提供的 When 以及剛剛所寫的 RespondJson 方法，來處理資料。 12345678910111213[Test]public void RenderWithoutResponse()&#123; using var ctx = new Bunit.TestContext(); var mock = ctx.Services.AddMockHttpClient(); mock.When(&quot;/sample-data/weather.json&quot;).RespondJson(new List&lt;FetchData.WeatherForecast&gt; &#123; new() &#123;Date = new DateTime(2022, 01, 20), TemperatureC = 15, Summary = &quot;first data&quot;&#125; &#125;); var comp = ctx.RenderComponent&lt;FetchData&gt;(); StringAssert.Contains(&quot;Loading...&quot;, comp.Markup);&#125; 可以發現這樣怎麼還是沒重新 render 拿到新的 html 結構，因為是使用非同步的方法取得資料，因此測試也需要使用非同步的方式。 12345678910111213141516[Test]public void RenderMockResponse()&#123; using var ctx = new Bunit.TestContext(); var mock = ctx.Services.AddMockHttpClient(); mock.When(&quot;/sample-data/weather.json&quot;).RespondJson(new List&lt;FetchData.WeatherForecast&gt; &#123; new() &#123;Date = new DateTime(2022, 01, 20), TemperatureC = 15, Summary = &quot;first data&quot;&#125; &#125;); var comp = ctx.RenderComponent&lt;FetchData&gt;(); comp.WaitForAssertion(() =&gt; &#123; Assert.IsNotNull(comp.Find(&quot;.table&quot;)); &#125;);&#125; 除了使用 WaitForAssertion 也可以採用另一種等待狀態變更 WaitForState 的作法，後面就能變回同步的狀態。 1234567891011121314[Test]public void RenderMockResponse_WaitState()&#123; using var ctx = new Bunit.TestContext(); var mock = ctx.Services.AddMockHttpClient(); mock.When(&quot;/sample-data/weather.json&quot;).RespondJson(new List&lt;FetchData.WeatherForecast&gt; &#123; new() &#123;Date = new DateTime(2022, 01, 20), TemperatureC = 15, Summary = &quot;first data&quot;&#125; &#125;); var comp = ctx.RenderComponent&lt;FetchData&gt;(); comp.WaitForState(() =&gt; !comp.Markup.Contains(&quot;Loading...&quot;)); Assert.IsNotNull(comp.Find(&quot;.table&quot;));&#125; Index 頁面看完 Mock HttpClient 的作法後，接著要來做 Mock Component，有時候我們可以假設 Child component 的行為都是正確的，把測試主力放在自己身上，這時候就會需要這個技巧。 開啟 Pages 中 Index.razor 的內容，裡面使用到 SurveyPrompt 元件。 123456789@page &quot;/&quot;&lt;PageTitle&gt;Index&lt;/PageTitle&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;Welcome to your new app.&lt;SurveyPrompt Title=&quot;How is Blazor working for you?&quot; /&gt; Mock Component在測試專案中，新增檔案 IndexTest.cs。在 ComponntFactories 加上要 mock 的元件，先試著 mock SurveyPrompt 看輸出內容，就可以發現那個元件的部份是完全空白。 1234567891011121314[Test]public void MockChildComp()&#123; using var ctx = new Bunit.TestContext(); ctx.ComponentFactories.AddStub&lt;SurveyPrompt&gt;(); var comp = ctx.RenderComponent&lt;Index&gt;(); Console.WriteLine(comp.Markup); /*&lt;h1&gt;Hello, world!&lt;/h1&gt;Welcome to your new app. */&#125; 可以使用 IRenderedComponent.HasComponent&lt;T&gt;() 檢查元件是否有存在，將測試案例調整一下。 12345678910[Test]public void MockChildComp()&#123; using var ctx = new Bunit.TestContext(); ctx.ComponentFactories.AddStub&lt;SurveyPrompt&gt;(); var comp = ctx.RenderComponent&lt;Index&gt;(); Assert.False(comp.HasComponent&lt;SurveyPrompt&gt;()); Assert.True(comp.HasComponent&lt;Stub&lt;SurveyPrompt&gt;&gt;());&#125; Mock content剛剛的測試是沒有任何內容，如果想要自訂內容的話，可以在 AddStub&lt;T&gt;(&quot;xxxx&quot;) 中放入字串。 12345678910[Test]public void MockChildCompContent()&#123; using var ctx = new Bunit.TestContext(); var content = &quot;&lt;div&gt;Mock SurveyPrompt&lt;/div&gt;&quot;; ctx.ComponentFactories.AddStub&lt;SurveyPrompt&gt;(content); var comp = ctx.RenderComponent&lt;Index&gt;(); StringAssert.Contains(content, comp.Markup);&#125; Mock content with parameter除了寫死的內容以外，也能夠支援傳遞參數的方法，在 AddStub 的方法內改用函式的作法，來取得並輸出參數。 123456789[Test]public void MockChildCompContentWithParameter()&#123; using var ctx = new Bunit.TestContext(); ctx.ComponentFactories.AddStub&lt;SurveyPrompt&gt;(paras =&gt; $&quot;&lt;div&gt;&#123;paras.Get(x =&gt; x.Title)&#125;&lt;/div&gt;&quot;); var comp = ctx.RenderComponent&lt;Index&gt;(); StringAssert.Contains(&quot;How is Blazor working for you?&quot;, comp.Markup);&#125; 使用第三方套件除了 bUnit 的這種作法外，也可以使用第三方的 mock 套件，像是 MOQ 及 NSubtitute。作法跟上面的類似，將 AddStub&lt;T&gt;() 改為 Add&lt;T&gt;(mock object) 。 打開 Nuget 管理將 MOQ 這個套件加入到測試專案中，這邊將使用 MOQ 做範例。 1PM&gt; Install-Package MOQ 12345678910111213[Test]public void MockComponentByMOQ()&#123; using var ctx = new Bunit.TestContext(); var mockComp = new Mock&lt;SurveyPrompt&gt;(); ctx.ComponentFactories.Add(mockComp.Object); // 另一種寫法 // ctx.ComponentFactories.Add(() =&gt; Mock.Of&lt;SurveyPrompt&gt;()); var comp = ctx.RenderComponent&lt;Index&gt;(); var actualComp = comp.FindComponent&lt;SurveyPrompt&gt;(); Assert.AreSame(mockComp.Object, actualComp.Instance);&#125; 總結今天介紹了 HttpClient 及 Component 的 mock 方法，個人覺得還要另外採用第三方套件來做 Mock 是蠻麻煩的，但官方目前的態度就是這樣，bUnit 不去依賴第三方套件。 範例程式 也放在 github 上，如果有需要也可以按照 commit 的步驟來跟著操作學習。 Reference mocking component mocking HttpClient","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Blazor","slug":"Frontend/Blazor","permalink":"http://jiaming0708.github.io/categories/Frontend/Blazor/"}],"tags":[{"name":"Testing","slug":"Testing","permalink":"http://jiaming0708.github.io/tags/Testing/"},{"name":"Blazor","slug":"Blazor","permalink":"http://jiaming0708.github.io/tags/Blazor/"}]},{"title":"將獨立的 dll 打包發佈到 nuget server","slug":"dll-publish-nuget","date":"2021-12-29T01:02:29.000Z","updated":"2023-03-09T14:18:38.759Z","comments":true,"path":"2021/12/29/dll-publish-nuget/","link":"","permalink":"http://jiaming0708.github.io/2021/12/29/dll-publish-nuget/","excerpt":"nuget 是 dotnet 的套件管理工具，就像是 npm 是屬於 nodejs 的平台一樣，在上面的版本只能升不能降，還會有所有的版本異動紀錄，可以讓專案的參考管理更為有效。有 source code 的話要做到打包其實非常的簡單，今天要分享只有 dll 的話該如何發佈到 nuget server。","text":"nuget 是 dotnet 的套件管理工具，就像是 npm 是屬於 nodejs 的平台一樣，在上面的版本只能升不能降，還會有所有的版本異動紀錄，可以讓專案的參考管理更為有效。有 source code 的話要做到打包其實非常的簡單，今天要分享只有 dll 的話該如何發佈到 nuget server。 安裝 Explorer要發佈到 nuget 前要先做打包成 *.nupkg 的檔案，有 source code 的話可以透過 nuget.exe CLI (下載 NuGet Gallery | Downloads) 來進行打包，打包後如果還要編輯 unpkg 的話，就可以透過 Nuget Package Explorer 。 目前有兩個方法可以安裝 Microsoft Store (推薦)![microsoft store].\\microsoft-store.png) Chocolatey 1choco install nugetpackageexplorer 打包 dll打開 NuGet Package Explorer 並且選擇 Create a new package 來產生一個新的檔案 接著會看到畫面分為兩個區塊 metadata: 描述 package 的基本資訊，版本、作者、說明…等。 contents: 包含在這個 package 中的內容，dotnet 版本、dll…等。 編輯 metadata點下 metadata 的左上角的 icon，進入編輯的畫面 通常會編輯幾個區塊 Id: 需要唯一名稱，不可和 nuget 平台上的重複 (同一個 Id 可以在不同的 nuget server 上，也就是 nuget.org 和 private 的可以用同一個名稱)。 Version: 每次推到 nuget server 都必須比原本的版本還要新。 Author: 作者資訊。 Description: 對於這個 package 的描述。 編輯 content要將 dll 放進去前，要先新增 lib 的資料夾 如果 dll 有指定平台或是版本，就可以選擇上面的 Add &#123;*&#125; folder ，若沒有的話，可以直接點選 Add Existing File 。我要放進去的 dll 是 framework 4.5 的版本，就先指定版本再來新增檔案。 產生 unpkg做完前面兩個步驟以後，就可以按下儲存，來產生 unpkg 的檔案。預設的檔案名稱會使用 &#123;Id&#125;_&#123;Version&#125;.unpkg ，基本上也不用去改名稱，直接找到想要的目錄底下儲存就好。 發佈最後就是將做好的內容發佈到 nuget 上啦，在上方的選單中 File 點選 Publish ，選擇要發佈的 server 及填入 api key。 心得對於一些年久失修的 dll，可以透過這樣的方法來重新打包上 nuget server，讓套件的管理更加統一。一開始操作的時候，我也有嘗試過將好幾顆 dll 一起打包，但這樣會有個缺點，一次參考就一定會所有 dll 都進去，如果每個 dll 是獨立沒有相依性的，就會建議拆開來做，避免這樣的問題發生。這些做好的 unpkg 甚至可以放進版控並且整合 CI&#x2F;CD 流程。 Reference NuGetPackageExplorer&#x2F;NuGetPackageExplorer: Create, update and deploy Nuget Packages with a GUI (github.com) [Nuget] 使用 NuGet Package Explorer 製作 Nuget 套件 ~ m@rcus 學習筆記 (marcus116.blogspot.com)","categories":[{"name":"nuget","slug":"nuget","permalink":"http://jiaming0708.github.io/categories/nuget/"}],"tags":[{"name":"nuget","slug":"nuget","permalink":"http://jiaming0708.github.io/tags/nuget/"}]},{"title":"將專案從 SVN 搬到 Git","slug":"svn-migrate-git","date":"2021-12-24T01:35:48.000Z","updated":"2023-03-09T14:18:38.759Z","comments":true,"path":"2021/12/24/svn-migrate-git/","link":"","permalink":"http://jiaming0708.github.io/2021/12/24/svn-migrate-git/","excerpt":"公司還是有舊的專案是放在 Subversion(SVN) 中，為了接下來增加一些 CI&#x2F;CD 的輔助，並且希望在 Teams 能夠集中並且即時的收到專案的資訊，就必須要做搬移的動作。 之前有做過一次，今天在做的時候又有點卡關，一定是沒有做筆記的原因!!","text":"公司還是有舊的專案是放在 Subversion(SVN) 中，為了接下來增加一些 CI&#x2F;CD 的輔助，並且希望在 Teams 能夠集中並且即時的收到專案的資訊，就必須要做搬移的動作。 之前有做過一次，今天在做的時候又有點卡關，一定是沒有做筆記的原因!! SVN 問題SVN 也有 hooks 可以發通知之類的，公司就有在 hooks 檢查 message 的格式，把 commit 的資訊推到專案管理的平台。但有點美中不足的地方是，hooks 的設定必須進去 server 然後寫 bat 之類的程式，也就是說這個設定對於新建立專案的人來說並不友善。 第二點就是 branch 的管理，每個資料夾只能同步到其中一個 branch ，如果同時有 master 和 develop，就必須要開兩個資料夾來存放，這對於開發人員真的是一個很不方便的事情。(也許可以用一個資料夾做到，如果知道的人可以跟我分享喔) 最後一點應該就是集中式管理，同事會常常要出差到客戶那，或是 VPN 到客戶的環境中作業，這時候將專案放在公司的 SVN server 上，那就會很痛苦要一直切換網路環境。 搬移環境準備電腦應該要安裝好以下這幾個軟體已經被安裝，並且開啟 terminal Subversion Git git-svn (將會透過這個工具做資訊的轉換) 作業系統為 window 10 取得所有作者資訊Git 和 SVN 對於作者描述的方法不同，第一步就要先把 SVN 的作者資訊做轉換。 Subversion users Git users 從 PowerShell (建議使用 version 7) 執行以下的指令，會將作者資訊存到檔案 authors.txt，格式會是像 jiaming = jiaming &lt;jiaming&gt; 這樣，開啟檔案將 &lt;&gt; 中的內容修改成 email 格式。 這邊要特別注意一下，檔案的編碼必須是 UTF8 (不能有 bom)，不然下一個步驟 clone 時會有找不到 author 的錯誤。 1svn.exe log --quiet | ? &#123; $_ -notlike &#x27;-*&#x27; &#125; | % &#123; &quot;&#123;0&#125; = &#123;0&#125; &lt;&#123;0&#125;&gt;&quot; -f ($_ -split &#x27; \\| &#x27;)[1] &#125; | Select-Object -Unique | Out-File -Encoding UTF8 &#x27;authors.txt&#x27; 使用 git-svn 複製接著就要將 svn 的專案轉換成 git，先在目前的專案目錄底下建立一個子目錄 gitsource ，並且執行指令。 如果只有一個主幹，那直接 git svn clone 就好 1git svn clone [svn repo] -A authors.txt ./gitsource 若專案是標準的 trunk&#x2F;branch&#x2F;tag ，那就可以加上 --stdlayout 來描述 1git svn clone [svn repo] -A authors.txt ./gitsource --stdlayout 如果 history 很多的話，就會跑比較久一點，建議就是先放著讓他跑，做其他事情去XD 轉換 ignoreSVN 也有自己的 ignore 設定，可以透過指令轉換成 .gitignore。 如果是 dotnet 可以參考這兩個 ignore 設定，for core、for vs 1234cd gitsourcegit svn show-ignore &gt; .gitignoregit add .gitignoregit commit -m &#x27;convert svn:ignore to .gitignore&#x27; 推到遠端呼~終於到最後一步啦!! 接著就是照平常 push 到遠端的作法，就可以了 12git remote add origin [git repo]git push -u origin --all Reference Migrate from Subversion (SVN) to Git - Azure Repos | Microsoft Docs 30 天精通 Git 版本控管 (29)：如何將 Subversion 專案匯入到 Git 儲存庫 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)","categories":[{"name":"Git","slug":"Git","permalink":"http://jiaming0708.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://jiaming0708.github.io/tags/Git/"},{"name":"SVN","slug":"SVN","permalink":"http://jiaming0708.github.io/tags/SVN/"}]},{"title":"[Blazor] 元件測試 - 基礎篇","slug":"blazor-testing-basic","date":"2021-12-23T14:27:50.000Z","updated":"2023-03-09T14:18:38.759Z","comments":true,"path":"2021/12/23/blazor-testing-basic/","link":"","permalink":"http://jiaming0708.github.io/2021/12/23/blazor-testing-basic/","excerpt":"寫了很多的元件來使用，但要怎麼確保行為正確，在修改的時候沒有把一些行為改壞，可以透過測試來進行保護，在 Blazor 中可以透過 bUnit 這個套件來達成。","text":"寫了很多的元件來使用，但要怎麼確保行為正確，在修改的時候沒有把一些行為改壞，可以透過測試來進行保護，在 Blazor 中可以透過 bUnit 這個套件來達成。 bUnit 可以套用在 xUnit&#x2F;NUnit&#x2F;MSTest 任何一個測試框架上，寫法不會因為框架的不同而有所差異。跟 API 或是 method 不一樣的測試目的，元件通常是由一個 click 或是外部的參數改變，而產生一些行為的變化，在元件的測試中， 環境建置在開始之前要先準備一下專案的環境，直接用 cli 來產生 blazor wasm 的專案，或者用 VS&#x2F;Rider 這種 IDE 來產生 dotnet sdk 版本為 6 1234mkdir blazor-tsting-demodotnet new sln -n blazor-testing-demodotnet new blazorwasm -n clientdotnet sln add ./client/client.csproj 接著在把測試專案也先建立好，並且增加 bunit 及 client 的參考到專案中。 我使用的是 nunit ，如果你有習慣的測試框架也可以使用沒有問題 12345dotnet new nunit -n testdotnet sln add ./test/test.csprojcd testdotnet add package bunitdotnet add test.csproj reference ../client/client.csproj 撰寫測試Render驗證不管透過 cli&#x2F;IDE 所建立出來的 blazor wasm 專案都有基本的樣板，這邊就先來看一下樣板中 Pages/Counter.razor 這個元件，有什麼樣的行為，並且如何進行測試。 123456789101112131415161718@page &quot;/counter&quot;&lt;PageTitle&gt;Counter&lt;/PageTitle&gt;&lt;h1&gt;Counter&lt;/h1&gt;&lt;p role=&quot;status&quot;&gt;Current count: @currentCount&lt;/p&gt;&lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;&gt;Click me&lt;/button&gt;@code &#123; private int currentCount = 0; private void IncrementCount() &#123; currentCount++; &#125;&#125; 在這個樣板中，主要的行為是按下 button 後 count 會加1，測試的動作，就是要模擬使用者點擊 button 後，html 應該要反映出 count 的變化。 回到測試專案中，把原本的 UnitTest1.cs 改成 CounterTest.cs ，之後我們還會繼續增加其他的測試檔案。將原本的 Test1 改成 CounterRender ，宣告一個 Bunit 的 TestContext 並且呼叫 RenderComponent 就可以取得 Counter 這個元件的 html 輸出。 123456789101112131415[Test]public void CounterRender()&#123; using var ctx = new Bunit.TestContext(); var comp = ctx.RenderComponent&lt;Counter&gt;(); Console.WriteLine(comp.Markup);/*&lt;h1&gt;Counter&lt;/h1&gt;&lt;p role=&quot;status&quot;&gt;Current count: 0&lt;/p&gt;&lt;button class=&quot;btn btn-primary&quot; blazor:onclick=&quot;1&quot;&gt;Click me&lt;/button&gt;*/&#125; 這樣的輸出結果，會發現兩個比較困難的地方 換行字元 blazer:onclick 屬性並不知道內容是什麼 我會建議採用部分比對就可以，抓到重點確定內容有符合即可，將測試案例調整如下 12345678[Test]public void CounterRender()&#123; using var ctx = new Bunit.TestContext(); var comp = ctx.RenderComponent&lt;Counter&gt;(); StringAssert.Contains(&quot;Current count: 0&quot;, comp.Markup);&#125; 互動驗證第一個測試案例寫好後，接著要來寫第二個案例，點擊 button 後 count 應該加1。從 render 出來的元件中找到需要的 element，並且進行互動。 12345678910[Test]public void CounterShouldIncrementWhenClicked()&#123; using var ctx = new Bunit.TestContext(); var comp = ctx.RenderComponent&lt;Counter&gt;(); comp.Find(&quot;button&quot;).Click(); StringAssert.Contains(&quot;Current count: 1&quot;, comp.Markup);&#125; 或者是直接拿到 p 這個 element，來驗證裡面的內容 1comp.Find(&quot;p&quot;).TextContent.MarkupMatches(&quot;Current count: 1&quot;); 比對驗證畫面有了異動，會想要知道異動的地方是不是如我們所預期，這時候可以透過比對差異的方法，有兩種作法可以做到 跟第一次比 123456789101112[Test]public void CounterShouldIncrementWhenClicked_CompareWithFirst()&#123; using var ctx = new Bunit.TestContext(); var comp = ctx.RenderComponent&lt;Counter&gt;(); comp.Find(&quot;button&quot;).Click(); var diffs = comp.GetChangesSinceFirstRender(); var diff = diffs.ShouldHaveSingleChange(); diff.ShouldBeTextChange(&quot;Current count: 1&quot;);&#125; 比對 snapshot，在比對之前要先儲存 在這邊的範例中比較展示不出來差異，因為異動的都是同一個地方。 1234567891011121314151617[Test]public void CounterShouldIncrementWhenClicked_CompareWithSnapshot()&#123; using var ctx = new Bunit.TestContext(); var comp = ctx.RenderComponent&lt;Counter&gt;(); var button = comp.Find(&quot;button&quot;); button.Click(); comp.SaveSnapshot(); button.Click(); var diffs = comp.GetChangesSinceSnapshot(); var diff = diffs.ShouldHaveSingleChange(); diff.ShouldBeTextChange(&quot;Current count: 2&quot;);&#125; 參數給值接著要來改一下功能需求，可以由外面來決定初始 Count 是多少，沒有給的話就是0。 123456789@code &#123; [Parameter] public int currentCount &#123; get; set; &#125; = 0; private void IncrementCount() &#123; currentCount++; &#125;&#125; 將剛剛所寫的幾個測試案例重跑過一遍，要確定這樣的修改是正確的。 測試通過後，再來寫傳遞參數的測試案例，有兩個方法可以傳遞參數 在 init 時就給 123456789[Test]public void CountShouldBe5_OnInit()&#123; using var ctx = new Bunit.TestContext(); var count = 5; var comp = ctx.RenderComponent&lt;Counter&gt;(parameters =&gt; parameters.Add(p =&gt; p.currentCount, count)); comp.Find(&quot;p&quot;).TextContent.MarkupMatches($&quot;Current count: &#123;count&#125;&quot;);&#125; 先 init 再給值 12345678910111213[Test]public void CountShouldBe5_AfterInit()&#123; using var ctx = new Bunit.TestContext(); var count = 5; var comp = ctx.RenderComponent&lt;Counter&gt;(); var elm = comp.Find(&quot;p&quot;); elm.TextContent.MarkupMatches(&quot;Current count: 0&quot;); comp.SetParametersAndRender(parameters =&gt; parameters.Add(p =&gt; p.currentCount, count)); elm.TextContent.MarkupMatches($&quot;Current count: &#123;count&#125;&quot;);&#125; 總結今天的重點會放在元件的基本互動，click 還有 parameter 進行測試，可以看到其實都是以 html 的變化作為測試結果的確認，也很符合元件給使用者操作的印象。 今天的 範例程式 也放在 github 上，如果有需要也可以按照 commit 的步驟來跟著操作學習。 Reference verify markup parameter","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Blazor","slug":"Frontend/Blazor","permalink":"http://jiaming0708.github.io/categories/Frontend/Blazor/"}],"tags":[{"name":"Testing","slug":"Testing","permalink":"http://jiaming0708.github.io/tags/Testing/"},{"name":"Blazor","slug":"Blazor","permalink":"http://jiaming0708.github.io/tags/Blazor/"}]},{"title":"在瀏覽器偵測裝置是否已經安裝應用程式","slug":"detect-application-installed","date":"2021-11-18T02:10:54.000Z","updated":"2023-03-09T14:18:38.759Z","comments":true,"path":"2021/11/18/detect-application-installed/","link":"","permalink":"http://jiaming0708.github.io/2021/11/18/detect-application-installed/","excerpt":"前面介紹了在瀏覽器開起應用程式及封裝應用程式，今天要來介紹的是如何在瀏覽器中偵測裝置是否已經安裝，根據狀態來決定是否要顯示不同的文字內容。 還沒有看的話，可以先回頭看看這兩篇 如何在瀏覽器開啟應用程式、透過visual studio建立安裝檔案 瀏覽器開啓應用程式是透過os層的機制處理，對於瀏覽器來說，不會回報是否開啓成功，這個部分就必須要透過其他的手法來偵測。","text":"前面介紹了在瀏覽器開起應用程式及封裝應用程式，今天要來介紹的是如何在瀏覽器中偵測裝置是否已經安裝，根據狀態來決定是否要顯示不同的文字內容。 還沒有看的話，可以先回頭看看這兩篇 如何在瀏覽器開啟應用程式、透過visual studio建立安裝檔案 瀏覽器開啓應用程式是透過os層的機制處理，對於瀏覽器來說，不會回報是否開啓成功，這個部分就必須要透過其他的手法來偵測。 實作要偵測是否開啟成功的話，就不能開在新視窗或分頁，也不能把現在頁面給換掉，這樣 script 都會失效。這邊可以透過 iframe 的方式來做包裝，將 custom protocol 丟進去，接下來偵測的行為才能夠正確。 iframe 這時候就是香阿，在其他地方使用還是要小心XD 如果有安裝的話，會跳出視窗詢問是否開啟應用程式，對於原本的頁面來算是 unfocus/blur ，大部分的瀏覽器可以透過這樣的概念來做到偵測的行為。接著來看一下基本的範例，利用 blur 的事件來判斷是否開啟，並用 timeout 來判斷是否沒安裝。 這邊要注意到 timeout 的時間，可能會因為電腦的速度而影響到 1234567891011121314151617181920212223// 利用 timeout 來判斷是否有安裝const timeout = setTimeout(function() &#123; console.log(&quot;fail to launch application&quot;); handler.remove(); &#125;, 2000);var iframe = document.querySelector(&quot;#hiddenIframe&quot;);if(!iframe) &#123; document.createElement(&quot;iframe&quot;); iframe.src = &quot;about:blank&quot;; iframe.id = &quot;hiddenIframe&quot;; iframe.style.display = &quot;none&quot;; document.appendChild(iframe);&#125;// 若離開視窗，則表示有安裝const onBlur = () =&gt; &#123; clearTimeout(timeout); handler.remove(); console.log(&quot;launch application successful&quot;);&#125;;const handler = registerEvent(window, &quot;blur&quot;, onBlur);iframe.contentWindow.location.href = &quot;jimmy://&quot;; 結論實作的概念大概是這樣，其實已經有人寫好並且包成 library 可以直接引用，想要看完整的作法就請移駕到 Custom Protocol Check in Browser 。 這個作法也適用於手機上，判斷若沒有安裝的話就提示安裝 app 這樣的概念，之前想要用的時候沒查對方向，變成是用手機開啟都會提示安裝 app ，但這樣其實蠻干擾使用者的，透過這樣的機制，能夠對使用者更加友善。","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"JavaScript","slug":"Frontend/JavaScript","permalink":"http://jiaming0708.github.io/categories/Frontend/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiaming0708.github.io/tags/JavaScript/"}]},{"title":"透過visual studio建立安裝檔案","slug":"vs-installer-project","date":"2021-11-06T07:37:49.000Z","updated":"2023-03-09T14:18:38.755Z","comments":true,"path":"2021/11/06/vs-installer-project/","link":"","permalink":"http://jiaming0708.github.io/2021/11/06/vs-installer-project/","excerpt":"前一篇 如何在瀏覽器開啟應用程式 中講到開啟應用程式，接著要來講怎麼樣封裝應用程式在安裝檔內。","text":"前一篇 如何在瀏覽器開啟應用程式 中講到開啟應用程式，接著要來講怎麼樣封裝應用程式在安裝檔內。 本篇使用的VS版本為 2019 community 英文版 （會選用英文的原因是為了有錯誤訊息時比較好找） 封裝應用程式新增Installer專案在VS 2019中預設是沒有這種的專案類型，必須要另外安裝，可以點擊 這個網址 下載或是在 Extension Manager 搜尋 Installer Project 記得要先關掉 vs 才會開始安裝 安裝重開方案後，要來新增專案，在專案範本中找到 Setup Project 並且建立 建立好後只要在專案點選編譯，就會有 install 的選項可以安裝測試了，接下來每一個步驟都會建議編譯後安裝確認效果 專案設定建立好專案以後，可以看到一個被開啟的畫面，裡面包含下面幾個項目 Application Folder User’s Desktop User’s Programs 首先要將原先的專案輸出結果放進來，點選 Application Folder 右鍵新增 Project Output 接著來改一些基本的資料，在方案總管點選專案再開啟屬性視窗 在設定 Setup Project 的過程中，建議可以把屬性視窗 pin 起來，還蠻常會用到的 加上註冊碼在專案點選右鍵找到 Registry ，開啟註冊碼的設定畫面 根據上一篇的作法，要在 HKEY_CLASSES_ROOT 底下建立，這邊我使用專案屬性中的 Manufacturer 作為 custom protocol。 專案屬性可以使用 [] 來取得 預設的值，只要將名稱留空即可 command 的執行檔名需要寫死 記得將刪除時移除註冊碼的部份啟用，這樣才不會有垃圾註冊碼在裡面 增加安裝步驟預設的安裝步驟其實很簡易，就是選安裝範圍、路徑，最後就是安裝。 在這邊我準備要新增一個步驟來輸入值，並且將資料寫入到 config 中。從專案點選右鍵找到 User Interface 。 在 Start 的區塊點右鍵 Add Dialog ，從清單中選擇一個項目來做為預計要新增的步驟，在這邊我選擇的是 Textboxes(A) 。 就可以看到 Start 的區塊增加了一個 Textboxes(A) 在最後一個項目，可以用滑鼠拖拉改變順序到第三個步驟。 接著打開 屬性視窗 來修改基本設定，可以看到可調整的程度很低，只有四個輸入框及畫面的標題這幾個項目而已，連位置什麼的都不能改變。（這邊就先不改任何設定） 使用 Custom action 修改 exe.config前面所講到的都是透過介面的方式來操作，在這個專案中提供 Custom action 的功能，可以透過寫程式的方法來做更多的事情。 設定 Custom action同樣的在專案右鍵中找到 Custom Actions 並且開啟，並且在 Install 的地方點選右鍵 Add Custom Action，選擇前面在 Application Folder 中所建立的 Output 即可。 接著要把安裝步驟中輸入的值，可以讓後面的程式可以讀取，選到剛剛所加入的 Output 並開啟 屬性視窗 ，將欄位的名稱用這樣的格式包裝 value=[name] 寫到 CustomActionData 中。 新增 Installer Class設定完畢以後，若直接這樣安裝，會發現報錯，因為缺少了一個程式的檔案，接著回到來源的專案新增檔案 Installer Class 。 開啟剛新增的檔案，可以看到裡面的程式會是這樣的。 12345678[RunInstaller(true)]public partial class Installer1 : System.Configuration.Install.Installer&#123; public Installer1() &#123; InitializeComponent(); &#125;&#125; 剛剛是在 Installer 設定輸出，在這邊同樣要對應的寫方法，可以透過 override 的方式來增加方法。相關的作法可以參考 MSDN 的文件。 修改config先透過 Context.Parameters 的方法來取得剛剛所設定在 CustomActionData 中的值，接著使用 ExeConfigurationFileMap 取得 config 並且回寫。 System.Diagnostics.Debugger.Launch() 可以用來在安裝過程中偵錯，是一個好用的技巧。 1234567891011121314151617181920// 可以避免寫入config檔的時候失敗// [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand)] public override void Install(IDictionary stateSaver) &#123; base.Install(stateSaver); // 偵錯時可以取消註解使用 //System.Diagnostics.Debugger.Launch(); var value1 = Context.Parameters[&quot;value1&quot;]; //尋找安裝路徑中的App.config檔 var exeConfigurationFileMap = new ExeConfigurationFileMap(); exeConfigurationFileMap.ExeConfigFilename = Context.Parameters[&quot;assemblypath&quot;] + &quot;.config&quot;; var config = ConfigurationManager.OpenMappedExeConfiguration(exeConfigurationFileMap, ConfigurationUserLevel.None); //將參數值寫回App.config檔 config.AppSettings.Seetings[&quot;Value1&quot;].Value = value1; config.Save(); &#125; 使用數位簽章增加信任度剛製作完的 msi 檔案，直接放在網站上讓人下載，會被瀏覽器認為是不信任的檔案，使用者必須經過重重關卡才能真正拿到安裝檔瀏覽器怕使用者誤下載一個執行檔，導致電腦出問題，因此會在下載後檢查檔案是否包含合法的數位簽章。 為了避免這樣的問題，必須要加上數位簽章 (code sign)，讓瀏覽器認可。因為這邊是公司其他部門的同事處理，就直接讓大家看一下有數位簽章會是什麼樣子。 結論微軟提供的這個專案很陽春，很適合一些簡單需求的人使用，若有要比較客製化的步驟，則不建議使用。也是透過這次的實作才知道，原來瀏覽器會檢查簽章的合法與否，來避免使用者暴露於風險之中。 Reference [Visual Studio] 應用程式佈署大作戰 - 為Setup Project加入自訂的對話視窗以修改App.config的內容 | Ouch@點部落 - 點部落 (dotblogs.com.tw) 如何透過 C# 類別庫讀取 Web.config 或 App.config 的參數設定值 | The Will Will Web (miniasp.com) 如何將自訂參數傳入 Installer 類別的 Install 方法 ( Part 2 ) | The Will Will Web (miniasp.com) 程式學習筆記: 幫自己的exe檔建立自己的數位簽章 (limitx5.blogspot.com)","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"}],"tags":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/tags/Backend/"},{"name":"installer","slug":"installer","permalink":"http://jiaming0708.github.io/tags/installer/"},{"name":"VS2019","slug":"VS2019","permalink":"http://jiaming0708.github.io/tags/VS2019/"}]},{"title":"如何在瀏覽器開啟應用程式","slug":"browser-open-application","date":"2021-10-11T02:31:38.000Z","updated":"2023-03-09T14:18:38.755Z","comments":true,"path":"2021/10/11/browser-open-application/","link":"","permalink":"http://jiaming0708.github.io/2021/10/11/browser-open-application/","excerpt":"現在越來越多的服務會直接用網頁來開啟應用程式（例如 zoom&#x2F;teams），不管是在手機或是電腦中，這篇主要就是要來分享在 windows 中如何做到這件事情。","text":"現在越來越多的服務會直接用網頁來開啟應用程式（例如 zoom&#x2F;teams），不管是在手機或是電腦中，這篇主要就是要來分享在 windows 中如何做到這件事情。 這會是一個系列文，將會介紹如何做安裝程式並且在頁面中自動偵測是否能夠開啟應用程式 我們都知道一般上網的時候都是採用 http 的協定，來瀏覽網頁，如果說你曾經有用過 ftp 這樣的服務，應該記得瀏覽器是能夠直接連 ftp 伺服器。 http://www.google.comftp://localhost 在前面的 http &#x2F; ftp 都是屬於一種 URL 協定，那要開啟應用程式，我們也能夠制定這樣的協定，讓系統認識並且啟動我們所需要的指令或程式。 註冊應用程式在 windows 中，登陸編輯程式 是一個很強大的功能，我們要讓系統認識新的 URL 協定，就必須透過他來進行。 首先，我們來參考一下 zoom&#x2F;teams 的作法，開啟 登陸編輯程式 後到 HKEY_CLASSES_ROOT 底下，找到 zoommtg 或者 ms-teams 就可以看到像下圖 嘗試匯出成檔案，來看一下內容有些什麼 123456789101112Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\ms-teams]&quot;URL Protocol&quot;=&quot;&quot;@=&quot;URL:ms-teams&quot;[HKEY_CLASSES_ROOT\\ms-teams\\shell][HKEY_CLASSES_ROOT\\ms-teams\\shell\\open][HKEY_CLASSES_ROOT\\ms-teams\\shell\\open\\command]@=&quot;\\&quot;C:\\\\Users\\\\Jimmy\\\\AppData\\\\Local\\\\Microsoft\\\\Teams\\\\current\\\\Teams.exe\\&quot; \\&quot;%1\\&quot;&quot; 最上面的那層機碼就是協定名稱，必須要跟裡面的 URL 相同，並且指定為 URL Protocol，並在 command 指定要啟動的應用程式。來試著在瀏覽器中輸入 ms-teams:\\\\ ，可以看到提示是否開啟 Microsoft Teams。 透過上面的範例就可以知道，如何產生一個新的協定 jimmy-test，接著我們來試著建立一個新的協定，並且開啟 vscode 這個應用程式。 123456789101112Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\jimmy-test]&quot;URL Protocol&quot;=&quot;&quot;@=&quot;URL:jimmy-test&quot;[HKEY_CLASSES_ROOT\\jimmy-test\\shell][HKEY_CLASSES_ROOT\\jimmy-test\\shell\\open][HKEY_CLASSES_ROOT\\jimmy-test\\shell\\open\\command]@=&quot;\\&quot;D:\\\\Programes\\\\Microsoft VS Code\\\\Code.exe\\&quot; \\&quot;%1\\&quot;&quot; 儲存成 reg 檔以後執行，並且在瀏覽器中輸入 jimmy-test:// 就可以看到開啟 vscode 的提示，是不是很簡單呢。 %1 的值會等於瀏覽器中輸入的值，例如 jimmy-test://123，在你的應用程式中，就必須要用這樣的網址做解析 如果是在手機的 app ，則是在開發時，就要對外宣告有這樣的協定可以使用，ios&#x2F;android都有支援，在瀏覽器端作法則是不變 Reference Launching applications using custom browser protocols – Shotgun Support (shotgunsoftware.com) 使用 URL 開啟 Windows 應用程式","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://jiaming0708.github.io/tags/Windows/"},{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/tags/Frontend/"},{"name":"browser","slug":"browser","permalink":"http://jiaming0708.github.io/tags/browser/"}]},{"title":"[Design Pattern] facade(外觀) 和 interpreter(直繹器) 以及 mediator(協調者)","slug":"design-pattern-facade-mediator-interpreter","date":"2021-08-06T02:29:54.000Z","updated":"2023-03-09T14:18:38.755Z","comments":true,"path":"2021/08/06/design-pattern-facade-mediator-interpreter/","link":"","permalink":"http://jiaming0708.github.io/2021/08/06/design-pattern-facade-mediator-interpreter/","excerpt":"繼上篇 [Design Pattern] Observer(觀察者)、Decoractor(裝飾器)，我們接著繼續看其他的模式 迷之音:也隔太久了吧!!! Facade 外觀 Mediator 協調者 Interpreter 直譯器","text":"繼上篇 [Design Pattern] Observer(觀察者)、Decoractor(裝飾器)，我們接著繼續看其他的模式 迷之音:也隔太久了吧!!! Facade 外觀 Mediator 協調者 Interpreter 直譯器 Facade (外觀)目的這個模式重點是封裝，只讓使用者看到外觀(表層)，這件事情其實大家都很常在做，尤其是當某個事件一定要執行固定邏輯時，那這樣我們就會想要把那些邏輯集中起來，讓外面呼叫端可以固定行為。 情境那用一點現實的例子來看，用便當商店買東西來做說明，你可能會買咖啡&#x2F;便當或是其他東西，不管哪一種的行為都是只有對應店員，剩下的煮咖啡&#x2F;加熱，都會由店員來處理。 實作 ❯ dotnet run—買餅乾—結帳囉—買咖啡—結帳囉咖啡好了—買便當—結帳囉加熱完成 Mediator (協調者)目的將原本互相交錯的溝通，向上抽一層，統一由第三方來轉接收並且轉交。 情境以現實的世界來看，其實工作中就很多這樣的狀況，工程師、設計師、行銷，老闆除了要跟這些人說明他要的是什麼，同時也要接收他們的狀況回報，並且這些人彼此間也需要互相更新狀態。對於老闆來說，不需要一直收到那麼多的訊息，這時候我們會獨立一個角色叫做 PM ，由這個人來負責所有的資訊，彼此間也不用丟出各種訊息給不必要的人，統一由新的角色來做處理，對於老闆來說，也只要叫PM回報狀況就好。 實作 ❯ dotnet rundesigner receive login completed from Engineermarketing receive login completed from Engineerengineer receive home page mockup ready from Designermarketing receive home page mockup ready from Designer Interpreter (直譯器)目的偶爾在系統中，會需要一些簡單的文字解析，這時候可以使用這個設計模式來輔助我們，讓後面要擴充的時候更為容易。但效能不是第一考量，因此有效能的需求就應該要重新思考是否適用。 情境有一組字串，裡面的資料可能要轉換成中文或是英文 實作 ❯ dotnet run二零二一 to 20212021 to 二零二一","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://jiaming0708.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://jiaming0708.github.io/tags/Design-Pattern/"}]},{"title":"[Blazor] 客製化元件","slug":"blazor-customize-component","date":"2021-07-03T01:27:13.000Z","updated":"2023-03-09T14:18:38.755Z","comments":true,"path":"2021/07/03/blazor-customize-component/","link":"","permalink":"http://jiaming0708.github.io/2021/07/03/blazor-customize-component/","excerpt":"不管是哪一個前端的框架或套件，寫一個專屬於自己專案的元件，是很基本的行為，今天要來分享的是在 Blazor 中建立元件的一些小撇步。","text":"不管是哪一個前端的框架或套件，寫一個專屬於自己專案的元件，是很基本的行為，今天要來分享的是在 Blazor 中建立元件的一些小撇步。 two-way binding (雙向綁定)基本使用Blazor 是一個標榜可以做到雙向綁定的一個前端框架，先來看看最基本的範例，使用 bind 這個前綴就可以做到雙向綁定，等於是把 value 以及 onchange 做整合。 123456&lt;input @bind=&quot;data&quot; /&gt;&lt;input value=&quot;@data&quot; @onchange=&quot;@((ChangeEventArgs __e) =&gt; data = __e.Value.ToString())&quot; /&gt;@code &#123; string data;&#125; 透過上面的範例，可以發現到這兩個行為是相同的，從這邊可以理解到所謂的雙向綁定，也就是將做到輸入以及資料的輸出兩個行為做結合。 元件雙向綁定根據上面的行為，我們要來嘗試所謂的雙向綁定，在 blazor 中有一個規則，只要事件的名稱結尾是 Changed 就可以搭配 bind 做雙向綁定。 底下我們先寫一個元件來測試雙向綁定是否正確，元件的名稱就直接叫做 Jimmy.razor，並且公開一個屬性叫做 Value。 1234567891011&lt;button @onclick=&quot;clickChange&quot;&gt;change value&lt;/button&gt;@code &#123; [Parameter] public string Value &#123; get; set; &#125; [Parameter] public EventCallback&lt;string&gt; ValueChanged &#123; get; set; &#125; void clickChange() &#123; ValueChanged.InvokeAsync(&quot;jimmy&quot;); &#125;&#125; 我們就在另一個元件中使用剛剛所制定的 Jimmy 這個元件，並且將資料輸出在畫面上。 12345678@page &quot;/&quot;&lt;Jimmy @bind-Value=&quot;data&quot; /&gt;&lt;span&gt;hi @data&lt;/span&gt;@code &#123; string data;&#125; 執行以後應該可以看到像下面的結果，雙向綁定的行為是成功的。 多層雙向綁定接著我們要寫一個元件叫做 TextField.razor，裡面會包含 label 以及 input，並且希望能夠直接將 input 的資料做雙向綁定。 如果只照著前面的做法來做，會遇到一個問題，input 本身有雙向綁定，會需要一個屬性來承接，但又要能直接跟開放出去的屬性作連接，這時可以使用一個新的屬性來做關聯。 1234567891011121314&lt;label&gt; @Text &lt;input @bind=&quot;Data&quot; /&gt;&lt;/label&gt;@code &#123; [Parameter] public string Text &#123; get; set; &#125; [Parameter] public string Value &#123; get; set; &#125; [Parameter] public EventCallback&lt;string&gt; ValueChanged &#123; get; set; &#125; string Data &#123; get =&gt; Value; set =&gt; ValueChanged.InvokeSync(value); &#125;&#125; 參數未定義參數如果是很明確所要開放的參數，通常我們會直接定義屬性，但 html 原生的屬性，就不會想要用這樣的方式一個一個去做開放，我們可以將 ParameterAttribute 的屬性 CaptureUnmatchedValues 設定為 true，就可以拿到剩下未定義但外面有傳的參數。 123456&lt;div @attributes=&quot;Attributes&quot; id=&quot;test&quot; /&gt;@code &#123; [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary&lt;string, object&gt; Attributes &#123; get; set; &#125;&#125; 1&lt;TextField id=&quot;jimmy&quot; /&gt; 這邊可以看到輸出的 id 會是 test 而不是 jimmy ，要特別注意的是定義的順序，會影響到輸出的結果，如果希望以外面定義的為主，那就要把 @attributes 放在最後面。 重新組合 class元件通常會有自己的樣式，也會提供給外面覆寫 class，我們可以透過上一個方法所定義的屬性，來取得外面所定義的 class。 1234567891011121314151617&lt;div class=&quot;@GetClass()&quot; /&gt;@code &#123; [Parameter(CaptureUnmatchedValues = true)] public IReadOnlyDictionary&lt;string, object&gt; Attributes &#123; get; set; &#125; string GetClass() &#123; var baseClass = &quot;d-flex flex-column&quot;; if (Attributes != null &amp;&amp; Attributes.TryGetValue(&quot;class&quot;, out var @class) &amp;&amp; !string.IsNullOrEmpty(Convert.ToString(@class))) &#123; return $&quot;&#123;baseClass&#125; &#123;@class&#125;&quot;; &#125; return baseClass; &#125;&#125; 使用樣板在寫元件時，為了要開放給使用者決定部分區的內容，我們可以透過開放樣板屬性的方式來達成， RenderFragment 這個類別可以來承接 html 的內容。 使用預設名稱只有屬性名稱叫做 ChildContent ，使用端才能省略不用屬性名稱包住內容。 12345678&lt;!-- JimmyTemplate.razor --&gt;&lt;div class=&quot;button-wrapper&quot;&gt; @ChildContent&lt;/div&gt;@code &#123; [Parameter] public RenderFragment ChildContent &#123; get; set; &#125;&#125; 1234&lt;JimmyTemplate&gt; &lt;button&gt;confirm&lt;/button&gt; &lt;button&gt;cancel&lt;/button&gt;&lt;/JimmyTemplate&gt; 非預設名稱不管有幾個樣板，只要屬性名稱不叫 ChildContent ，使用端都要使用屬性名稱包住。 12345678&lt;!-- JimmyTemplate.razor --&gt;&lt;div class=&quot;button-wrapper&quot;&gt; @CustomWrapper&lt;/div&gt;@code &#123; [Parameter] public RenderFragment CustomWrapper &#123; get; set; &#125;&#125; 123456&lt;JimmyTemplate&gt; &lt;CustomWrapper&gt; &lt;button&gt;confirm&lt;/button&gt; &lt;button&gt;cancel&lt;/button&gt; &lt;/CustomWrapper&gt;&lt;/JimmyTemplate&gt; 參考 ASP.NET Core Razor components | Microsoft Docs radzenhq&#x2F;radzen-blazor: The home of the Radzen Blazor components. (github.com)","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Blazor","slug":"Frontend/Blazor","permalink":"http://jiaming0708.github.io/categories/Frontend/Blazor/"}],"tags":[{"name":"Blazor","slug":"Blazor","permalink":"http://jiaming0708.github.io/tags/Blazor/"}]},{"title":"在blazor中使用JavaScript","slug":"blazor-interoperability-js","date":"2021-06-27T02:08:40.000Z","updated":"2023-03-09T14:18:38.755Z","comments":true,"path":"2021/06/27/blazor-interoperability-js/","link":"","permalink":"http://jiaming0708.github.io/2021/06/27/blazor-interoperability-js/","excerpt":"最近都在使用一個很新的前端框架，叫做 Blazor ，是由微軟所推出給 dotnet 的開發人員所用，優點是可以使用一個語言打天下(迷之音: 真的能嗎?)，但現在的 Blazor 還太年輕，對應的東西都還沒那麼齊全，JavaScript 反而已經擁有很多套件&#x2F;方法可以使用，今天就一起來看看怎麼將兩個結合一起使用。","text":"最近都在使用一個很新的前端框架，叫做 Blazor ，是由微軟所推出給 dotnet 的開發人員所用，優點是可以使用一個語言打天下(迷之音: 真的能嗎?)，但現在的 Blazor 還太年輕，對應的東西都還沒那麼齊全，JavaScript 反而已經擁有很多套件&#x2F;方法可以使用，今天就一起來看看怎麼將兩個結合一起使用。 環境dotnet core 5blazor webassembly 基本使用首先，先來介紹一點基本的應用，如何在 Blazor 呼叫 JS。先準備好一個 index.js 的檔案，並且在 html 中載入。接下來的 js 範例都會放在這個檔案中。 12345&lt;html&gt; &lt;head&gt; &lt;script src=&quot;./scripts/index.js&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;/html&gt; 呼叫方法Blazor 是一個以 dotnet 為基底的框架，因此沒有辦法直接呼叫 js，要使用 IJSRuntime 這個介面，裡面提供的 InvokeAsync 或是 InvokeVoidAsync 兩個方法。然後有一點要特別注意，不管是哪一個方法都只能呼叫 function ，因此要把需要執行的指令包裝過，先來宣告一個 function 叫做 HelloWorld。 123function HelloWorld()&#123; console.log(&#x27;hello world&#x27;);&#125; 接著在 Blazor 使用點擊按鈕來呼叫js。 1234567891011@page &quot;/sample&quot;@inject IJSRuntime JS&lt;button @onclick=&quot;clickConsole&quot;&gt; console &lt;/button&gt;@code &#123; async Task clickConsole() &#123; await JS.InvokeVoidAysnc(&quot;HelloWorld&quot;); &#125;&#125; 傳遞參數通常我們會希望把資料丟給 js 或是從 js 拿到一些回傳值，先來看看怎麼把資料傳給 js。在 InvokeVoidAsync 的第二個參數開始，就是傳給 js function 的所有參數。 123function HiName(name)&#123; console.log(`Hi! $&#123;name&#125;`);&#125; 1234async Task clickConsole()&#123; await JS.InvokeVoidAysnc(&quot;HiName&quot;, &quot;jimmy&quot;);&#125; 接受回傳值那如果說，我們要拿到 js 的回傳值，就要改用 InvokeAsync 這個方法才能接收到。 1234function getElementHeight(id) &#123; const elm = document.querySelector(`#$&#123;id&#125;`); return elm.offsetHeight;&#125; 1234async Task clickConsole()&#123; var height = await JS.InvokeAysnc&lt;int&gt;(&quot;getElementHeight&quot;, &quot;block1&quot;);&#125; 動態載入執行到某個頁面的時候才載入一些 js 的檔案，減少第一次不必要的下載，對於前端來說是蠻常見的事情，在 blazor 中當然也有提供這樣的方法。 這邊準備另一個檔案叫做 module.js ，然後將前面的 HelloWorld 放進去，來測試看看。 嘗試在 blazor 這邊的做法其實一樣，沒有其他的方法可以使用，但參數要稍微改一下，第一個參數使用 import ，第二個參數給路徑，然後回傳的值就會是整個 module 的物件，。 12345async Task clickConsole()&#123; var jsmodule = await JS.InvokeAysnc&lt;IJSObjectReference&gt;(&quot;import&quot;, &quot;./scripts/module.js&quot;); jsmodule.InvokeVoidAysnc(&quot;HelloWorld&quot;);&#125; 寫法調整如果你按照這樣寫，應該會得到錯誤，找不到 HelloWorld 這個方法。原因是使用 module 的作法，整個就會是封閉的，外面如果要調用，就必須要加上 export。 如果對於 module 的寫法不太熟悉，可以參考一下 MDN 的文件，JavaScript modules 123export function HelloWorld()&#123; console.log(&#x27;hello world&#x27;);&#125; 應用分享最後來分享幾個自己在開發上會使用到的技巧&#x2F;應用。 傳入 blazor 自己在使用 chart 套件的時候，很常會有互動的行為，那就會需要從套件中來呼叫 blazor 的方法，官方有給出幾個做法，這邊我只介紹其中之一，個人覺得最乾淨的。產生一個該類別的物件，再傳遞給 js 來作為回呼的物件。 1234567891011async Task clickDraw()&#123; var objRef = DotNetObjectReference.Create(this); var height = await JS.InvokeAysnc&lt;int&gt;(&quot;DrawChart&quot;, objRef);&#125;[JSInvokable]public void onClick()&#123; // ...&#125; 1234567function DrawChart(dotnetHelper)&#123; new Chart(&#x27;#chart&#x27;, &#123; on_click: function()&#123; dotnetHelper.invokeMethodAsync(&#x27;onClick&#x27;); &#125; &#125;);&#125; 回傳的物件型態從 js 的回傳物件中，如果不是基礎類別，也是可以透過類別來轉型，但這樣的物件再次丟回給 js 時，會導致無法正常找到一些 property，這時候可以使用 IJSObjectReference 這個型別。 1234567function DrawChart(dotnetHelper)&#123; return new Chart(&#x27;#chart&#x27;, &#123; on_click: function()&#123; dotnetHelper.invokeMethodAsync(&#x27;onClick&#x27;); &#125; &#125;);&#125; 12345async Task clickDraw()&#123; var objRef = DotNetObjectReference.Create(this); var chartObj = await JS.InvokeAysnc&lt;IJSObjectReference&gt;(&quot;DrawChart&quot;, objRef);&#125; 動態載入的動態載入在檔案載入的時候，希望能夠直接初始化做一些事情，例如引入第三方套件的 js&#x2F;css，在這邊我們要使用 js 的一個技巧叫做 IIFE (立即執行函式)，並且使用 createElement 的作法來做到在檔案載入後才去引入對應的 js&#x2F;css。 12345678910111213141516171819(function (d, id) &#123; // not create script element again if existing if (d.getElementById(id)) &#123; return; &#125; const headElm = d.getElementsByTagName(&quot;head&quot;)[0] const linkElm = d.createElement(&quot;link&quot;); linkElm.rel = &#x27;stylesheet&#x27;; linkElm.type = &#x27;text/css&#x27;; linkElm.href = &#x27;js/frappe-gantt/dist/frappe-gantt.css&#x27;; headElm.appendChild(linkElm); const scriptElm = d.createElement(&#x27;script&#x27;); scriptElm.id = id; scriptElm.src = &#x27;js/frappe-gantt/dist/frappe-gantt.min.js&#x27;; headElm.appendChild(scriptElm);&#125;(document, &#x27;gantt-script&#x27;)); 參考 Blazor Call JavaScript functions from .NET methods in ASP.NET Core Blazor | Microsoft Docs IIFE JavaScript modules","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Blazor","slug":"Frontend/Blazor","permalink":"http://jiaming0708.github.io/categories/Frontend/Blazor/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiaming0708.github.io/tags/JavaScript/"},{"name":"Blazor","slug":"Blazor","permalink":"http://jiaming0708.github.io/tags/Blazor/"}]},{"title":"安裝 PowerShell7 及 Window Terminal 並套用 theme 美化","slug":"install-window-terminal-ps7-theme","date":"2021-05-19T13:09:59.000Z","updated":"2023-03-09T14:18:38.755Z","comments":true,"path":"2021/05/19/install-window-terminal-ps7-theme/","link":"","permalink":"http://jiaming0708.github.io/2021/05/19/install-window-terminal-ps7-theme/","excerpt":"最近再次投入了 window 平台的筆電，之前已經很習慣 mac 的 iTerm + oh-my-zsh 的功能，一直嘗試找有沒有類似的工具可以使用，很開心的找到了一個類似的工具，Window Terminal 搭配最新的 PowerShell 7 套用 oh-my-posh （是不是很相似阿，作者有說是參考 oh-my-zsh）","text":"最近再次投入了 window 平台的筆電，之前已經很習慣 mac 的 iTerm + oh-my-zsh 的功能，一直嘗試找有沒有類似的工具可以使用，很開心的找到了一個類似的工具，Window Terminal 搭配最新的 PowerShell 7 套用 oh-my-posh （是不是很相似阿，作者有說是參考 oh-my-zsh） 安裝 Window Terminal 以及 PowerShell 7PowerShell 7PowerShell 7 或者是說 PowerShell Core，比原本 Window 10 內建的 PowerShell 5.1 相比，更加強大且跨平台。這套在安裝後會獨立存在，也就是說不會蓋掉原本的 PowerShell 5.1，也就是說會有兩套同時存在於電腦中。 我是蠻懷疑，有多少 Linux 或是 Mac 的使用者會想要安裝這套XDDD 現在微軟都有提供多種安裝方式，可以到 github 看看，那個人是使用 Window Store 直接下載安裝，安裝完以後可以在開始的選單中搜尋 powershell 就可以發現到有兩種不一樣的版本（不是x86的差異），一個叫做 Window PowerShell 也就是原生5.1的版本，另一個 PowerShell 就是剛安裝好的7這個版本。 Window Terminal為什麼有了 PowerShell 這樣的工具，還需要另外一套類似的工具呢？PowerShell 是一個強大的工具，但一次就是一個視窗，分散開來其實有時候要管理的時候不是非常方便，如果同時又開了 cmd 以及 ubnutu wsl 的話，那不就一堆視窗在那邊跑，在這種情況下就蠻適合使用 Window Terminal 這套工具的。 好啦，最重要的原因是跟 mac 很像，所以選他就對了！ 一樣的微軟提供許多安裝方式，其中官方推薦的是 Window Store 。 套用 Theme安裝打開剛裝好的 Window Terminal 以及 PowerShell 7，接下來我們就要開始安裝 Theme 相關的套件，總共要安裝兩個套件，一個是 oh-my-pos 樣式的套件，另一個就是 posh-git 是用來顯示 git 的狀態，安裝的指令如下。 12Install-Module oh-my-posh -Scope CurrentUserInstall-Module posh-git -Scope CurrentUser 接著就是要讓 PowerShell 在啟動的時候就能夠套用，需要去修改設定檔，可以透過 $PROFILE 這個指令來確認設定檔的位置。如果沒有設定檔，則建立一個並且使用 記事本 來開啟。 12if (!(Test-Path -Path $PROFILE )) &#123; New-Item -Type File -Path $PROFILE -Force &#125;notepad $PROFILE 將以下的內容貼到記事本中，存檔以後，重開一個分頁即可看到套用 Paradox 這個樣式。 123Import-Module posh-gitImport-Module oh-my-poshSet-PoshPrompt -Theme Paradox 執行錯誤 若你重開分頁以後有套用成功，請跳過這個章節。 若你開啟後看到後面的錯誤，「檔案無法載入，因為這個系統已停用指令碼執行」，也不用太過多的擔心，在預設的情況下，PowerShell 是禁止執行自訂的檔案，可以透過 管理原權限 來打開 PowerShell 並且執行以下指令 1Set-ExecutionPolicy RemoteSigned 套用樣式oh-my-posh 提供蠻多的樣式可以做選擇，可以透過指令 Get-PoshThemes 或是 網站Themes | Oh my Posh 來做參考，下圖是執行指令出來的部份結果。 如果發現有些內容顯示不出來，通常是字體的問題，可以改為官方使用的字體 Nerd Fonts 如果預設的樣式還是不滿意的話，也可以自己客製化，做一些調整，讓自己開心工作上也會比較有動力！ 1Export-PoshTheme -FilePath C:\\.oh-my-posh.omp.json 重新開啟 $PROFILE 設定檔，並且將剛剛的第三行 Set-PoshPrompt 改成套用客製化的 json 檔案即可。 123Import-Module posh-gitImport-Module oh-my-poshSet-PoshPrompt -Theme C:\\.oh-my-posh.omp.json 最後分享一下我自己的設定檔，是參考了 paradox 以及 jandedobbeleer 所整理出來的樣式。 參考 使用 oh-my-posh 美化 PowerShell 樣式 (poychang.net) PowerShell 美化：oh my posh | Flymia 凡事用心之事 (ppundsh.github.io)","categories":[{"name":"Windows","slug":"Windows","permalink":"http://jiaming0708.github.io/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://jiaming0708.github.io/tags/Windows/"},{"name":"Powershell","slug":"Powershell","permalink":"http://jiaming0708.github.io/tags/Powershell/"},{"name":"WindowTerminal","slug":"WindowTerminal","permalink":"http://jiaming0708.github.io/tags/WindowTerminal/"}]},{"title":"[Angular]透過輸入的方法動態載入模組","slug":"angular-dynamic-module-by-input","date":"2021-04-20T06:30:50.000Z","updated":"2023-03-09T14:18:38.755Z","comments":true,"path":"2021/04/20/angular-dynamic-module-by-input/","link":"","permalink":"http://jiaming0708.github.io/2021/04/20/angular-dynamic-module-by-input/","excerpt":"在Angular中，除了先在Route定義好路徑並且載入模組以外，也能透過動態的方式去載入，能夠讓程式更加的靈活。今天想要試著用輸入的方法來做到動態載入模組，最後結果是失敗的，要來看看編譯後的結果，試著去理解原因。","text":"在Angular中，除了先在Route定義好路徑並且載入模組以外，也能透過動態的方式去載入，能夠讓程式更加的靈活。今天想要試著用輸入的方法來做到動態載入模組，最後結果是失敗的，要來看看編譯後的結果，試著去理解原因。 動態載入模組可以參考以下的文章 [Angular 大師之路] Angular 8 之後動態載入模組的方法 (非延遲載入路由) [Angular] 手動創造出 Lazy Loading 的效果 載入模組固定編譯前12345onClickLazyModule() &#123; import(&#x27;./lazy/lazy.module&#x27;).then(loadedModule =&gt; &#123; console.log(&#x27;123&#x27;, loadedModule); &#125;); &#125; 編譯後12345onModuleChange(path) &#123; __webpack_require__.e(/*! import() | lazy-lazy-module */ &quot;lazy-lazy-module&quot;).then(__webpack_require__.bind(null, /*! ./lazy/lazy.module */ &quot;g5p6&quot;)).then(loadedModule =&gt; &#123; console.log(&#x27;123&#x27;, loadedModule); &#125;);&#125; 載入模組不固定模組路徑透過輸入的方法載入 編譯前12345onClickLazyModule(pathModule) &#123; import(pathModule).then(loadedModule =&gt; &#123; console.log(&#x27;123&#x27;, loadedModule); &#125;); &#125; 編譯後1234567891011121314151617181920212223242526/***/ &quot;+Huz&quot;:/*!***************************************!*\\ !*** ./src/app lazy namespace object ***! \\***************************************//*! no static exports found *//***/ (function(module, exports) &#123;function webpackEmptyAsyncContext(req) &#123; // Here Promise.resolve().then() is used instead of new Promise() to prevent // uncaught exception popping up in devtools return Promise.resolve().then(function() &#123; var e = new Error(&quot;Cannot find module &#x27;&quot; + req + &quot;&#x27;&quot;); e.code = &#x27;MODULE_NOT_FOUND&#x27;; throw e; &#125;);&#125;webpackEmptyAsyncContext.keys = function() &#123; return []; &#125;;webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;module.exports = webpackEmptyAsyncContext;webpackEmptyAsyncContext.id = &quot;+Huz&quot;; onModuleChange(path) &#123; __webpack_require__(&quot;+Huz&quot;)(path).then(loadedModule =&gt; &#123; console.log(&#x27;123&#x27;, loadedModule); &#125;);&#125; 編譯警告123456789101112Warning: ./src/app/app.component.ts 14:8-20Critical dependency: the request of a dependency is an expression at ImportContextDependency.getWarnings (/Work/test/node_modules/webpack/lib/dependencies/ContextDependency.js:40:18) at Compilation.reportDependencyErrorsAndWarnings (/Work/test/node_modules/webpack/lib/Compilation.js:1454:24) at /Work/test/node_modules/webpack/lib/Compilation.js:1258:10 at _next0 (eval at create (/Work/test/node_modules/tapable/lib/HookCodeFactory.js:33:10), &lt;anonymous&gt;:30:1) at eval (eval at create (/Work/test/node_modules/tapable/lib/HookCodeFactory.js:33:10), &lt;anonymous&gt;:43:1) at runMicrotasks (&lt;anonymous&gt;) at processTicksAndRejections (internal/process/task_queues.js:97:5) @ ./src/app/app.module.ts @ ./src/main.ts @ multi ./src/main.ts 結論從上面的結果來看，可以看到當使用 import 沒有給路徑的話，在編譯的時候就會直接給警告，並且輸出的結果永遠都是 Cannot find module。 要這麼動態的載入，在angular的編譯機制中，就會出現這樣的結果，也許要workaround才能做到，那這邊我就沒有深入去研究了，如果你有其他作法，歡迎留言給我。","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"[IIS] Gitea 搭配 reverse proxy 的問題排解","slug":"gitea-iis-reverse-proxy-trouble-shooting","date":"2021-04-19T13:20:54.000Z","updated":"2023-03-09T14:18:38.755Z","comments":true,"path":"2021/04/19/gitea-iis-reverse-proxy-trouble-shooting/","link":"","permalink":"http://jiaming0708.github.io/2021/04/19/gitea-iis-reverse-proxy-trouble-shooting/","excerpt":"繼前一篇 [IIS] 修正 reverse proxy 的 host 問題 後，又持續的跟 IIS 奮鬥了一陣子，才讓 Gitea 搭配 reverse proxy 的運作是正確的！","text":"繼前一篇 [IIS] 修正 reverse proxy 的 host 問題 後，又持續的跟 IIS 奮鬥了一陣子，才讓 Gitea 搭配 reverse proxy 的運作是正確的！ 無法建立PR問題描述一進去 repo 的畫面，直接點選 建立合併請求 會提示 404 的錯誤，這時候的 URL 如下 git.com&#x2F;jimmy&#x2F;test&#x2F;compare&#x2F;master…master 但這時候如果切換到其他 branch 再來建立 PR 的話，就可以正常顯示。 解法IIS 會針對一些附檔名做一些處理，這邊要將 IIS 設定成忽略所有的副檔名，全部交給 Gitea server 做處理。在 web.config 的設定中加上以下的設定 12345678910&lt;configuration&gt; &lt;system.webServer&gt; &lt;security&gt; &lt;!-- 將所有的副檔名都排除 --&gt; &lt;fileExtensions allowUnlisted=&quot;true&quot;&gt; &lt;clear /&gt; &lt;/fileExtensions&gt; &lt;/security&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; Push 認證失敗問題描述可以使用 domain 做 clone&#x2F;fetch&#x2F;pull 等行為，但 push 的時候會一直跳錯誤 401 未授權 。但只要不使用 domain 馬上可以正常的使用，IIS 就是你的鍋阿！！ 解法 記得設定要將 HTTP_X_ORIGINAL_ACCEPT_ENCODING 及 HTTP_ACCEPT_ENCODING 加到伺服器變數中。 12345678910111213141516171819202122&lt;rules&gt; &lt;rule name=&quot;ReverseProxyInboundRule1&quot; stopProcessing=&quot;true&quot;&gt; &lt;match url=&quot;(.*)&quot; /&gt; &lt;conditions logicalGrouping=&quot;MatchAll&quot; trackAllCaptures=&quot;false&quot; /&gt; &lt;serverVariables&gt; &lt;set name=&quot;HTTP_X_ORIGINAL_ACCEPT_ENCODING&quot; value=&quot;HTTP_ACCEPT_ENCODING&quot; /&gt; &lt;set name=&quot;HTTP_ACCEPT_ENCODING&quot; value=&quot;&quot; /&gt; &lt;/serverVariables&gt; &lt;action type=&quot;Rewrite&quot; url=&quot;http://localhost:3000&#123;UNENCODED_URL&#125;&quot; /&gt; &lt;/rule&gt;&lt;/rules&gt;&lt;outboundRules&gt; &lt;rule name=&quot;RestoreAcceptEncoding&quot; preCondition=&quot;NeedsRestoringAcceptEncoding&quot;&gt; &lt;match serverVariable=&quot;HTTP_ACCEPT_ENCODING&quot; pattern=&quot;^(.*)&quot; /&gt; &lt;action type=&quot;Rewrite&quot; value=&quot;&#123;HTTP_X_ORIGINAL_ACCEPT_ENCODING&#125;&quot; /&gt; &lt;/rule&gt; &lt;preConditions&gt; &lt;preCondition name=&quot;NeedsRestoringAcceptEncoding&quot;&gt; &lt;add input=&quot;&#123;HTTP_X_ORIGINAL_ACCEPT_ENCODING&#125;&quot; pattern=&quot;.+&quot; /&gt; &lt;/preCondition&gt; &lt;/preConditions&gt;&lt;/outboundRules&gt; 結論IIS 的 reverse proxy 設定相對於 nginx 複雜，不過他們的功能定義上本身就不一樣，所以也不能單純的這樣比。要使用的話就有許多地方要先設定好來，不然會比較多的小問題。 另外我有找到一些網路上推薦的設定，但可能我沒有注意到那些問題，這邊附上完整的 web.config。 參考 [IIS][GitLab] 利用 IIS Reverse Proxy 將 GitLab 加上 Https [IIS][GitLab] Reverse Proxy 後的小問題 Gitea document - reverse proxies","categories":[{"name":"IIS","slug":"IIS","permalink":"http://jiaming0708.github.io/categories/IIS/"}],"tags":[{"name":"IIS","slug":"IIS","permalink":"http://jiaming0708.github.io/tags/IIS/"}]},{"title":"[IIS] 修正 reverse proxy 的 host 問題","slug":"iis-reverse-proxy-header","date":"2021-04-09T03:36:52.000Z","updated":"2023-03-09T14:18:38.747Z","comments":true,"path":"2021/04/09/iis-reverse-proxy-header/","link":"","permalink":"http://jiaming0708.github.io/2021/04/09/iis-reverse-proxy-header/","excerpt":"使用 IIS 做 reverse proxy 時，如果網站需要 OAuth，會自動導去其他網站，但會發現這時候 host 沒有被切過去，導致整個 auth 失敗，來分享一下可以怎麼樣解決這個問題。","text":"使用 IIS 做 reverse proxy 時，如果網站需要 OAuth，會自動導去其他網站，但會發現這時候 host 沒有被切過去，導致整個 auth 失敗，來分享一下可以怎麼樣解決這個問題。 問題描述先把問題描述的清楚一點，如果你的情況剛好跟我一樣，就可以參考參考。 在 window 的 server 上，架了兩個服務，要透過 IIS 設定 domain 對應到這兩個服務，使用 URL rewrite 這個模組中的反向代理 (reverse proxy) 設定。 這邊就不介紹怎麼設定 reverse proxy，最下面會放相關連結可以參考。 git.com -&gt; 3000 ci.com -&gt; 8000 當進入 ci 這個 domain 會先轉到 git 這邊做 OAuth 的認證，預期的流程如下 在瀏覽器輸入 ci.com 轉導至 git.com&#x2F;login?redirect&#x3D;ci.company.com 帳號登入，導回 ci.com 那問題出現在第二步，host 沒有轉過去，還保留在 ci 這個 domain ，除了 host 以外，其他路徑及參數都是正確。 錯誤的 URL, ci.com&#x2F;login?redirect&#x3D;ci.com 解決方法將 ARR 中的 Reverse rewrite host in response headers 關閉即可。 在 IIS 的 root 找到 Application Request Routing(ARR) 在 ARR 的右側點選 Server Proxy Setting 找到 Reverse rewrite host in response headers 並且取消核選 參考 設定Reverse Proxy在Windows、Mac 如何利用 IIS7 的 ARR 模組實做 Reverse Proxy 機制 URL Rewrite keeps original host Location when reverse proxy 301 redirects The OAuth Login and Approve has the wrong URL when using IIS as a proxy","categories":[{"name":"IIS","slug":"IIS","permalink":"http://jiaming0708.github.io/categories/IIS/"}],"tags":[{"name":"IIS","slug":"IIS","permalink":"http://jiaming0708.github.io/tags/IIS/"}]},{"title":"在本機使用Docker架Gitea和DroneCI","slug":"gitea-drone-docker","date":"2021-03-22T02:04:38.000Z","updated":"2023-03-09T14:18:38.739Z","comments":true,"path":"2021/03/22/gitea-drone-docker/","link":"","permalink":"http://jiaming0708.github.io/2021/03/22/gitea-drone-docker/","excerpt":"當要選擇自架的 git 伺服器，Gitea 是蠻多公司的選擇，在這個講求效率的開發時代，必須要搭配一個 CI&#x2F;CD 的平台，讓我們可以更好更快的部屬，我選擇 Drone CI 作為平台，今天要來分享一下使用 docker-compose 建置在本機的步驟。","text":"當要選擇自架的 git 伺服器，Gitea 是蠻多公司的選擇，在這個講求效率的開發時代，必須要搭配一個 CI&#x2F;CD 的平台，讓我們可以更好更快的部屬，我選擇 Drone CI 作為平台，今天要來分享一下使用 docker-compose 建置在本機的步驟。 Gitea跟著官方的文件試著把 Gitea 的服務建立起來，在這邊就只弄最簡單的SQLite，首先要建立一個 docker-compose.yml 的檔案，並且將內容貼上。 123456789101112131415161718192021version: &quot;3&quot;networks: gitea: external: falseservices: gitea-server: image: gitea/gitea:1.13.3 container_name: gitea environment: - USER_UID=1000 - USER_GID=1000 restart: always networks: - gitea volumes: - ./gitea:/data ports: - &quot;3000:3000&quot; - &quot;222:22&quot; 試著跑看看 docker-compose up -d ，成功的話就可以看到 done 的字樣。 123&gt; docker-compose up -dCreating network &quot;test_gitea&quot; with the default driverCreating gitea ... done 再用瀏覽器打開 localhost:3000 看到以下畫面就沒問題了！ DroneDrone 可以跟很多平台做整合，這邊當然就是選擇前面已經架好的 Gitea 作為我們的目標 參考文件。Drone 總共要起兩個服務，一個是主服務，另一個是 runner 專門執行 task 的。 Gitea OAuth根據文件，第一步要在 Gitea 的設定中找到 Applications 這個頁籤，建立一個新的應用。名稱我們給他 drone，URI 的話預期是 http://locahost:8000。 這邊要特別注意的是 Redirect URI 最後必須要帶上 &#x2F;login，不然會無法成功 按下建立以後就可以看到以下的畫面，這個畫面先留著不要馬上關掉，或者是把 Client ID 以及 Client Secret 存起來，等一下設定會用到。 產生共用密碼接著我們要產生一個共用密碼，給主服務和 runner 之間做認證使用。 12&gt; openssl rand -hex 1681e04d83a6054b464f5c5b13365578fd 設定docker-compose為了讓 container 之間能夠互相的溝通，加上前面的 gitea 已經使用 compose，這邊就繼續往下編輯，讓我們使用一個檔案來起多個服務。 將資料填入對應的欄位，並且儲存 docker-compose.yml 。 12345678910111213141516171819202122gitea-server: # ...drone-server: image: drone/drone:1 container_name: drone-server ports: - 8000:80 volumes: - ./drone:/data restart: always networks: - gitea depends_on: - gitea-server environment: - DRONE_SERVER_HOST=localhost:8000 # drone server - DRONE_SERVER_PROTO=http - DRONE_RPC_SECRET=81e04d83a6054b464f5c5b13365578fd #共用密碼 # Gitea - DRONE_GITEA_CLIENT_ID=cf9e05e8-53b0-447b-a8d7-86d7c882c64a # client id - DRONE_GITEA_CLIENT_SECRET=6nZ8EEJtk6lqI00Fdbf4A3F7_2-rSzxbQbikw-EnsvU= #client secret - DRONE_GITEA_SERVER=http://localhost:3000 # gitea server 執行跟剛剛一樣的指令 docker-compose up -d ，不需要先把 gitea 停掉，就可以啟動 drone。 123&gt; docker-compose up -dgitea is up-to-dateCreating drone-server ... done 好了！來用瀏覽器開啟 localhost:8000 這個服務，看到這個畫面表示成功啦！！ 錯誤auth 的按鈕按下去以後，會看到一個錯誤訊息。 Login Failed. Post “http://localhost:3000/login/oauth/access_token&quot;: dial tcp 127.0.0.1:3000: connect: connection refused 經過 google 大神說明，原來是 container 的網路都是獨立，所以不接受 127.0.0.1，要使用 192.168.0.x 或者是 domain 的方式。 ngrokngrok 是一個可以將本機的服務直接轉成對外的服務，很適合還在開發階段，但又要給其他人確認畫面之類的時候。因為剛剛的 drone 不能使用 localhost 作設定，因此我們可以先使用這個服務來做測試，確認整個設定都是正確。 設定這邊我們要把預計使用到的 3000 以及 8000 兩個 port 都做監聽，ngrok 的指令一次只能起一個 port ，因此我們要透過 ngrok.yml 做設定一次起多個。 12345678authtoken: &#123;&#123;your token&#125;&#125;tunnels: gitea: addr: 3000 proto: http drone: addr: 8000 proto: http 執行 ./ngrok start --all --config ngrok.yml，應該可以看到底下的畫面。 修改 docker-compose.yml將 ngrok 所產生的 domain 貼回去 docker-compose.yml 中，這邊只有兩個地方要調整 DRONE_SERVER_HOST DRONE_GITEA_SERVER 1234567891011121314151617181920drone-server: image: drone/drone:1 container_name: drone-server ports: - 8000:80 volumes: - ./drone:/data restart: always networks: - gitea depends_on: - gitea-server environment: - DRONE_SERVER_HOST=b42812f5966a.ngrok.io #改用nrok的domain - DRONE_SERVER_PROTO=http - DRONE_RPC_SECRET=81e04d83a6054b464f5c5b13365578fd # Gitea - DRONE_GITEA_CLIENT_ID=cf9e05e8-53b0-447b-a8d7-86d7c882c64a - DRONE_GITEA_CLIENT_SECRET=6nZ8EEJtk6lqI00Fdbf4A3F7_2-rSzxbQbikw-EnsvU= - DRONE_GITEA_SERVER=http://4fe6164979a9.ngrok.io #改用nrok的domain 修改 Application 的 redirect URI重新啟動服務以後，一樣可以使用 localhost:3000 進去 gitea 的服務頁面，將前面設定好的 Redirect URI 修改為 ngrok 的 domain。 都修改好後，就可以重新進入 8000 的那個 domain，應該就可以成功進入到 drone 的首頁。 測試drone runner前面有講到 drone 是分兩個服務，一個 server 另一個是 runner，但剛剛其實都沒有起這個服務，在測試之前，先將這個服務起起來！ 1234567891011121314drone-agent: image: drone/drone-runner-docker:1 container_name: drone-runner restart: always depends_on: - drone-server volumes: - /var/run/docker.sock:/var/run/docker.sock environment: - DRONE_RPC_HOST=b42812f5966a.ngrok.io - DRONE_RPC_PROTO=http - DRONE_RPC_SECRET=81e04d83a6054b464f5c5b13365578fd - DRONE_RUNNER_CAPACITY=2 - DRONE_RUNNER_NAME=$&#123;HOSTNAME&#125; push 一個 commit做測試萬事具備！先建立一個 repo 並且 push 檔案 .drone.yml 作為確認。 12345678910kind: pipelinetype: dockername: default steps:- name: test image: alpine commands: - echo hello - echo world 可以看到一個 task 就跑起來了！但是，凡事都有個 but！在 clone 的時候竟然失敗了！！！ 重新設定gitea還記得一開始啟動 gitea 的時候，我們什麼都沒有改，直接就建立了，但後來我們使用了 ngrok 作為 domain，在 gitea 建立後這個 URI 就已經被固定，因此我們要在 docker-compose.yml 中加上 ROOT_URL ，並且將 gitea 的資料夾砍掉，重新啟動！ 這邊可以使用 docker-compose down 的指令先將服務都停止 123456789101112131415gitea-server: image: gitea/gitea:1.13.3 container_name: gitea environment: - USER_UID=1000 - USER_GID=1000 - ROOT_URL=http://4fe6164979a9.ngrok.io restart: always networks: - gitea volumes: - ./gitea:/data ports: - &quot;3000:3000&quot; - &quot;222:22&quot; 在 install 的設定中找到 Gitea Base URL 這個欄位，並且確認 domain 是預期的 ngrok。 接著按照前面的步驟，重新建立 application 等的動作，就可以看到 drone 成功的跑完啦！！ 結論這些服務在一開始設計的時候，就不是預期在本機，如果是在有 domain 的 server 上，這些問題都不會發生。 很妙的是 drone 用 0.8 就可以使用 localhost，應該是後面他們有做過調整導致。","categories":[{"name":"CI/CD","slug":"CI-CD","permalink":"http://jiaming0708.github.io/categories/CI-CD/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://jiaming0708.github.io/tags/Docker/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://jiaming0708.github.io/tags/CI-CD/"},{"name":"Gitea","slug":"Gitea","permalink":"http://jiaming0708.github.io/tags/Gitea/"},{"name":"Drone","slug":"Drone","permalink":"http://jiaming0708.github.io/tags/Drone/"}]},{"title":"[nginx] 設定reverse proxy當location使用regex","slug":"nginx-location-regex-reverse-proxy","date":"2021-03-13T01:03:58.000Z","updated":"2023-03-09T14:18:38.739Z","comments":true,"path":"2021/03/13/nginx-location-regex-reverse-proxy/","link":"","permalink":"http://jiaming0708.github.io/2021/03/13/nginx-location-regex-reverse-proxy/","excerpt":"一個網站有部分頁面是需要連到其他網站的，但又希望網址改變，這時候我們可以使用 reverse proxy 的技術來達成，今天要來分享的是如何在 nginx 中完成這樣的需求。 reverse proxy 可以參考我之前 寫的這篇","text":"一個網站有部分頁面是需要連到其他網站的，但又希望網址改變，這時候我們可以使用 reverse proxy 的技術來達成，今天要來分享的是如何在 nginx 中完成這樣的需求。 reverse proxy 可以參考我之前 寫的這篇 proxy_pass先來個基本題，使用者進到 course 這個路徑時，希望能夠開啟維持一樣的 url 但是內容呈現在 webflow 上做好的一頁，我們所要使用的指令叫做 proxy_pass。 12345server &#123; location ~ /course &#123; proxy_pass https://mkt-hk.webflow.io/hkdse-courses; &#125;&#125; proxy_pass 與 regex進階題來了，想要限制只有特定前綴 zh-hk 以及 en-hk 的 course 路徑才顯示 academy 的內容。 先來列一下預期的 URL &#x2F;zh-hk&#x2F;course &#x2F;en-hk&#x2F;course 12345server &#123; location ~ /*-hk/course &#123; proxy_pass https://mkt-hk.webflow.io/hkdse-courses; &#125;&#125; 很開心的做完了，重起 nginx 卻發現到錯誤 “proxy_pass” cannot have URI part in location given by regular expression, or inside named location, or inside “if” statement, or inside “limit_except” 當 location 是動態 (regex) 路徑時，就只能指定 domain 那層，後面的 folder 不能存在。雖然只有兩個前綴，可以簡單的重複寫兩次，但總是覺得這樣很笨。 查了相關的設定以後，需要透過 rewrite 的方式，先讓這個頁面先轉到目標 folder，但又不能真的執行 (break)，再來執行 proxy_pass 就可以達成目的。 123456server &#123; location ~ /*-tw/course &#123; rewrite ^ /hkdse-courses break; proxy_pass https://mkt-hk.webflow.io; &#125;&#125; 參考 stackoverflow nginx","categories":[{"name":"nginx","slug":"nginx","permalink":"http://jiaming0708.github.io/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://jiaming0708.github.io/tags/nginx/"}]},{"title":"[AWS] Elastic Load Balancer變更TLS的設定","slug":"aws-elb-tls-setting","date":"2021-02-20T06:33:28.000Z","updated":"2023-03-09T14:18:38.739Z","comments":true,"path":"2021/02/20/aws-elb-tls-setting/","link":"","permalink":"http://jiaming0708.github.io/2021/02/20/aws-elb-tls-setting/","excerpt":"網站的安全性中，其中有一項是關於 TLS 的檢查，建議是v1.2版以上。那服務如果是架設在 AWS 的 ELB 上，應該要怎麼做調整呢？","text":"網站的安全性中，其中有一項是關於 TLS 的檢查，建議是v1.2版以上。那服務如果是架設在 AWS 的 ELB 上，應該要怎麼做調整呢？ TLS簡介在瀏覽網站的時候，現在大部分的網站都會是 https ，與 http 的差異也就是加密，這個加密的方法是透過所謂的 SSL &#x2F; TLS 來做進行。那為什麼要進行加密呢，因為 http 是明碼的傳輸，也就是說只要你想看，就能看到有哪些資料被傳送並且有機會進行修改。 SSL 的全名是 Secure Sockets Layer，用來確保瀏覽器與伺服器之間的資料傳輸，減少被修改的可能性，但因為存在著一些問題無法解決，因此在2016年的時候被 TLS 取代。 TLS 的全名是 Transport Layer Security，比 SSL 更強大的加密，並且解決掉了部分的問題。 現在外面所發的憑證基本上都是 TLS，但因為大家都習慣了，因此還是繼續稱呼為 SSL 憑證。 調整ELB設定ELB 是 AWS 中的一個服務，全名是 Elastic Load Balancer 或稱為 Network Load Balancer，TLS 則是透過 Security policy 來做設定。 從上面介紹可以得知，會需要設定 TLS 的只有 443 也就是 https 那組 Listener ，我們可以看到預設的 Security policy 是 ELBSecurityPolicy-2016-08 。 接著把 443 打勾並且點擊上方的 edit 按鈕，可以進入到編輯的頁面。 請找到 Security policy 這個欄位，並且參考這張表，重新調整為你所需要的即可。 因為我的目的只有要先關閉，TLS v1.0 以及 V1.1，因此最終選擇的是 ELBSecurityPolicy-TLS-1-2-Ext-2018-06，當然可以的話就選擇最安全的設定 ELBSecurityPolicy-FS-1-2-Res-2020-10。 如果選擇的越安全，有可能瀏覽器支援度越低，還是要根據使用者的瀏覽器使用狀況來做決定。 參考 What is Transport Layer Security (TLS)? 簡介 SSL、TLS 協定 何謂SSL、TLS 以及HTTPS？為什麼網站都須要安裝SSL？ TLS listeners for your Network Load Balancer","categories":[{"name":"AWS","slug":"AWS","permalink":"http://jiaming0708.github.io/categories/AWS/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"http://jiaming0708.github.io/tags/AWS/"}]},{"title":"設定nginx的log備份機制","slug":"logrotate-nginx","date":"2021-01-26T02:25:27.000Z","updated":"2023-03-09T14:18:38.739Z","comments":true,"path":"2021/01/26/logrotate-nginx/","link":"","permalink":"http://jiaming0708.github.io/2021/01/26/logrotate-nginx/","excerpt":"前幾天公司部屬新的版本到 prod server 的時候失敗了，檢查以後才發現是空間不足，問題是出現在 nginx log 目錄太肥，到底是發生什麼事情，今天來探討一下。","text":"前幾天公司部屬新的版本到 prod server 的時候失敗了，檢查以後才發現是空間不足，問題是出現在 nginx log 目錄太肥，到底是發生什麼事情，今天來探討一下。 環境與前言目前我們還有些服務還是直接架設在 ec2 上，所以我們會在上面安裝 nginx 來指向我們的服務，因為這台 server 已經運行蠻久的時間，上面的版本也比較舊，為了安全性問題，前陣子將 nginx 升級到 1.18（強烈建議安裝到此版本，之前的版本都有安全性的問題），但升級以後沒有注意到 logrotate 的設定跟之前不同。 ubuntu v16 nginx v1.18 logrotatelogrotate 是一個 linux 上的定時服務，會根據設定來做壓縮以及產生新的檔案。 舉例來說，log是以天為單位作為切分，那 logfile.1 就會變成 logfile.2 並且產生新的 logfile.1 目前設定執行以下指令查看 logrotate 目前設定。 cat &#x2F;etc&#x2F;logrotate.d&#x2F;nginx 123456789101112131415/var/log/nginx/*.log &#123; daily missingok rotate 52 compress delaycompress notifempty create 640 nginx adm sharedscripts postrotate if [ -f /var/run/nginx.pid ]; then kill -USR1 `cat /var/run/nginx.pid` fi endscript&#125; 參數介紹 daily，以天為單位做檔案切割，另外還有其他三種 weekly monthly yearly missingok，沒檔案的時候略過且不會發生錯誤 rotate 52，保留的檔案個數，這邊指的是52個檔案 compress，切割出來的檔案，將會壓縮成 gzip delaycompress，延遲壓縮，避免檔案還被咬著導致失敗 notifempty，檔案內容是空的時候不做動作 create 640 nginx adm，產生檔案時要給的使用者及權限 sharedscripts，一般來說 postrotate &#x2F; prerotate 會在每個檔案 rotate 後執行，加上這個指令的話就等於只會執行一次 postrotate，在 endscript 的區間內是 rotate 結束後會執行的指令 調整設定根據上面的一些介紹，可以得知會保留52天的檔案，並且一個檔案沒有上限，那為了讓開檔更順利且不會佔用太多的空間，限縮檔案是 10M 並且只保留 7個。 12345678910111213141516171819--- /etc/logrotate.d/nginx+++ /etc/logrotate.d/nginx/var/log/nginx/*.log &#123;+ size=10M daily missingok- rotate 52+ rotate 7 compress delaycompress notifempty create 640 nginx adm sharedscripts postrotate if [ -f /var/run/nginx.pid ]; then kill -USR1 `cat /var/run/nginx.pid` fi endscript&#125; 測試執行基本上 logrotate 是每天定時跑起來，改完以後是可以不用特別重新執行，但通常改完我們會希望確定是不是如我們預期，那我們可以下個指令要求立刻執行。 sudo logrotate -v &#x2F;etc&#x2F;logrotate.d&#x2F;nginx Reference StatckExchange - How to make log-rotate change take effect Linux man page - logrotate","categories":[{"name":"linux","slug":"linux","permalink":"http://jiaming0708.github.io/categories/linux/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://jiaming0708.github.io/tags/nginx/"}]},{"title":"在GitKraken中使用template","slug":"git-template-in-kraken","date":"2020-10-25T07:33:08.000Z","updated":"2023-03-09T14:18:38.735Z","comments":true,"path":"2020/10/25/git-template-in-kraken/","link":"","permalink":"http://jiaming0708.github.io/2020/10/25/git-template-in-kraken/","excerpt":"最近團隊開始規範 git commit 並且導入 Conventional commit，剛開始不熟悉都會一直要去翻文件，看看到底這時候要用什麼樣的類型，為了加速類別的輸入，可以在 commit 的 template 中設定，今天就來分享一下使用這個規範並且如何有效的套用在 GitKraken 這套工具中。","text":"最近團隊開始規範 git commit 並且導入 Conventional commit，剛開始不熟悉都會一直要去翻文件，看看到底這時候要用什麼樣的類型，為了加速類別的輸入，可以在 commit 的 template 中設定，今天就來分享一下使用這個規範並且如何有效的套用在 GitKraken 這套工具中。 介紹Conventional commit這是一個由 angular 團隊推動的 commit message 規範，主要是把每個 commit 做一個分類，分類的好處除了人在看比較輕鬆以外，也是有機會能夠使用工具去拿到某個分類的全部 commit，在 release 時要整理就會比較輕鬆。 目前的類別大概有 feat, fix, build:, chore, ci, docs, style, refactor, perf, test…等，基本上大部分的 commit 應該都能夠被分類到；目前我最常用到的應該是 feat, style, refactor, fix 這幾個，剩下幾個就沒那麼常使用到。 要導入一個規範最好的方法還是用強迫的，那就必須要安裝 commit lint 的套件 config-conventional。 1npm install --save-dev @commitlint/config-conventional @commitlint/cli 使用Git Template剛剛有說到可以使用套件來作為規範，但初期的時候就是很容易忘記有哪些類別，這時候可以考慮使用 git 的 template 功能，讓我們在 commit 時，能有一個快速的參考，當然這個 template 並不會真的進入到你的 message 中。 接著就來試試看在 git 中加上 template，首先建立一個檔案叫做 .gitmessage ，並且放在 root 底下。 123cd ~touch .gitmessagevi .gitmessage 接著將 conventional commit 的類別放進去，輸入 i 然後 cmd+v 貼上，這個是我目前使用的內容。 123456789101112# Conventional Commit Types:# build# ci# chore# docs# feat# fix# perf# refactor# revert# style# test 最後把這個檔案指定給 git。 1git config commit.template .gitmessage 設定 GitKaren 如果你是 CLI 派的，就麻煩這邊左轉離開囉。 使用過的 GUI 工具還蠻多種的，目前就剩下一套 GitKaren 固定在使用，關於這套的介紹建議大家可以去參考 Mike 的文章，畢竟介紹這套工具不是我們今天的重點，今天的重點在於使用了 commit template 以後，怎麼樣更方便的在 GitKaren 中應用。 做完上面的步驟以後，就可以看到在 message 的欄位已經自動帶入所建立的 template。 這時候可以先來試一下 commit 一個檔案，看看結果是什麼。 唉～等等！為什麼我們的 template 也跟著進去，這跟我們預期的不同，如果你有 SourceTree 這套 GUI 的話也能夠試試看，結果應該會有點不同。 讓我們試著找找看設定沒有沒地方可以修改，開啟 preference 可以看到下方有一個屬於個別專案的設定，點進去以後將 remove comment from commit messages 打勾即可。 這個地方比較麻煩，還沒找到好的設定可以套用全部，如果你有找到方法，歡迎留言告訴我 參考 Conventional commit GitKraken offical site GitKraken commit template","categories":[{"name":"Git","slug":"Git","permalink":"http://jiaming0708.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://jiaming0708.github.io/tags/Git/"},{"name":"GitKraken","slug":"GitKraken","permalink":"http://jiaming0708.github.io/tags/GitKraken/"}]},{"title":"create-react-app 開發心得分享","slug":"create-react-app","date":"2020-09-07T13:11:31.000Z","updated":"2023-03-09T14:18:38.735Z","comments":true,"path":"2020/09/07/create-react-app/","link":"","permalink":"http://jiaming0708.github.io/2020/09/07/create-react-app/","excerpt":"最近公司的一個新專案，因為網站的功能都必須要登入以後才能操作，因此選擇了 create-react-app (CRA) 這個來做為 project base，前陣子剛上線第一個版本，順便來整理一些心得。","text":"最近公司的一個新專案，因為網站的功能都必須要登入以後才能操作，因此選擇了 create-react-app (CRA) 這個來做為 project base，前陣子剛上線第一個版本，順便來整理一些心得。 why CRA在開始之前先和 PM 確認這個網站的功能要有哪些，是否會有所謂的內容或是行銷頁面，那經過 PM 確認後，網站主要是登入後的內容。既然要登入，有沒有所謂的 server-side-render (SSR) 根本不重要，因為對於網站來說也沒辦法那些內容呈現給爬蟲，因此這個時候我們就只需要 client-side-render (CSR) 的功能。 既然只是 CSR 的網站，react 的團隊也提供已經建置好的一個架構也就是 CRA，讓你不用再煩惱 webpack 等等的設定。 專案建置CRA 本身提供的功能真的很陽春，react 團隊只是提供了一個平台，讓你不用在乎專案的一些架構設定等等，但如果要達到稍微複雜的開發需求，還是有不少東西需要被調整，接著我會說明怎麼去建置所需要的環境。 建立有redux的專案根據官網的介紹，我們可以使用下面的指令很輕鬆的建立好專案，完成後使用 vscode 打開，可以發現到只有 public 以及 src 兩個目錄而已，而且是只有 react 的功能， redux 等等的功能都沒有。 123npx create-react-app my-projectcd my-projectcode . 作為一個完整的專案，基本上就是會有 redux 以及 middleware （也許有人會說用 context 就好，但就不再這邊討論囉！），那有沒有更簡單的方法呢？當然是有的， 在 npm 中搜尋 cra-template 就可以使用這些別人已經建立好的範本來做初始專案。 目前團隊是使用 redux+saga ，因此我這邊就選擇一個已經整合好的範本。 123npx create-react-app my-project --template react-redux-sagacd my-projectcode . CSS管理在 CRA 中有兩種的 css 管理方法，一種是全域的檔案，另一種就是 css module ，基本上兩種模式都有用到，但主要用比較多的會是 css module ，因此再建立 component 時，就必須要將 css 的檔案名稱加上 ***.module.css** 這樣才會變成 module scope，不然的話預設就會是全域。 另外就是使用預處理器 scss 來撰寫，webpack的處理已經準備好，只是需要安裝 node-sass 的 library 即可！ 1yarn add node-sass Route建立一個稍微有點規模的專案，都一定不會只有一個頁面，因此我們一定會需要使用到 route ，那想當爾就是我們要自己安裝囉！ 1yarn add react-router-dom Format 及 ESLint &#x2F; StyleLint排版是一件麻煩的事情，尤其是大家的習慣不同，使用 formatter 以及 linter 是最簡單的，我們團隊是使用 prettier 為基礎，另外套一些 react &#x2F; scss 的 lint，基本上不太會去改什麼設定，參考這邊使用方法。 如果有另外定義 .eslintrc 記得要再 env 檔案中加上 EXTEND_ESLINT=TRUE，才不會一直套用到 CRA 預設的 eslint 使用 ESLint 時要注意一下，如果開啟 error 會導致編譯失敗，一定要修復才會正常編譯（但我還是開了！） 環境變數CRA 已經定義好每個 script 所對應的 env 檔案是什麼，先參考一下這邊。公司的開發環境一共有三個，分別是本機、測試、正式，但根據文件所介紹的， build 只能對應 .env.production ，那測試環境的 .env.uat 檔案該怎麼讓 build 的指令可以被使用到？還好他們也有考慮到這問題，可以參考這邊，透過 env-cmd 的 library來替換檔案。 結論其實可以發現 CRA 真的很基本，著重在於編譯相關的事情，但也有考慮到一個專案應該會要有的東西，只是需要使用者自己去針對所需做設定，也算是蠻符合 react 本身的精神。 原本還想寫寫客製 react-scripts ，但沒有想出比較好的介紹方式，這邊就先不提了，有興趣的可以從 eject 的相關介紹著手。 Reference CRA 官網","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"React","slug":"Frontend/React","permalink":"http://jiaming0708.github.io/categories/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://jiaming0708.github.io/tags/React/"}]},{"title":"專案設定 - vscode 以及 nvmrc","slug":"project-setting","date":"2020-07-19T15:26:00.000Z","updated":"2023-03-09T14:18:38.735Z","comments":true,"path":"2020/07/19/project-setting/","link":"","permalink":"http://jiaming0708.github.io/2020/07/19/project-setting/","excerpt":"open source總是有些不一樣的東西可以挖，今天為了要找一些使用action的範例，反而讓我找到了一些不一樣的設定，可以幫助我們。","text":"open source總是有些不一樣的東西可以挖，今天為了要找一些使用action的範例，反而讓我找到了一些不一樣的設定，可以幫助我們。 .vscode當改變了一些設定是只有為了專案的時候，vscode 就會產生一個 settings.json 的檔案在根目錄底下，除了設定以外，vscode 也支援 推薦 extensions 給專案的使用者，只要在 .vscode 的目錄下建立 extensions.json 即可，範例如下： 12345678&#123; &quot;recommendations&quot;: [ // format: &#123;publisher&#125;.&#123;extension&#125; &quot;ms-vscode.vscode-typescript-tslint-plugin&quot;, &quot;dbaeumer.vscode-eslint&quot;, &quot;msjsdiag.debugger-for-chrome&quot; ]&#125; 若是有一些推薦的設定，但不希望強制的話，就可以在 .vscode 的目錄下，建立一些 recommended-* 的檔案，由使用者自行改檔名套用，例如： .vscode/recommended-settings.json 可以複製成 .vscode/settings.json nvmrc手邊每一個 node 的專案都不同版本，那為了確保版本的正確性，可以使用 .nvmrc 的檔案搭配 zsh script 自動載入版本，這樣就可以避免每次開啟 terminal 都還要手動切換版本的問題。 首先要在專案中產生 .nvmrc 的檔案 1node -v &gt; .nvmrc 接著到 .zshrc 中將以下的 script 貼上 123456789101112131415161718192021# place this after nvm initialization!autoload -U add-zsh-hookload-nvmrc() &#123; local node_version=&quot;$(nvm version)&quot; local nvmrc_path=&quot;$(nvm_find_nvmrc)&quot; if [ -n &quot;$nvmrc_path&quot; ]; then local nvmrc_node_version=$(nvm version &quot;$(cat &quot;$&#123;nvmrc_path&#125;&quot;)&quot;) if [ &quot;$nvmrc_node_version&quot; = &quot;N/A&quot; ]; then nvm install elif [ &quot;$nvmrc_node_version&quot; != &quot;$node_version&quot; ]; then nvm use fi elif [ &quot;$node_version&quot; != &quot;$(nvm version default)&quot; ]; then echo &quot;Reverting to nvm default version&quot; nvm use default fi&#125;add-zsh-hook chpwd load-nvmrcload-nvmrc 接著用一個新視窗來開啟專案，就可以看到 zsh 自動載入 node 版本 123&gt; cd /GrapefruitFound &#x27;/Grapefruit/.nvmrc&#x27; with version &lt;v12.6.0&gt;Now using node v12.6.0 (npm v6.9.0) 實測以後，發現這個功能雖然好用，但開啟的速度就會變比較慢一點點，如果在意的話，建議不要使用 參考資料 angular vscode readme vscode recommend extensions nvmsh","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Project","slug":"Frontend/Project","permalink":"http://jiaming0708.github.io/categories/Frontend/Project/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://jiaming0708.github.io/tags/vscode/"},{"name":"nvm","slug":"nvm","permalink":"http://jiaming0708.github.io/tags/nvm/"}]},{"title":"在 elasticsearch 更新後立即能夠查詢","slug":"elastic-update-refresh","date":"2020-05-21T14:24:59.000Z","updated":"2023-03-09T14:18:38.727Z","comments":true,"path":"2020/05/21/elastic-update-refresh/","link":"","permalink":"http://jiaming0708.github.io/2020/05/21/elastic-update-refresh/","excerpt":"一般的關聯式資料庫下 update 以後，如果沒有下 commit 大部分情況是拿到舊的資料，但是在 elastic search 的環境下，沒有所謂的 commit，在異動資料後馬上執行 search 卻拿不到更新後的結果。","text":"一般的關聯式資料庫下 update 以後，如果沒有下 commit 大部分情況是拿到舊的資料，但是在 elastic search 的環境下，沒有所謂的 commit，在異動資料後馬上執行 search 卻拿不到更新後的結果。 只要你在下指令的時候，加上 refresh 這個條件並且指定為 true，就可以馬上讓 search 看到異動後的資料。 官方不太建議使用，如果真的要用要小心，官方文件 這邊附上 elasticsearchjs 的範例，將符合的 id 都改為 deleted 的狀態。 123456789101112131415elastic.updateByQuery(&#123; index: TABLE_NAME, refresh: true, body: &#123; script: &#123; lang: &#x27;painless&#x27;, source: &#x27;ctx._source[&quot;deleted&quot;] = true&#x27;, &#125;, query: &#123; terms: &#123; id: ids, &#125;, &#125;, &#125;,&#125;);","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"ElasticSearch","slug":"Backend/ElasticSearch","permalink":"http://jiaming0708.github.io/categories/Backend/ElasticSearch/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://jiaming0708.github.io/tags/ElasticSearch/"},{"name":"Database","slug":"Database","permalink":"http://jiaming0708.github.io/tags/Database/"}]},{"title":"使用 Github Action 作為 CI/CD 將 libraray 發佈到 Github Package","slug":"github-action-and-package","date":"2020-05-21T13:43:19.000Z","updated":"2023-03-09T14:18:38.727Z","comments":true,"path":"2020/05/21/github-action-and-package/","link":"","permalink":"http://jiaming0708.github.io/2020/05/21/github-action-and-package/","excerpt":"Continuous Integration (以下簡稱CI)，是在開發中很重要的一環，大家常用或常聽到的例如：Jenkins, Travis…等等的，我們常在使用的 Github 本身也有提供類似的服務。今天來使用 Github 的全套服務，使用 Action 做 CI&#x2F;CD 並且發佈到 Package。","text":"Continuous Integration (以下簡稱CI)，是在開發中很重要的一環，大家常用或常聽到的例如：Jenkins, Travis…等等的，我們常在使用的 Github 本身也有提供類似的服務。今天來使用 Github 的全套服務，使用 Action 做 CI&#x2F;CD 並且發佈到 Package。 使用Action Github本身對於Action有一些限制和收費的方式，詳細請參考官方文件。 使用範本建立在開始之前當然就要先建立好一個 repo ，點選到 Action 的頁籤，就可以開始建立囉 一個還沒有建立過 Action 的專案，會先看到上圖的畫面，可以從現有的範本中做建立的動作，那我們就使用 Simple workflow 來做為我們的第一個 Action，從範本中我們可以發現到兩件事情 yaml 的格式做撰寫 檔案存在 .github/workflow 底下 先什麼都不改然後 commit 就可以到 Action 的頁籤中確認執行狀況，從下圖中可以看到 CI 的 workflow 已經執行成功 了解yaml為了之後能夠寫出自己的檔案，就要先了解檔案的每個區塊是怎麼運作，詳細可以參考官網 為了篇幅我將註解都刪除 1234567891011121314151617name: CIon: push: branches: [ master ] pull_request: branches: [ master ]jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Run a one-line script run: echo Hello, world! - name: Run a multi-line script run: | echo Add other actions to build, echo test, and deploy your project. nameworkflow 的名稱，為了區別不同的行為，可以將名稱取成不一樣。 on觸發 workflow 的時機點，按照範例觸發時機是 push 新 commit 或是對這個 branch 發 PR 。 jobs定義要執行的工作項目，可以一個或多個（預設每個工作項目是平行處理）。 build第一層的 build 是 job_id ，若有多個 job 請記得不要重複並且取好懂一點的名字 runs-on要以哪個環境做執行 (window&#x2F;ubuntu&#x2F;macos)，支援列表可以參考這邊 steps執行的步驟，會按照順序的往下執行 uses使用別人已經寫好的功能作為基礎來進行後續的動作，以此範例是用來 checkout repo 官方建議後面要加上版本號，避免突然間炸掉 name&#x2F;run每個步驟的名稱，以及要執行的指令 看看build log 可以看到左邊的 build 就是所有的 job，右邊則是列出所有的 steps ###執行錯誤 如果有執行錯誤從外面其實看不到是在哪一個步驟錯誤，必須要到詳細的 log 中查看才行 Package前面已經了解完了 Action，接著第二個目的是使用 Github Package 這個服務，這個服務本身不是只能放 javascript 的 library 也是能夠放其他語言的 library ，例如 nugget、gem 等等的，詳細請見官方說明 登入使用 npm 的方式做登入，只是要另外指定 registry；登入的時候使用的是 Github 的帳號以及 token ，token產生方式可以參考這邊 因為我們要用的是 package 功能，所以除了 repo 以後還要將 package 的權限也打開 1234$ npm login --registry=https://npm.pkg.github.com&gt; Username: USERNAME&gt; Password: TOKEN&gt; Email: PUBLIC-EMAIL-ADDRESS 設定 package.json要發佈到 package 之前要先將 package.json 設定好，這邊有兩個地方要注意一下 publishConfig 要設定 registry name 必須是 organization&#x2F;personal account 加上這個 repo 的名稱 我們的 repo 假設叫做 jimmy-first-library 那我們發佈到 npm 的時候可以改名稱叫做 jimmy-library，但是在 Github 是不被允許的，因為他是基於 repo 去產生的 package 所以名稱必須相同 12345&#123; &quot;name&quot;: &quot;@jiaming0708/schematics-react&quot;, // ... &quot;publishConfig&quot;: &#123; &quot;registry&quot;: &quot;https://npm.pkg.github.com/&quot; &#125;&#125; 發佈做完以上的動作以後，我們就可以用 npm 的 publish 指令，進行發佈 1npm publish 接著我們可以到 Github 的 repo 中查看 安裝發佈以後我們可以來安裝看看，在專案的根目錄中，加上 .npmrc 在裡面要加上 package 所屬的 owner，接著就可以使用一般的 npm 安裝方法 1registry=https://npm.pkg.github.com/jiaming0708 如果你是到另一個環境做測試的話，記得要重新登入 使用 Action 發佈到 Package我們要在steps底下，加上下面的語法 123456789- name: Setup Node.js environment uses: actions/setup-node@v1 with: node-version: &#x27;12.6.0&#x27; registry-url: &#x27;https://npm.pkg.github.com&#x27; scope: &#x27;@jiaming0708&#x27;- run: npm publish env: NODE_AUTH_TOKEN: $&#123;&#123;secrets.GITHUB_TOKEN&#125;&#125; node環境建置使用別人寫好的 node 環境，並且加上 with 指定一些參數 發佈執行發佈的時候，一樣要提供 token 讓 action 來幫我們登入，這邊必須要將 token 放在 env 的設定中 這邊有一個很厲害的地方， GITHUB_TOKEN 是一個預設的變數，每次會執行時自動產生並且提供對應的權限，因此你不需要特別的再產生什麼樣的 token 來給 action 使用 總結Github Action 基本上蠻方便的，除了做 CI&#x2F;CD 以外，也可以拿來做 issue 上的 tag，對於一個很多人在使用的 open repo 管理上會很有幫助。 Github Package 以 javascript 就是另一個私人的 libraies，使用上較為麻煩，一定要做登入的動作； repo 和 library 名稱一定要相同，不然會發佈失敗。 第一次的使用上來說對於 Action 的評價高過於 Package，但因為 npm 已經被 github 買下，所以未來會不會移到 package 也不好說。 reference sample repo Learn YAML Workflow syntax for GitHub Actions Github package documentation","categories":[{"name":"CI/CD","slug":"CI-CD","permalink":"http://jiaming0708.github.io/categories/CI-CD/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://jiaming0708.github.io/tags/Github/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://jiaming0708.github.io/tags/CI-CD/"}]},{"title":"chrome devtool介紹","slug":"chrome-devtool-intro","date":"2020-03-26T13:06:51.000Z","updated":"2023-03-09T14:18:38.699Z","comments":true,"path":"2020/03/26/chrome-devtool-intro/","link":"","permalink":"http://jiaming0708.github.io/2020/03/26/chrome-devtool-intro/","excerpt":"今天晚上聽 林亨力 在 GDG台中 分享的 如果你連DevTools都不會用，還敢說你是網頁設計者嗎，滿滿的乾貨，所以趁新鮮趕快來記錄一下自己所不知道的部份。","text":"今天晚上聽 林亨力 在 GDG台中 分享的 如果你連DevTools都不會用，還敢說你是網頁設計者嗎，滿滿的乾貨，所以趁新鮮趕快來記錄一下自己所不知道的部份。 命令列選單在DevTool任何地方按下 cmd+shift+p ，就可以叫出選單，才發現滿滿的功能！！ window請用 control+shift+p 檢視animation在命令列選單輸入 animation 就只會看到一個選項，點下去就可以在下方看到新的 tab（如下圖）。 在裡面就能夠看到目前頁面中所有的動畫元素，並且可以暫停重跑。 在今天之前，如果要看 animation 的效果並且調整，我會選擇 firefox 查看，現在才知道原來chrome也有類似的功能。實際操作了一下，發現還是 firefox 比較強，在 firefox 是顯示某個元素底下所有的結果，不用另外開出來，直接在檢視中就提供（如下圖）。 截圖想要把整個網頁截取的話，可以不用額外的工具，只需要在命令列中輸入 screenshot 選取 capture full size 就會開始執行截圖的行為，但需要一下下的執行時間，請耐心等候。 Sensors一樣在命令列輸入 sensor ，這個 tab 中可以看到下面這幾個功能，個人覺得這 tab 的功能很酷！ Geolocation可以模擬訊號位置到別的地區，對於這方面的測試是蠻方便的，最簡單的測試是打開 google map 並且變更設定到 berlin ，重新整理後就會發現自己離開台灣啦🤩（可以打卡出國了 Orientation模擬手機的陀螺儀功能，可以到這個網站，並且將 orientation 設定改為 protrait upsite down ，重新整理後在右邊手機的地方點著旋轉，就可以上下左右的觀看了🤩 Network Condition在命令列輸入 network condition 開啟 tab ，看到下面的 user-agent ，可以更改想要模擬的裝置 Coverage在命令列輸入 coverage 開啟 tab 後點擊 refresh 的圖示，就可以看到你網站的所有 css 以及 js 檔案使用率，對於效能調教上有著很大的幫助。基本上應該是越少紅色越好，因為紅色代表著未被該頁面使用到。 偵錯design mode在 console 的 tab 中輸入 document.designMode=&#39;on&#39; 就可以直接在畫面上編輯元素的文字，這對於要測試多文字樣式的確認還蠻方便的。 CSS overview目前在 stable 版本是沒有的，可以看看別人的介紹，會讓我有點期待想要看到公司的網站會顯示什麼樣的內容 Reference slide","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"chrome","slug":"Frontend/chrome","permalink":"http://jiaming0708.github.io/categories/Frontend/chrome/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"http://jiaming0708.github.io/tags/chrome/"}]},{"title":"[CSS] ios的iframe問題","slug":"ios-safari-iframe-issue","date":"2020-03-14T08:22:46.000Z","updated":"2023-03-09T14:18:38.691Z","comments":true,"path":"2020/03/14/ios-safari-iframe-issue/","link":"","permalink":"http://jiaming0708.github.io/2020/03/14/ios-safari-iframe-issue/","excerpt":"如果要掛載另一個網站的內容進來時，通常會使用iframe，今天要來分享一下在ios safari的bug，並且要如何解決 iframe使用雖然方便但也要小心一些安全性的問題","text":"如果要掛載另一個網站的內容進來時，通常會使用iframe，今天要來分享一下在ios safari的bug，並且要如何解決 iframe使用雖然方便但也要小心一些安全性的問題 問題發現的問題有兩個，也都蠻容易重現的，剛好有用到iframe的話，就必須要注意一下！ 寬度超過100% 捲動穿透看到iframe後層的內容 可以從底下的button看到，寬度是不正確的，並且在捲動的時候，有個莫名的背景出現。 發生環境是在 ios 11 &amp; 12 ，在 ios 13 已經修正。（更低版本的就沒有特別測試，因為公司產品的 app 最低也只有支援到 11） 解決方法先來看一下html的結構 123456&lt;body&gt; &lt;div&gt;原始網站內容&lt;/div&gt; &lt;div style=&quot;position: absolute;right: 10px;bottom: 10px;width: 300px;max-width: 100%;&quot;&gt; &lt;iframe style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/body&gt; 寬度超過100%首先看一下 iframe 的父層設定 width: 300px; ，為了讓 iframe 佔滿整個空間，因此設定 width: 100%; 但是在safari上偏偏就是會發現他超過了！！ 必須要使用一個workaround來解決這個問題，不要直接設定 width 而是改成設定 min-width 並且加上 scrolling 的屬性。 1&lt;iframe style=&quot;width: 0;min-width: 100%;&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; 如果同時需要支援手機和桌機的話，記得加上檢查瀏覽器版本的語法來控制 scrolling 的屬性 123function isiOS()&#123; return /iP(hone|od|ad)/.test(navigator.platform);&#125; 捲動穿透捲動的問題可以透過 overflow 相關的兩個屬性來解決，這次就不是放在 iframe 身上，而是要放在父層才會有效果；目前測試起來不會因為手機或桌機而有所區別。 123&lt;div style=&quot;-webkit-overflow-scrolling: touch;overflow-y: scroll;&quot;&gt; &lt;iframe&gt;&lt;/iframe&gt;&lt;/div&gt; 結論這些問題在safari似乎存在很久，使用關鍵字 ios iframe issue 蠻容易查到相關的資料，但不知道為什麼 apple 拖到 ios 13 才修正掉，只能說前端真的很辛苦，要面對各種瀏覽器廠商所留下的坑。 順帶一提，如果是用mac的朋友，可以使用 simulator 來進行測試，還能透過本機的safari來針對device上的做檢視。 safari真的是新一代的IE","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"http://jiaming0708.github.io/categories/Frontend/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://jiaming0708.github.io/tags/CSS/"},{"name":"debug","slug":"debug","permalink":"http://jiaming0708.github.io/tags/debug/"}]},{"title":"[CSS] 利用animation做圓形的移動","slug":"circle-path-animation","date":"2020-02-29T02:58:30.000Z","updated":"2023-03-09T14:18:38.691Z","comments":true,"path":"2020/02/29/circle-path-animation/","link":"","permalink":"http://jiaming0708.github.io/2020/02/29/circle-path-animation/","excerpt":"在畫面上的一個物件的移動方式希望能夠是圓形的，除了用javascript計算的方式以外，有沒有css的方式能做到呢？今天要來一探究竟","text":"在畫面上的一個物件的移動方式希望能夠是圓形的，除了用javascript計算的方式以外，有沒有css的方式能做到呢？今天要來一探究竟 position模擬不知道你會不會跟我第一時間的想法一樣，用兩點移動近似圓形的走法可不可以呢？使用 animation 搭配 position 的變化，理論上應該是可以做到這件事情 1234567891011121314@keyframes move&#123; 0%&#123; left: 10px; top: 10px; &#125; 50%&#123; left: 20px; top: 20px; &#125; 100%&#123; left: 10px; top: 10px; &#125;&#125; 但因為是兩點的移動是直線，這就等於要切非常細才會趨近於圓，可以想像一下…要算多久才能寫好一個圓形的移動？ 使用rotate另外一個方法就是使用 rotate 可以更輕鬆的達成目標，首先來看一下MDN的定義 The rotate() CSS function defines a transformation that rotates an element around a fixed point on the 2D plane, without deforming it 從定義中可以知道，rotate 會做角度的旋轉 原地旋轉因此先寫個來測試一下旋轉這件事情，設定一個 keyframe 角度是從0到360 12345678@keyframes move&#123; 0%&#123; transform: rotate(0deg); &#125; 100%&#123; transform: rotate(360deg); &#125;&#125; 加上移動距離現在已經有了旋轉的效果，那要讓物件有圓形的移動感，這時候可以使用 translate 來加上位移量 要記得只能有一個 transform，儘管 translate 沒有變化還是要每次都寫 12345678@keyframes move&#123; 0%&#123; transform: rotate(0deg) translateX(10px); &#125; 100%&#123; transform: rotate(360deg) translateX(10px); &#125;&#125; 維持正面其實這樣已經完成了八成了，但還差一點點，就是希望字不要跟著轉，這時候要用到 transform 的特性 同一個function會累加計算 由左至右計算 累加計算那我們先來測試第一件事情，同一個function會累加計算，寫 rotate 一個0和一個45，最後結果會是 45 123div&#123; transform: rotate(0deg) rotate(45deg);&#125; 由左至右animation 會根據數字的不同來做動畫的效果，根據上面的作法，如果 rotate 先給一個數字接著減去同樣的數字，是不是就能夠移動了呢？ 12345678@keyframes move&#123; 0%&#123; transform: rotate(0deg) rotate(-0deg) translateX(10px); &#125; 100%&#123; transform: rotate(360deg) rotate(-360deg) translateX(10px); &#125;&#125; 答案是不行的，當 rotate 給了一個數值接著馬上減掉，這時候並不會讓 animation 認為這個function有變化量，因此再兩個 rotate 中間，必須要加上其他的 function 來做為緩衝，讓 animation 誤以為 rotate 有變化 組合結果12345678@keyframes move&#123; 0%&#123; transform: rotate(0deg) translateX(10px) rotate(-0deg); &#125; 100%&#123; transform: rotate(360deg) translateX(10px) rotate(-360deg); &#125;&#125; 結論這個作法一開始看到的時候，其實我根本無法理解原理，因為 rotate 算出來就是0阿，但為什麼他能夠引發角度的變化呢，原來是還要加上另一個特性，才能夠做出這樣的效果 另外，有興趣的話也可以加上 scale 或是將 translate 的值改變，試試看效果是什麼喔！ 參考 Animating Circular Paths Using CSS3 Animations MDN","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"http://jiaming0708.github.io/categories/Frontend/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://jiaming0708.github.io/tags/CSS/"}]},{"title":"讓vscode讀懂alias path","slug":"alias-path-vscode","date":"2020-01-31T09:00:14.000Z","updated":"2023-03-09T14:18:38.691Z","comments":true,"path":"2020/01/31/alias-path-vscode/","link":"","permalink":"http://jiaming0708.github.io/2020/01/31/alias-path-vscode/","excerpt":"在專案開發的時候，為了讓import的路徑短一點，通常都會用alias來處理，例如../../../components/Button會用@components/Button來做為取代 這邊不討論用auto import還是用alias的好壞","text":"在專案開發的時候，為了讓import的路徑短一點，通常都會用alias來處理，例如../../../components/Button會用@components/Button來做為取代 這邊不討論用auto import還是用alias的好壞 code123// import Button from &#x27;../../../components/Button&#x27;;// aliasimport Button from &#x27;@components/Button&#x27;; webpack首先我們會在webpack加上resolve的設定 相關資料可以參考官網 1234567&#123; resolve: &#123; alias: &#123; &#x27;@components&#x27;: path.resolve(__dirname, &#x27;src/components&#x27;) &#125; &#125;&#125; 這樣的設定是為了讓編譯看的懂，但是vscode還是看不懂，當你滑鼠移動到 @components/Button 就無法知道真正的路徑，也沒辦法快速的用f12移動到檔案中看內容 jsconfig為了要能夠讓vscode讀懂alias，可以在根目錄底下建立jsconfig.json，在裡面加上下面的設定，儲存後不用重開只要等個幾秒，就可以測試是不是有效了！ 相關資料可以參考官網 12345678910&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es2017&quot;, &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: &#123; &quot;@components/*&quot;: [&quot;src/components/*&quot;] &#125; &#125;, &quot;exclude&quot;: [&quot;node_modules&quot;]&#125; 在我的專案中，如果只有設定baseUrl和paths是沒有效果的，必須要搭配上target才能正確的解析，在使用上需要注意一下，避免設定完了結果還是不會work","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"vscode","slug":"Frontend/vscode","permalink":"http://jiaming0708.github.io/categories/Frontend/vscode/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://jiaming0708.github.io/tags/vscode/"},{"name":"webpack","slug":"webpack","permalink":"http://jiaming0708.github.io/tags/webpack/"}]},{"title":"[Debug] iterm2的頁籤標題設定","slug":"iterm2-session-title","date":"2019-10-22T13:47:48.000Z","updated":"2023-03-09T14:18:38.687Z","comments":true,"path":"2019/10/22/iterm2-session-title/","link":"","permalink":"http://jiaming0708.github.io/2019/10/22/iterm2-session-title/","excerpt":"一直以來都有用 iterm2 作為 bash 的工具，最近不知道什麼樣的更新，讓頁籤的標題永遠都只會顯示 zsh ，但工作的關係，一次都會開好幾個專案在跑，那每個都顯示 zsh 說真的還真沒記得哪個頁籤是什麼…","text":"一直以來都有用 iterm2 作為 bash 的工具，最近不知道什麼樣的更新，讓頁籤的標題永遠都只會顯示 zsh ，但工作的關係，一次都會開好幾個專案在跑，那每個都顯示 zsh 說真的還真沒記得哪個頁籤是什麼… 上圖是壞掉的狀況，為了示範只有兩個頁籤，但是實際上在工作的時候我會開四五個，到底是哪邊的設定跑掉呢？ 首先，要先定義一下名詞，在 iterm 裡面，每個頁籤其實叫做 session ，這樣在查找資料的時候才會比較容易，不然會像我一樣一直用 tab title 去查，查到的不一定是錯的，但就是解不了我的問題 設定這個問題其實很簡單，只是一個設定跑掉而已，找了很久才找到，打開 preferences 的設定，進入到 Profiles 的頁籤，然後找到 Title 這個下拉選單 錯誤 從上面這張可以看到，只選了 Job 然後其他都沒了，試著每個都選選看可以看到不一樣的變化 預設那預設的是什麼呢？應該要選 Session Name + Job 設定完的 iterm 就會回到正常的資料夾顯示於標題 參考https://iterm2.com/documentation-session-title.html","categories":[{"name":"iterm","slug":"iterm","permalink":"http://jiaming0708.github.io/categories/iterm/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"http://jiaming0708.github.io/tags/Debug/"},{"name":"iterm","slug":"iterm","permalink":"http://jiaming0708.github.io/tags/iterm/"}]},{"title":"[mac] Catalina的notification設定","slug":"mac-catalina-notifiction","date":"2019-10-14T07:36:11.000Z","updated":"2023-03-09T14:18:38.679Z","comments":true,"path":"2019/10/14/mac-catalina-notifiction/","link":"","permalink":"http://jiaming0708.github.io/2019/10/14/mac-catalina-notifiction/","excerpt":"上禮拜官方release了最新的作業系統，當然要跟上體驗最新的Catalina這個作業系統，但是蘋果提昇了Catalina的一些安全性管理，如果你跟我一樣討厭被notification打擾，那可以看一下我怎麼設定","text":"上禮拜官方release了最新的作業系統，當然要跟上體驗最新的Catalina這個作業系統，但是蘋果提昇了Catalina的一些安全性管理，如果你跟我一樣討厭被notification打擾，那可以看一下我怎麼設定 在更新完系統後，開啟各種app就會開始提示你是否允許notification，如果你跟我一樣都按 Not allow(不允許)然後就GG惹，會發現app的所有通知都不見（包含badge） 開啟notification接著我們要來重新設定一下 在 System Preferences 找到 Notifications 並且打開 找到不被允許的app，並且設定成允許通知 對我來說只需要有badge就可以，其他都不需要，將設定改成只剩下badge就好 slack設定只要在Notifications中沒有被列出來的app就代表沒有需要通知的功能，如果你的slack是沒有被列在裡面的，可以參考一下我的作法 前面有說到我很不喜歡太多的notification，因此我把slack設定成都沒有任何提醒只會顯示badge 在這個情況下，對於Catalina來說是等於沒有需要通知這個功能，因此完全不會被列在 Notifications 中，那要做的事情很簡單 將 Nothing 改成其他的任何一種 新的訊息進來時候系統就會問你是否要開啟或是關閉notification的功能 一樣到 Notifications 做詳細的設定 看你的習慣要不要再把slack的設定改回去成 Nothing 結論照習慣還是要結論一下，因為新系統的安全性提高，因此有些地方要重新設定，以免跟之前的使用習慣都不一樣。 如果你還沒升級或是升級以後遇到類似的情況，希望這篇能對你有所幫助","categories":[{"name":"mac","slug":"mac","permalink":"http://jiaming0708.github.io/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://jiaming0708.github.io/tags/mac/"}]},{"title":"rxjs之operator使用介紹","slug":"rxjs-operator","date":"2019-07-16T14:23:04.000Z","updated":"2023-03-09T14:18:38.679Z","comments":true,"path":"2019/07/16/rxjs-operator/","link":"","permalink":"http://jiaming0708.github.io/2019/07/16/rxjs-operator/","excerpt":"很多人在使用rx的時候，往往遇到的瓶頸是operator的使用，因為實在太多可以使用，今天要來分享一下我曾經用過以及常用的operator是哪些","text":"很多人在使用rx的時候，往往遇到的瓶頸是operator的使用，因為實在太多可以使用，今天要來分享一下我曾經用過以及常用的operator是哪些 operator從一開始寫Rx到現在，全部使用的operator有差不多18個左右，其中只有五個是最常用的，其他都是遇到需求而使用 目前官方大概有100個左右 of將參數輸出成資料流，常用建構observable之一 1234of(1, 2, 3).subscribe(console.log);// 1// 2// 3 from跟of類似，個人蠻常用在將陣列拆解 1234from([1, 2, 3]).subscribe(console.log);// 1// 2// 3 fromEvent監聽element的事件最佳利器！！沒有之一XD 1fromEvent(window, &#x27;scroll&#x27;).subscribe(console.log); map這個是最常用之一，只要有任何的物件轉換就一定會使用到，而且一段裡面可能會使用好幾次 12345map(p =&gt; (&#123; id: p.id, name: p.Name, &#125;)) mergeMap把merge和map的功能合一，兩個observable資料是可以並行進來輸出 switchMap功能與mergeMap類似，資料進來後會取消前面的資料重新要一次 concatMap跟mergeMap類似，但會等到前一個observable結束才會執行，通常使用於前面的API結束後才能執行後面的API filter顧名思義，就是過濾資料用，例如重複的資料不想要，或是只想要拿到某些資料 123from([true, false, true]).pipe( filter(p =&gt; !!p)) tap基本上寫rx應該要讓每一個function都是pure的，減少side effect但如果真的再中間需要寫入一些值的話就可以使用，另一個使用狀況就是debug啦 1234from([true, false, true]).pipe( filter(p =&gt; !!p), tap(console.log),) takeUntil比較多使用在unsubscribe一個observable，在angular中就是ngOnDestroy事件中，在react就是componentWillUnmount 12345678910fromEvent(window, &#x27;scroll&#x27;).pipe( takeUntil(this.destory$))destory$ = new Subject();ngOneDestory()&#123; this.destory$.next(); this.destory$.complete();&#125; toArray前面有說到會用switchMap把陣列拆解開，但最後的資料就是需要陣列，這時候就很適合使用 123of(1, 2, 3).pipe( toArray()) reduce資料整理上的好幫手，可以把陣列拆解，然後可以輸出任何類型的資料 12345from([1, 2, 3]).pipe( reduce((acc, value) =&gt; &#123; acc.push(value * 2); &#125;, [])) catchError我主要應用在串接API，當發生錯誤時要先做處理然後再讓呼叫端拿到error 12345678of(undefined).pipe( map(p =&gt; p.name), catchError(p =&gt; &#123; // do something // 結束整個observable return Observable.throw(p); &#125;)) debounceTime收到資料沒有變化多久的時間後就會觸發，適合在不想要被頻繁觸發的事件上，例如autocomplete 123fromEvent(input, &#x27;keyDown&#x27;).pipe( debounceTime(200)) delay跟sleep差不多的概念（笑），基本上只使用過一次，demo project為了模擬api的效果才用的 bufferCount累積n筆資料以後才輸出，輸出為陣列，但要注意，如果數量不夠，那些資料就會一直卡在拿不到！基本上也只使用過一次 123of(1, 2, 3).pipe( bufferCount(2)) pairwise情境是為了要可以拿到連續配對的資料 [1, 2] [2, 3] [3, 4]；只使用過一次 補充，也能用在scroll事件，可以用來判斷前次和這次的捲軸位置 123of(1, 2, 3).pipe( pairwise()) bufferTime資料需要被累積一定時間後再一起輸出，輸出為陣列；只使用過一次 123of(1, 2, 3).pipe( bufferTime(100),) 小結好的，介紹完曾經使用過的operator，有沒有發現有不少都非常的難用到，因為情境太少，畢竟大部分的情況都還是在整理資料或是串接的用途 subject為什麼要額外提subject呢，因為這個功能實在太好用啦，使用情境來列一下 變數值是一樣的，但希望被重複觸發 例如alert message，什麼時候不會管，外層只需要呼叫讓component顯示就好 1234567//只會觸發一次var openDialog = true;//&lt;app-dialog [open]=&quot;openDialog&quot; /&gt;var openDialog$ = new Subject();openDialog$.next(true);//&lt;app-dialog [open]=&quot;openDialog$&quot; /&gt; 手動控制資料時間點，例如destory 需要有預設值或是取得前幾次的結果（其他subject） 結論operator常用的就那幾個，剩下都是屬於情境型的應用，再沒有看到那種case的情況下，就是不知道這些要怎麼使用，所以也不用擔心，先開始用並且寫下去就知道我也寫過一個map露露等5.60行的，先交差，後面再來想要怎麼改善，一次到位永遠都是最痛苦的 看完這篇也能看看另一篇 Rx真實案例展示 會更有感覺喔! 如果覺得挑戰不夠，可以看看這個repo，絕對給你滿滿的應用！","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"RxJS","slug":"Frontend/RxJS","permalink":"http://jiaming0708.github.io/categories/Frontend/RxJS/"}],"tags":[{"name":"RxJS","slug":"RxJS","permalink":"http://jiaming0708.github.io/tags/RxJS/"}]},{"title":"[Debug] AI匯出svg小雷","slug":"ai-export-svg","date":"2019-07-07T03:28:17.000Z","updated":"2023-03-09T14:18:38.679Z","comments":true,"path":"2019/07/07/ai-export-svg/","link":"","permalink":"http://jiaming0708.github.io/2019/07/07/ai-export-svg/","excerpt":"AI全名是Adobe Illustrator，由Adobe出的一個繪圖工具，今天為什麼會講到這個工具呢？原因是最近公司要做re-brand的動作，designer出的icon都是用svg做匯出，但卻發生了顏色跑掉的問題，原本是藍色變成黑色","text":"AI全名是Adobe Illustrator，由Adobe出的一個繪圖工具，今天為什麼會講到這個工具呢？原因是最近公司要做re-brand的動作，designer出的icon都是用svg做匯出，但卻發生了顏色跑掉的問題，原本是藍色變成黑色 版本介紹 Adobe Illustrator 2017 cc中文 簡單介紹SVGSVG全名是Scalable Vector Graphics，透過xml的格式撰寫，可縮放的向量圖。因為是直接把顏色當成是attribute的方式做宣告因此同一個svg要呈現不同顏色時不用再重出一張圖，只要透過css就可以做到染色的行為。 問題檔案內容剛剛有說到顏色可以透過attribute的方式宣告，並且可以透過css的方式做染色的行為，今天這個狀況就是發生在css的部份 123456789&lt;svg id=&quot;Layer_1&quot; data-name=&quot;Layer 1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 24 24&quot;&gt; &lt;defs&gt; &lt;style&gt;.cls-1&#123;fill:#231714;&#125;&lt;/style&gt; &lt;/defs&gt; &lt;title&gt;ic_audio_pause_240&lt;/title&gt; &lt;path class=&quot;cls-1&quot; d=&quot;M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,20a9,9,0,1,1,9-9A9,9,0,0,1,12,21Z&quot;/&gt; &lt;rect class=&quot;cls-1&quot; x=&quot;9&quot; y=&quot;8&quot; width=&quot;2&quot; height=&quot;8&quot; rx=&quot;0.5&quot;/&gt; &lt;rect class=&quot;cls-1&quot; x=&quot;13&quot; y=&quot;8&quot; width=&quot;2&quot; height=&quot;8&quot; rx=&quot;0.5&quot;/&gt;&lt;/svg&gt; 因為是透過AI產生的圖檔，class的名稱對軟體來說不重要，只要有產生預期的效果就好，因此所有的icon都是從.cls-1開始做命名，然後輸出的時候又是用style的方式做顏色的宣告。 問題解析可能有人發現問題點了，****是一種全域的宣告，也就是說今天你的html中只要有任何一個class叫做.cls-1的全部都會符合這個selector被染成紅色 再加上css的特性之一，相同的宣告後面的會蓋掉前面的，也就是常在說的覆蓋，因此只要.cls-1這個class的顏色有不一樣，那就會變成看誰是最後被載入的，全部都會跟著變成他的顏色 請看完整範例 AI怎麼設定這個問題當然只要把svg修掉就解決，問題是每次designer出圖的時候都要在那邊檢查修改嗎？難道AI沒有辦法從輸出的時候就處理掉這個問題嗎？ 首先來看一下AI輸出的畫面，點選工具列 檔案 &gt; 轉存 &gt; 轉存為螢幕適用 就可以看到下方這個畫面，右側選擇格式的右上方有一個小小齒輪（紅色圈） 點進去以後可以看到下面這個畫面，接著選到SVG看一下裡面有哪些設定 這次的目標是要把樣式改對，因此點選樣式設定，可以看到有三個選項 內部CSS &lt;&#x3D;&#x3D; 預設 內嵌樣式 簡報屬性 &lt;&#x3D;&#x3D; 請選擇 是說有沒有人覺得簡報屬性的翻譯很難懂阿，我看到的當下完全不知道是要做什麼用…lol 將樣式改為簡報屬性，再次輸出測試，可以看到顏色就變成使用attribute做宣告，這樣就可以打完收工 123456&lt;svg id=&quot;Layer_1&quot; data-name=&quot;Layer 1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 24 24&quot;&gt; &lt;title&gt;ic_audio_pause_240&lt;/title&gt; &lt;path class=&quot;cls-1&quot; fill=&quot;#231714&quot; d=&quot;M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,20a9,9,0,1,1,9-9A9,9,0,0,1,12,21Z&quot;/&gt; &lt;rect class=&quot;cls-1&quot; x=&quot;9&quot; y=&quot;8&quot; width=&quot;2&quot; height=&quot;8&quot; rx=&quot;0.5&quot;/&gt; &lt;rect class=&quot;cls-1&quot; x=&quot;13&quot; y=&quot;8&quot; width=&quot;2&quot; height=&quot;8&quot; rx=&quot;0.5&quot;/&gt;&lt;/svg&gt; 結論這個問題真的很難遇到(?)，要不是公司要做re-brand，平常designer畫UI出mockup時用sketch這套軟體產生的檔案也都沒問題，但本著從根本解決問題，遇到的當下就拉著designer一起坐下來看有什麼地方是可以調整 另外補充一個小雷，很多人用svg來產生圖檔之類，有的圖可能包含著漸層，如果說把圖sketch再輸出的話，漸層就會有部分被吃掉，如果是直接輸出的話就沒有這個問題喔","categories":[{"name":"Debug","slug":"Debug","permalink":"http://jiaming0708.github.io/categories/Debug/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"http://jiaming0708.github.io/tags/Debug/"},{"name":"SVG","slug":"SVG","permalink":"http://jiaming0708.github.io/tags/SVG/"},{"name":"AI","slug":"AI","permalink":"http://jiaming0708.github.io/tags/AI/"}]},{"title":"[CSS] flex和float應用情境","slug":"flex-float-case","date":"2019-06-13T02:29:20.000Z","updated":"2023-03-09T14:18:38.679Z","comments":true,"path":"2019/06/13/flex-float-case/","link":"","permalink":"http://jiaming0708.github.io/2019/06/13/flex-float-case/","excerpt":"一直以來都很習慣用flex來解決排版上面的問題，但最近剛好遇到了一個情況，其實用float會更加方便，今天就來探討一下這個案例","text":"一直以來都很習慣用flex來解決排版上面的問題，但最近剛好遇到了一個情況，其實用float會更加方便，今天就來探討一下這個案例 情境說明基本題有一個畫面是這樣的，在desktop的寬度下顯示三欄 ipad寬度顯示兩欄 mobile顯示一欄 進階題每一個欄的高度都不是固定，會根據資料來變化，並且有max-height超過時，每個欄要自己有scrollbar 使用flex不管看到幾欄，起手勢就是先來用個flex（誤），先來看看要怎麼樣用flex來實作這塊 desktop、mobile呈現這種三欄一欄的變化，對於flex來說根本是輕而易舉，只要稍微調整一下就好 html 12345&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item item1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item item2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item item3&quot;&gt;3&lt;/div&gt;&lt;/div&gt; css 123456789101112131415161718.container&#123; background: #cacaca; height: 300px; display: flex;&#125;.item&#123; flex: 1; background: #E7F6FC; height: 100%; border: 1px solid black;&#125;/* mobile */@media screen and (max-width: 599px)&#123; .container&#123; flex-direction: column; &#125;&#125; ipad呈現使用flex最麻煩的會是ipad的2*1+1的呈現方式，因為比較不好這樣操作，這邊會分作兩種模式來寫 基本題html不變，只是調整一下css的寫法，加上wrap讓第三欄自動的換行，這這個缺點就是第一欄和第二欄的高度不夠彈性 12345678910111213141516171819202122@media screen and (max-width: 1023px)&#123; .container&#123; flex-direction: column; flex-wrap: wrap; &#125; .item3&#123; flex-basis: 100%; &#125;&#125;/* mobile */@media screen and (max-width: 599px)&#123; .container&#123; flex-direction: column; flex-wrap: unset; &#125; .item3&#123; flex: 1; &#125;&#125; 進階題先來做個簡單的微調，看看當欄位資料超過100%會發生什麼事情 12345678910111213141516171819@media screen and (max-width: 1023px)&#123; .container&#123; flex-direction: column; flex-wrap: wrap; &#125; .item1&#123; flex-basis: 30%; &#125; .item2&#123; flex-basis: 75%; &#125; .item3&#123; flex-basis: 100%; &#125;&#125; ㄟ～奇怪，怎麼變成三欄了，說好的兩欄呢！？但應該要怎麼完成我們的需求？其實非常的簡單就是把item1、item2包起來，以結構上來說就是變成兩欄的變化 先來把html做個調整 1234567&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;column column1&quot;&gt; &lt;div class=&quot;item item1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item item2&quot;&gt;2&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column column2&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 這邊就不寫其他尺寸的css，只先寫一種case 12345678910111213141516171819202122.container&#123; background: #cacaca; height: 300px; display: flex;&#125;.column&#123; flex: 1; background: #E7F6FC; height: 100%; border: 1px solid black;&#125;.column1&#123; display: flex; flex-direction: column;&#125;.item&#123; border: 1px solid red; flex: 1;&#125; 使用float看完flex以後，接著來看看怎麼使用float做到同樣的效果，只是float比較討厭的一點就是必須要清除，不然空間會有問題 desktop html 123456&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item item1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item item2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item item3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;&lt;/div&gt; css 1234567891011121314.container&#123; background: #cacaca;&#125;.item&#123; float: left; width: 33%; height: 300px; border: 1px solid black;&#125;.clearfix&#123; clear: left;&#125; ipad呈現這邊唯一的問題就是如果有邊框或是底色，第二欄就沒辦法滿版 123456789101112131415161718192021222324252627282930.container&#123; background: #cacaca;&#125;.item&#123; border: 1px solid black; box-sizing: border-box;&#125;.item1&#123; height: 100px; width: 30%; float: left;&#125;.item2&#123; height: 200px; width: 30%; float: left; clear: left;&#125;.item3&#123; display: inline-block; width: 70%;&#125;.clearfix&#123; clear: left;&#125; mobile這邊就都把float拉掉就行，因為block預設就是一個row的行為 小技巧我有一個算是潔癖？或是怪癖？希望不要出現多餘的html，像是clearfix的element，但是float一旦沒有被清除，parent的空間呈現上是有問題的，這時候有沒有比較好的作法呢？ 有兩個方法可以解決這問題 pseudo element 12345.container::after&#123; content: &#x27;&#x27;; display: block; clear: left;&#125; overflow，這是一個奇淫技巧，可以發現有一樣的效果 123.container&#123; overflow: hidden;&#125; 結論其實不管用哪個來實作都可以，都可以做出目的的效果，但在寫css的時候還是可以看一下應用的情境，也許剛好那個情境會比較適合，那何必要用更麻煩的方式來完成呢 最後來推廣一下Amos的youtube頻道和FB粉絲團，最近在暴力班收穫滿滿阿","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"http://jiaming0708.github.io/categories/Frontend/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://jiaming0708.github.io/tags/CSS/"}]},{"title":"[抓蟲] npm全域安裝路徑錯誤","slug":"npm-global-install-folder","date":"2019-05-25T09:20:19.000Z","updated":"2023-03-09T14:18:38.679Z","comments":true,"path":"2019/05/25/npm-global-install-folder/","link":"","permalink":"http://jiaming0708.github.io/2019/05/25/npm-global-install-folder/","excerpt":"很久沒寫angular，最近接了一個小的靜態網站，想要拿牛刀來殺雞XDDD第一件事情當然就是更新最新的angular cli，但是更新後系統卻跟我說 ng command not found","text":"很久沒寫angular，最近接了一個小的靜態網站，想要拿牛刀來殺雞XDDD第一件事情當然就是更新最新的angular cli，但是更新後系統卻跟我說 ng command not found 問題情境先來看看電腦環境 macos一開始直接裝node後來改裝nvmnode: v9.3.0 既然我們是用nvm那我們安裝的npm global應該是跟著nvm底下跑，但當我下指令 npm i -g @angular/cli 卻一直跑去另一個node version的目錄底下 1/Users/jimmy/.nvm/versions/node/v6.11.1/bin/ng -&gt; /Users/jimmy/.nvm/versions/node/v6.11.1/lib/node_modules/@angular/cli/bin/ng 因此這樣在目前版本的node目錄中永遠不會有@angular/cli可以使用，但是到底是哪邊的設定影響到呢？ 問題排查nvm版本第一次先確認的是nvm中的node版本是不是根本就錯誤，因此先把v6.11.1以及v9.3.0版本刪掉，接著重新安裝v9.3.0並且設定為預設 1234nvm uninstall v9.3.0nvm uninstall v6.11.1nvm install v9.3.0nvm alias default v9.3.0 再次安裝cli但還是失敗 重新安裝nvm因此改成檢查nvm本身是不是正確的，可以參考一下這篇文章Node.js 環境設定-for mac，但我們按照步驟重新做完以後，再次安裝cli還是一樣的結果 npm最後試著往npm的相關設定找，很剛好的讓我找到了.npmrc在根目錄底下有設定了一個prefix的目錄就是v6.11.1，先註解掉試試看，再次安裝cli果然成功，可以找到ng的指令了 npmrc試著回想一下為什麼會設定prefix…原來是因為之前vscode的terminal都會一直說prefix有問題，因此找到了一個錯誤的設定，但也剛好能夠解決我的問題，就這樣用下去，設定完以後也一直沒有再使用其他的global套件，因此相安無事到現在orz 但我們還是要來了解一下.npmrc，參考一下官方的文件 prefix的目的是什麼呢，npm的指令全部都會改成到prefix指定的路徑下，而不是目前的node目錄，因此這個如果設定在~/.npmrc就會發生像我一樣的悲劇 結論要解決問題也要找對資料，不然就可能造成悲劇，其實vscode會報那個錯誤是因為當初我直接安裝node變成用nvm，因此一些設定上錯誤，這次找到其他資料才發現原來問題是在用brew安裝nvm，最後成功解決問題，可以繼續使用angular啦！！","categories":[],"tags":[]},{"title":"[CSS] 在flex呈現省略號","slug":"flex-text-overflow","date":"2019-04-16T03:10:41.000Z","updated":"2023-03-09T14:18:38.675Z","comments":true,"path":"2019/04/16/flex-text-overflow/","link":"","permalink":"http://jiaming0708.github.io/2019/04/16/flex-text-overflow/","excerpt":"最近做一些新的畫面，其中有一個問題很妙，在一般的情況下要呈現省略號，其實算是蠻容易的，但在flex中卻有點麻煩，今天要來探討一下這個部分","text":"最近做一些新的畫面，其中有一個問題很妙，在一般的情況下要呈現省略號，其實算是蠻容易的，但在flex中卻有點麻煩，今天要來探討一下這個部分 畫面架構來看一下畫面需求是這樣，左邊有一個清單，每一張卡片裡面還分兩塊，右邊的資訊過長的時候，必須是需要呈顯省略號 討論省略號要能夠呈現省略號，必須要達成三個條件，少掉一個其實都無法看到省略號 width overflow text-overflow 後面兩個其實非常容易達成，但是width呢，在flex中該怎麼讓width固定，尤其是按照比例的那種 程式撰寫html結構這個需求的重點是在左邊的list，因此右邊就簡單做就好，在這邊可以看到在一張card裡面會有所謂的圖片和內容區在左右兩邊， 123456789101112131415&lt;div class=&quot;root&quot;&gt; &lt;div class=&quot;list&quot;&gt; &lt;!-- 重點區塊 --&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;pic&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;title&quot;&gt;&lt;/div&gt; &lt;div class=&quot;descr&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;body&quot;&gt; Body &lt;/div&gt;&lt;/div&gt; css接下來來看一下css的部份，先用最直覺的寫法，結果發現怎麼都超過了阿!! 1234567891011121314151617181920212223242526272829303132333435363738394041424344.root&#123; display: flex; border: 1px solid black; height: 500px; .list&#123; width: 30%; .card&#123; display: flex; border: 1px solid blue; padding: 1rem; .pic&#123; width: 100px; border: 1px solid green; &#125; // 重點區塊 .content&#123; flex: 1; margin-left: 0.5rem; .title&#123; font-weight: bold; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; &#125; .descr&#123; margin-top: 0.25rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; &#125; &#125; &#125; &#125; .body&#123; flex: 1; text-align: center; &#125;&#125; 怎麼完全width完全沒有被控制住呢，說好的省略號呢！ 解法那先試著給width一個固定值，省略號的確可以work，跟上面所講的三要素是相同，但給固定值絕對不是我們需要的，就讓我們一起試著找一些方法來解決吧 overflow:hidden 這應該算是比較合理的解法 一定會有人覺得奇怪，在 .descr 和 .title 已經有給，但為什麼還要在給呢？這邊要增加的是設定在 .content ，因為已經設定了 flex:1 ，這時候寬度已經被分配剩餘的空間，那我們只要加上這個屬性，就能夠正常顯示省略號 1234567891011121314151617181920.content&#123; flex: 1; margin-left: 0.5rem; // 重點 overflow: hidden; .title&#123; font-weight: bold; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; &#125; .descr&#123; margin-top: 0.25rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; &#125;&#125; min-width:0 小心服用，而且不好解釋給同事聽orz 這是一個查來的作法，其實我也沒有很懂他的概念，也許有人比較清楚可以在分享分享，但一樣可以達到目的，讓寬度限制住，一個黑魔法來著… 1234567891011121314151617181920.content&#123; flex: 1; margin-left: 0.5rem; // 重點 min-width: 0; .title&#123; font-weight: bold; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; &#125; .descr&#123; margin-top: 0.25rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; &#125;&#125; 參考 codepen flexbox-truncated-text","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"http://jiaming0708.github.io/categories/Frontend/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://jiaming0708.github.io/tags/CSS/"}]},{"title":"postgres對於json的支援度","slug":"postgres-json","date":"2019-03-14T13:47:58.000Z","updated":"2023-03-09T14:18:38.675Z","comments":true,"path":"2019/03/14/postgres-json/","link":"","permalink":"http://jiaming0708.github.io/2019/03/14/postgres-json/","excerpt":"data team的同事回報了一個bug，是我寫入的資料格式不正確，導致他們在解析資料上的有困難，先把寫入資料的問題解決以後，要幫忙把錯誤的資料導正回來，才發現postgres對於json的支援度蠻高","text":"data team的同事回報了一個bug，是我寫入的資料格式不正確，導致他們在解析資料上的有困難，先把寫入資料的問題解決以後，要幫忙把錯誤的資料導正回來，才發現postgres對於json的支援度蠻高 緣由先來說說這種資料格式怎麼產生的，我們有一個academy的網站，app會用web view的方式開啟，為了要追蹤這是由哪邊連近來的，所以app在開網頁的時候會加上query parameter給我們，並且我們將這些資訊寫入到db作為觀看記錄 格式大概會是這樣 ?region=tw&amp;platform=android，但是就出現了這種情況?region=tw&amp;platform=android&amp;region=tw&amp;patform=android，收到了雙份的參數，導致寫入的時候變成了錯誤的格式 寫入的資料變成這樣 region platform 正常 tw android 錯誤 {‘tw’,’tw’} {‘android’,’android’} 解決方法這個資料格式第一眼看到，就是往json的方向去找，剛好查到postgres官方文件表示從9.3的版本以後就可以直接使用 因此就馬上很開心的使用了裡面的一個function叫做json_object_keys是用來拿到json物件的key值，沒想到收到錯誤是傳進去的值不對，馬上試著用另一個看看to_json，沒想到一樣收到錯誤說這個資料格式不正確 原來這個根本不是json物件，而是一個不知道什麼的資料格式，那該怎麼辦呢 資料轉型幸好，還有另一種轉型的function叫做array_to_json(anyarray [, pretty_bool])，我們可以這樣使用 12select array_to_json(region::text[]) from table1-- [&#x27;tw&#x27;, &#x27;tw&#x27;] 並且得到一個正確的json陣列，接著就能根據這樣的資料透過json function做解析 取值在postgres有提供一種operator的寫法，來取得json物件的資料 1234select &#x27;&#123;&quot;tw&quot;:123&#125;&#x27;::json-&gt;&#x27;tw&#x27;-- 123select &#x27;[&quot;tw&quot;, 123]&#x27;::json-&gt;0-- &quot;tw&quot; 那我們就來試試看搭配我們的資料，沒錯啦，可以完美的拿到資料，但有沒有發現一個小缺點資料是&#39;tw&#39;帶著單引號的 12select array_to_json(region::text[])::json-&gt;0 from table1-- &#x27;tw&#x27; 這時候要用另一個方法來拿到只有tw的資料，使用&gt;&gt;，真是太完美了！ 12select array_to_json(region::text[])::json-&gt;&gt;0 from table1-- tw 結論在postgres的json相關功能提供的蠻齊全，並且也有支援json作為欄位格式，在使用上就更加的彈性 這次的意外順便學到了一個新的東西，順便碰一下很久沒有碰到的資料庫，趕快把技能點上來XD 參考 JSON Functions and Operators","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"Postgres","slug":"Backend/Postgres","permalink":"http://jiaming0708.github.io/categories/Backend/Postgres/"}],"tags":[{"name":"Postgres","slug":"Postgres","permalink":"http://jiaming0708.github.io/tags/Postgres/"}]},{"title":"react component重構心得分享","slug":"react-refactor-component","date":"2019-03-12T12:25:23.000Z","updated":"2023-03-09T14:18:38.675Z","comments":true,"path":"2019/03/12/react-refactor-component/","link":"","permalink":"http://jiaming0708.github.io/2019/03/12/react-refactor-component/","excerpt":"最近在寫新的功能時，因為有些跟舊有的功能有關係，所以一定會去改到原本的code，沒去看都不知道，看了大罵WTF，這也太噁心了吧… 寫過react的人都知道，component分為兩種，一個是class component，而另一個就是pure component，不管用哪一種，不知道各位可以接受一個js(x)的行數有多少，或者更精準的是render幾行內你可以接受","text":"最近在寫新的功能時，因為有些跟舊有的功能有關係，所以一定會去改到原本的code，沒去看都不知道，看了大罵WTF，這也太噁心了吧… 寫過react的人都知道，component分為兩種，一個是class component，而另一個就是pure component，不管用哪一種，不知道各位可以接受一個js(x)的行數有多少，或者更精準的是render幾行內你可以接受 先說說我可以接受的一個render element大概是50行內，但通常我自己寫是10行左右，我是覺得一個element如果超過太多，閱讀性整個會很差，不管是不是包含邏輯 可怕的component先來看看底下這段，經過一點點的處理，但基本上架構是跟原本一樣 現在需求來了，要增加一個button在sidebar，請問你要花多久時間才能夠增加 重構第一次看到的時候，完全不知道怎麼下手，所以我打算要做一件事情重構，先把element整理的比較好懂一點，就讓我們來動作試試看吧 先抽變數後的看到程式中，有一些element是根據變數來決定要不要render，這種的最好被拉出來，因此我們先針對這種來做 1234567showCancelPopup &amp;&amp; ( &lt;Modal onClose=&#123;this.closePopup&#125; &gt; &#123;/* ... */&#125; &lt;/Modal&gt;) 把上面的這種element變成獨立的function，讓主render可以看起來輕鬆一點，從原本的190行變成90行 完整的可以看這邊 區塊抽離做完第一步以後，覺得有舒服一點，但還是不夠好，閱讀了一下整個結構，發現其實是可以分為幾個區塊，接下來就針對這些來動個手術 把兩個最大的拆出去以後，主render就只剩下20行，整個爽度都上來了 完整的可以看這邊 component化做完前面兩個步驟，已經可以先交卷，為什麼會這樣說，主力的時間應該都在feature上面，重構只是順帶一做，當然如果有足夠的時間一定要把這步驟做完，整個才會夠乾淨 要做這步驟前一定是前面兩個做完，才有機會做到，至於這個component有沒有機會被共用這又是另一件事情了，這邊不討論 接著來說一下我怎麼規劃component，主要考量會是這兩個部分 資料的來源理論上我們會希望這是一個pure component，所以資料都是由外面傳進來，但會不會有那種資料反而是去redux中取得會比較好？例如說資料只有這個component用，結果已經傳遞了n層 事件的觸發是把事件往外傳，還是直接由component呼叫redux的action執行？ 範例講了那麼多，就來實作一下，把renderCancelPopup變成component，至於為什麼我會拿這個，因為這個行為最為單純，最適合第一時間重構 總共有三個事件，那我們都讓事件往外傳，至於文字要不要是外面傳的就看你囉，基本上非共用的我比較不會從外面傳，除非真的超級少 12345678910111213141516171819202122232425262728function CancelPopup(&#123; t, closePopup, cancelQ,&#125;)&#123; return ( &lt;Modal onClose=&#123;closePopup&#125; &gt; &lt;SimpleDialog title=&#123;t(&#x27;&#x27;)&#125; theme=&#123;dialogTheme&#125; &gt; &lt;Button theme=&#123;gray&#125; ghost onClick=&#123;closePopup&#125; text=&#123;t(&#x27;&#x27;)&#125; /&gt; &lt;Button theme=&#123;pink&#125; onClick=&#123;cancelQ&#125; text=&#123;t(&#x27;&#x27;)&#125; /&gt; &lt;/SimpleDialog&gt; &lt;/Modal&gt; );&#125; 在render就可以變成這樣 1&#123;showCancelPopup &amp;&amp; &lt;CancelPopup closePopup=&#123;closePopup&#125; cancelQ=&#123;cancelQ&#125; /&gt;&#125; 結論在一開始寫的時候我也傾向先不拆分，因為那時候這個component的拆法和行為整個都還不是非常確定，而等到整個行為比較確定以後，再來開始進行重構的動作，讓自己好閱讀以外，也讓review你的code的人不會腦袋打結 這個功能的重構，我目前只有做到第二步以後就交卷了，要等下個sprint稍微有空一點的時候才有辦法來處理 重構是必經的路程，適時的重構可以讓心情愉悅，不用鬱悶的寫到吐血","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"React","slug":"Frontend/React","permalink":"http://jiaming0708.github.io/categories/Frontend/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://jiaming0708.github.io/tags/React/"}]},{"title":"[JS] date自定義格式","slug":"js-date-parse-regex","date":"2019-03-03T02:35:15.000Z","updated":"2023-03-09T14:18:38.675Z","comments":true,"path":"2019/03/03/js-date-parse-regex/","link":"","permalink":"http://jiaming0708.github.io/2019/03/03/js-date-parse-regex/","excerpt":"前幾天收到QA開的一個bug，是關於日期時間顯示的錯誤，因為開發習慣都是以chrome為主，所以沒特別發現問題，結果QA是在firefox使用而發現的bug，經過追查以後才發現是字串轉成日期格式有問題","text":"前幾天收到QA開的一個bug，是關於日期時間顯示的錯誤，因為開發習慣都是以chrome為主，所以沒特別發現問題，結果QA是在firefox使用而發現的bug，經過追查以後才發現是字串轉成日期格式有問題 日期格式從後端來的資料格式是2019-03-03 10:35:15 +0800，如果用chrome可以正確的解析出來，但如果是用firefox、safari則會出現NaN代表著轉換失敗，遇到這種狀況就是先去查一下文件，確認標準格式是什麼，並且測試看看怎樣的轉換是可以work的 根據MDN文件表示，支援三種ISO格式 這邊不使用GTM，是因為資料格式差異比較大，轉換上更麻煩 只有日期2011-10-10 日期加時間2011-10-10T14:48:00 毫秒加時區2011-10-10T14:48:00.000+09:00 從這邊可以知道後端回來的格式跟標準還是有所差異，但因為這個改動會影響到app端，因此就只好web這邊自己改掉，解決的方法很簡單，就是給所謂的自訂格式 自訂格式如果你有寫過其他語言，可能都會有提供這樣的方法new Date(&quot;2011-10-10 14:48:00&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;)，但是在js中並沒有提供，因此你就必須要自己拆解字串去做到這樣的事情 拆解字串的作法很多種，這邊提供兩種比較常見的 字串拆解固定格式這種的最簡單就是直接拆解字串硬解 123456const dateString = &#x27;2019-03-03 10:35:15 +0800&#x27;;const date = dateString.substring(0, 10);const time = dateString.substring(11, 19);const zoneHour = dateString.substring(20, 23);const zoneMin = dateString.substring(23);const result = new Date(`$&#123;date&#125;T$&#123;time&#125;$&#123;zoneHour&#125;:$&#123;zoneMin&#125;`); 使用regex另外一種作法，就是moment或是luxon的作法，用regex來解析，但在專案中還是有點寫死，不太像是他們是用定義的比較活一點 1234const dateString = &#x27;2019-03-03 10:35:15 +0800&#x27;;const dateFormat = /^(\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;) (\\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;) (\\+\\d&#123;2&#125;)(\\d&#123;2&#125;)$/;const matchs = dateString.match(dateFormat);const result = new Date(`$&#123;matchs[1]&#125;T$&#123;matchs[2]&#125;$&#123;matchs[3]&#125;:$&#123;matchs[4]&#125;`); 結論這個問題的最佳解會是從backend傳回來的資料格式就應該是iso，就不用這麼麻煩的做這些workaround。也許會問為什麼不直接把luxon引入使用就好，雖然luxon已經比moment還要小，但還是相對用到的功能來說是相對肥阿，不如參考別人的作法，在自己專案中實作比較好 參考luxon repo","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"JavaScript","slug":"Frontend/JavaScript","permalink":"http://jiaming0708.github.io/categories/Frontend/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiaming0708.github.io/tags/JavaScript/"},{"name":"regex","slug":"regex","permalink":"http://jiaming0708.github.io/tags/regex/"}]},{"title":"rx用expand達成recursive","slug":"rx-expand","date":"2019-02-25T14:06:16.000Z","updated":"2023-03-09T14:18:38.675Z","comments":true,"path":"2019/02/25/rx-expand/","link":"","permalink":"http://jiaming0708.github.io/2019/02/25/rx-expand/","excerpt":"昨天看了一部影片，是由大神Ben介紹expand的功能 這篇是跟著實作並且去理解使用，將透過pagination的應用來做介紹，每頁10筆，假設不確定會有幾頁，要全部都拿回來的話可以怎麼實作","text":"昨天看了一部影片，是由大神Ben介紹expand的功能 這篇是跟著實作並且去理解使用，將透過pagination的應用來做介紹，每頁10筆，假設不確定會有幾頁，要全部都拿回來的話可以怎麼實作 模擬API資料首先我們要先有模擬api的功能，因此我們寫一段rx並帶上500的timer作為示意，這邊就固定只給到10頁 12345678910111213const getPagedData = index =&gt; timer(500).pipe( map(()=&gt;(&#123; pageIndex: index, data: Array.from(&#123; length: 10 &#125;, (_, i)=&gt;(&#123; id: (index * 10) + i, data: Math.random(), &#125;)), nextPageIndex: index &lt; 10 ? index + 1: undefined, &#125;)),);const source = getPagedData(0);source.subscribe(p=&gt;console.log(p)); 執行後可以看到這樣的資料，那初期的準備就完成了 12345&#123; data: Array[10], nextPageIndex: 1, pageIndex: 0&#125; recursive實作如果用原本熟悉的那些operator下去做，會怎麼實作呢？這時候我會使用subject來達到這個目的 1234567891011121314const nextPage$ = new Subject();nextPage$.pipe( concatMap(index =&gt; getPagedData(index))).subscribe(p=&gt;&#123; const &#123;nextPageIndex&#125; = p; if(nextPageIndex !== undefined)&#123; nextPage$.next(nextpageIndex); &#125; console.log(p);&#125;);nextPage$.next(0); 其實subscribe的那段判斷，可以拉上去變成用tap來做 1234const source = nextPage$.pipe( concatMap(index =&gt; getPagedData(index)), tap(&#123;nextPageIndex&#125; =&gt; nextPageIndex !== undefined &amp;&amp; nextPage$.next(nextpageIndex))); 重構改用expand但rx有提供更好的寫法，就是expand先來看看官方的說法 Recursively projects each source value to an Observable which is merged in the output Observable. 這非常類似於mergeMap但在條件完成前就是不斷的呼叫同一個方法，直到呼叫EMPTY為止，那就來試著改寫上面的那段程式 1expand(&#123;nextPageIndex&#125; =&gt; nextPageIndex !== undefined ? getPagedData(nextPageIndex) : EMPTY) 哇賽，整個變得好簡潔呢，但是來源資料要怎麼給呢？因為我們改成用expand，因此資料要符合他的格式，才能讓他遞迴下去，因此就改成用這樣的寫法 123const source = of(&#123;nextPageIndex: 0&#125;).pipe( expand(&#123;nextPageIndex&#125; =&gt; nextPageIndex !== undefined ? getPagedData(nextPageIndex) : EMPTY)); 結論雖然這個應用場景我還沒遇到，但能多學到一個operator是還蠻不錯的，畢竟rx所提供的operator還蠻多的，而且只看範例完全無法想像那個應用情境，剛好有大神開示，試著自己玩玩看還不錯！ 完整的程式碼可以到這邊來看！ 參考https://rxjs.dev/api/operators/expand","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"RxJS","slug":"Frontend/RxJS","permalink":"http://jiaming0708.github.io/categories/Frontend/RxJS/"}],"tags":[{"name":"RxJS","slug":"RxJS","permalink":"http://jiaming0708.github.io/tags/RxJS/"}]},{"title":"[GTM] pageview加上content group","slug":"gtm-content-group","date":"2019-02-19T04:22:02.000Z","updated":"2023-03-09T14:18:38.675Z","comments":true,"path":"2019/02/19/gtm-content-group/","link":"","permalink":"http://jiaming0708.github.io/2019/02/19/gtm-content-group/","excerpt":"最近有一個需求是在特定頁面要加上content group的資料，很多的功能用GA都還蠻簡單，但是用了GTM就會變得比較複雜一點，今天來分享一下用GTM怎麼完成這個需求","text":"最近有一個需求是在特定頁面要加上content group的資料，很多的功能用GA都還蠻簡單，但是用了GTM就會變得比較複雜一點，今天來分享一下用GTM怎麼完成這個需求 #設定GA 最一開始當然就是要先把GA設定起來，這樣後續才有辦法做測試並且確認資料是否正確，首先contnet group是設定在view底下而不是property，所以要先到admin中找到Content Grouping的設定 接著點擊新增然後輸入Name和index，在規劃的時候也要注意一下content group只能有五組 這邊要注意新增後只能停用不能刪除 有注意到圖的最下面，有給一些範例要怎麼去寫入這個資料，但這個對於我們要搭配GTM的來說，其實是沒什麼幫助的，因此可以忽略不看 設定GTMData Layer VariableGTM有一個功能叫做Data Layer Variable，這個可以接收從web打上來的一些資料，但缺點是資料會一直保留到清除為止，因此除了DL以外還要設定一個Custom Function DL-TYPE(Data Layer Variable)名稱就給他TYPE，在程式我們只要給對應的名稱GTM就會對應到 Get TYPE寫一個判斷式，當網址不是指定頁面(post)的時候要給其他值，避免掉資料殘留的問題，因為網站本身架構比較單純主要分兩個頁面，HOME、POST，所以只要簡單判斷並且給一個定值就好 123456789function()&#123; var val = &#123;&#123;DL-TYPE&#125;&#125;; var path = &#123;&#123;Page Path&#125;&#125;; if(!/(\\/post\\/)/.test(path))&#123; val = &#x27;HOME&#x27;; &#125; return val;&#125; GA Setting接著就可以在Google Analytics Settings加上content group的設定，打開More Setting找到Content Groups新增一個index是1，值從Get TYPE這個function取得 Send Data Layerpush data layerTYPE的資料是componentDidMount的時候透過API拿回來，因此我們可以在這邊再打出Data Layer資料 123window.dataLayer.push(&#123; &#x27;TYPE&#x27;: &#x27;VIDEO&#x27;,&#125;); 寫完使用preview的功能看一下有沒有資料，慘～怎麼都沒拿到，再仔細思考一下整個流程 home -&gt; (page view) -&gt; post -&gt; (send data layer) 從首頁到post頁面的時候，就已經會先打一個history，然後在GTM會發一個page view出去，然後post頁面會等到api回來的時候才打datalayer，這時候GTM已經把資料送出去根本不會包含datalayer event取代history上面的狀況導致我們不能直接在history change就送page view，因此要改一下時機點，變成是由程式自己發一個事件，這時候在triggers新增一個Custom Event 當然也要過濾掉原本的history設定，從All History Changes改成Some History Changes，並且設定path不包含 /post/ 整個設定完以後，程式也在componentDidMount發送event，就可以用preview看看結果是不是如預期！ 結論這個功能其實很簡單，官方也有說明怎麼設定，但因為時間點的問題，導致要多做一些動作，才能達到原本的預期，如果說你只是一個url的值當做content group，就完全可以忽略上面所講的這些","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"GTM","slug":"Frontend/GTM","permalink":"http://jiaming0708.github.io/categories/Frontend/GTM/"}],"tags":[{"name":"GTM","slug":"GTM","permalink":"http://jiaming0708.github.io/tags/GTM/"}]},{"title":"quokka搭配webpack設定","slug":"quokka-webpack","date":"2019-02-15T14:44:03.000Z","updated":"2023-03-09T14:18:38.675Z","comments":true,"path":"2019/02/15/quokka-webpack/","link":"","permalink":"http://jiaming0708.github.io/2019/02/15/quokka-webpack/","excerpt":"quokka是一個測試工具，支援蠻多的編輯器，可以直接即時的就看到結果，所以大部分都是開發或是測試的時候可以拿出來使用 在使用webpack作為打包編譯的工具的時候，有一些設定會讓quokka看不懂，這邊就來介紹一下怎麼設定","text":"quokka是一個測試工具，支援蠻多的編輯器，可以直接即時的就看到結果，所以大部分都是開發或是測試的時候可以拿出來使用 在使用webpack作為打包編譯的工具的時候，有一些設定會讓quokka看不懂，這邊就來介紹一下怎麼設定 alias在專案中通常會加上alias的設定，這樣可以讓import比較乾淨，大概會像是這樣設定 12345678910module.exports = () =&gt; &#123; return &#123; //... resolve: &#123; alias: &#123; &#x27;@app&#x27;: resolve(__dirname, &#x27;./app&#x27;) &#125; &#125;, &#125;;&#125; 那在程式中通常會這樣寫 1import api from &#x27;@app/services/api&#x27;; 但是這個時候使用quokka會告訴你找不到這個module，根據官方的文件可以透過設定.quokka的檔案(json format)，來讓工具看的懂 without babelalias有兩種方法，一個是有babel，當然另一種就是沒有，這兩個都有寫好的套件可以使用首先介紹一下沒有babel的情況下要使用alias-quokka-plugin 1yarn add --save --dev alias-quokka-plugin 再來就是把.quokka的檔案產生好 123456&#123; &quot;plugins&quot;: [&quot;alias-quokka-plugin&quot;], &quot;alias&quot;: &#123; &quot;@app&quot;: &quot;./app&quot;, &#125;&#125; 設定完以後就不用怕啦，開始使用在程式裡面吧 1const api = require(&#x27;@app/services/api&#x27;); with babel有使用babel的話，我們要安裝另一個套件babel-alias-quokka-plugin 1yarn add --save --dev babel-alias-quokka-plugin 改一下.quokka檔案的內容 123456789&#123; &quot;babel&quot;: true, &quot;plugins&quot;: [ &quot;babel-alias-quokka-plugin&quot; ], &quot;alias&quot;:&#123; &quot;@app&quot;:&quot;./app&quot; &#125; &#125; 可以看到這邊主要多了一個設定叫做babel，那預設會載入.babelrc並且env是test，當然你也可以特別指定env之類的，但我是全部都交給babelrc就好，.quokka只做最基本的設定 global variable很開心的設定完上面的步驟，一按下去執行，🤬又有錯誤，這次是**__CLIENT__**找不到，突然想到在webpack中有定義了一些屬於全域型的變數 1234// in webpack.config.jsnew webpack.DefinePlugin(&#123; __CLIENT: true,&#125;); 自定plugin這時候我們就要採用自訂plugin的方式，宣告一個變數讓quokka看懂，這時候就先產生一個quokkaPlugin.js的檔案 1global.__CLIENT__ = true; 在.quokka的設定中，把這個檔案當做plugin放進去 12345678910&#123; &quot;babel&quot;: true, &quot;plugins&quot;: [ &quot;./quokkaPlugin.js&quot;, &quot;babel-alias-quokka-plugin&quot; ], &quot;alias&quot;:&#123; &quot;@app&quot;:&quot;./app&quot; &#125; &#125; 結論終於設定完畢，可以正常的使用quokka這個工具，如果你的import很多的話，可能會使用到Pro的版本，可以先看一下官方的差異介紹，試用後再決定要不要買 如果你是有套用完整的測試框架像是jest或是protractor，就要改使用wallaby，絕對可以讓你享受到TDD的紅綠燈開發方式 再設定上面如果有一些問題的話可以去參考官方的repo，裡面有非常多種的範例","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Testing","slug":"Frontend/Testing","permalink":"http://jiaming0708.github.io/categories/Frontend/Testing/"}],"tags":[{"name":"Testing","slug":"Testing","permalink":"http://jiaming0708.github.io/tags/Testing/"},{"name":"Quokka","slug":"Quokka","permalink":"http://jiaming0708.github.io/tags/Quokka/"}]},{"title":"[crop系列] 5 完整實作","slug":"crop","date":"2019-01-09T13:43:55.000Z","updated":"2023-03-09T14:18:38.663Z","comments":true,"path":"2019/01/09/crop/","link":"","permalink":"http://jiaming0708.github.io/2019/01/09/crop/","excerpt":"系列文終於要來到最終章，前面的每一個都是重要的元素，但要怎麼整合起來會在這篇完整的交代","text":"系列文終於要來到最終章，前面的每一個都是重要的元素，但要怎麼整合起來會在這篇完整的交代 如果還沒看過系列其他篇的麻煩這邊請 [crop系列] 1 scale和position的糾葛、[crop系列] 2 canvas drawimage應用、[crop系列] 3 圖片mask、[crop系列] 4 drag實作 使用react作為範例 準備畫面既然這是最終章，當然就是要把畫面什麼的都準備好啦，這邊就直接來把html、css準備好畫面的功能是這樣，一開始進去要先上傳圖片，然後接著可以開始放大&#x2F;縮小&#x2F;移動，最後按下確定，把區域內的畫面顯示出來 html123456789101112131415161718192021222324252627282930313233&lt;div&gt; &lt;input class=&quot;file-input&quot; type=&quot;file&quot; accept=&#x27;image/*&#x27; /&gt; &lt;div class=&quot;crop-root&quot;&gt; &lt;div class=&quot;photo-block&quot;&gt; &lt;div class=&quot;photo-mask&quot;&gt; &lt;img draggable=&quot;false&quot; /&gt; &lt;/div&gt; &lt;img draggable=&quot;false&quot; /&gt; &lt;div class=&quot;zoom-block&quot;&gt; &lt;div class=&quot;zoom-out&quot; /&gt; &lt;input class=&quot;slide&quot; type=&quot;range&quot; min=&quot;1&quot; max=&quot;1.5&quot; step=&quot;0.01&quot; /&gt; &lt;div class=&quot;zoom-in&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-block&quot;&gt; &lt;button&gt; cut &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 最後顯示用 --&gt; &lt;img /&gt;&lt;/div&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384.crop-root&#123; border: 1px solid #808080; position: relative;&#125;.photo-block&#123; height: 440px; max-width: 500px; position: relative; overflow: hidden; img&#123; display: block; position: absolute; object-fit: contain; max-width: 100%; &#125; &amp; &gt; img&#123; background: #ffffff; opacity: 0.6; &#125;&#125;.photo-mask&#123; width: 100%; height: 100%; position: absolute; left: 0; right: 0; top: 0; bottom: 0; clip-path: circle(125px at center 180px);&#125;.zoom-block&#123; display: flex; position: absolute; bottom: 0; padding: 18px 0; width: 100%; background-color: white; justify-content: center;&#125;%zoomIconLine&#123; content: &#x27;&#x27;; display: block; height: 2px; width: 0.75rem; border-radius: 1px; background-color: #808080; position: absolute; top: calc(50% - 1px);&#125;%zoomIcon&#123; width: 1rem; height: 1rem; display: flex; justify-content: center; cursor: pointer;&#125;.zoom-out&#123; @extend %zoomIcon; &amp;:before&#123; @extend %zoomIconLine; &#125;&#125;.zoom-in&#123; @extend %zoomIcon; &amp;:before&#123; @extend %zoomIconLine; transform: rotate(-90deg); &#125; &amp;:after&#123; @extend %zoomIconLine; &#125;&#125; scale和drag結合scale計算前面用了兩篇各自的講到scale和drag，但是這兩個結合在一起以後計算的方式一定會有所不一樣，現在我們要把這塊完成 12345678const parent = this.dragNode.parentNode;const maxLeft = parent.offsetWidth - this.dragNode.offsetWidth;const maxTop = parent.offsetHeight - this.dragNode.offsetHeight;point = &#123; left: this.validValue(point.left, 0, maxLeft), top: this.validValue(point.top, 0, maxTop),&#125;; 上面是前一篇所用的方法，如果不管邊界值，我們只要把this.dragNode的offsetWidth乘上scale值就可以 123const parent = this.dragNode.parentNode;const maxLeft = parent.offsetWidth - (this.dragNode.offsetWidth * zoomValue);const maxTop = parent.offsetHeight - (this.dragNode.offsetHeight * zoomValue); 接下來我們要把邊界的條件拉近來，並且邊界從四周改成中間的圓，也就是圖片不能超過圓形的範圍，因此計算的方式要重新來 圓為邊界前面我們所用到的邊界取值的方式還記得嗎，使用目前值和最大最小做計算。用圓當做邊界也是一樣，我們要拿到圓的上下左右四個值，而不能偷懶直接用0當做最小值，這邊先來個暖身沒有任何scale的問題要帶入 我們只要拿一邊來做計算，因此思考的方式要調整一下，先來看一下操作模式 當圖左邊拉到圓的左邊時就要停止，而反邊的話是左邊拉到圓的右邊減去寬度，因此我們可以用這兩個值當做最大和最小 123456789101112131415161718192021222324const circle = &#123; radius: 125, offsetY: 54,&#125;;// 取得圓在drag區域的offsetconst photoRect = this.dragNode.parentNode.getBoundingClientRect();let circleNode = &#123; left: (photoRect.width / 2) - circle.radius, top: circle.offsetY,&#125;;circleNode = &#123; ...circleNode, right: circleNode.left + (circle.radius * 2), bottom: circleNode.top + (circle.radius * 2),&#125;;// 以上的計算只需要一次，所以可以放在 componentDidMountconst minLeft = circleNode.right - this.dragNode.offsetWidth;const minHeight = circleNode.bottom - this.dragNode.offsetHeight;point = &#123; left: this.validValue(point.left, minLeft, circleNode.left), top: this.validValue(point.top, minHeight, circleNode.top),&#125;; 乎～第一版搞定，那接著就要把scale的變數加進來！ 12345const &#123; offsetWidth, offsetHeight &#125; = this.dragNode;let minLeft = this.circleNode.right - (offsetWidth * zoomValue);let minTop = this.circleNode.bottom - (offsetHeight * zoomValue);let maxLeft = this.circleNode.left;let maxTop = this.circleNode.top; 但這裡有個問題是，圖放大了，但是我們的座標本身是沒有放大，因此在做max、min的比較時，不能用放大後的值來運算，應該要換算回正確的值 123456789if (zoomValue &gt; 1) &#123; minLeft = this.calOriginPosition(offsetWidth, minLeft, zoomValue); minTop = this.calOriginPosition(offsetHeight, minTop, zoomValue); maxLeft = this.calOriginPosition(offsetWidth, maxLeft, zoomValue); maxTop = this.calOriginPosition(offsetHeight, maxTop, zoomValue);&#125;const calOriginPosition = (originLength, value, zoomValue) =&gt; value + ((zoomValue - 1) * originLength / 2); mobile放大-pinch前面一篇有提到在mobile上的touch是一個陣列，為了可以記錄多點觸控時的位置，在mobile上scale有個名詞叫做**pinch**，可以看一下這張圖上面有各種在mobile上的操作行為 這邊跟drag只有一個地方要調整，就是一定要觸控兩個點，接著變更zoomValue即可 1filter(event =&gt; event.touches.length === 2) 輸出drag和scale都處理完以後就只剩下最後的輸出，在專案中為了上傳方便，因此使用的是blob來放檔案，當然你也能夠不要轉直接用base64做顯示，因為已經轉成blob，因此我們需要用URL.createObjectURL的方法去轉換成瀏覽器內部的連結 123456afterCutBlob = blob =&gt;&#123; const url = URL.createObjectURL(blob); this.setState(&#123; cutBlob: url, &#125;)&#125; 不要忘記離開前釋放一下記憶體，可以參考一下這篇MDN，在這篇中我就沒有寫上去 小應用這是一個在專案上用到的情境，designer跟我說希望一開始進去的時後，如果高比寬長，那就將寬設為圓的直徑，高等比比縮放，然後位置是在圓的左上角 這個需求其實很簡單，在image加上onLoad的事件，寫個判斷式，然後再把left和top重新計算取得正確的位置，就可以打完收工啦 1234567891011121314151617181920212223242526272829303132 loadedImage = () =&gt; &#123; const &#123; naturalHeight, naturalWidth, &#125; = this.image; const stateName = naturalHeight &gt; naturalWidth ? &#x27;width&#x27; : &#x27;height&#x27;; const diameter = circle.radius * 2; this.image[stateName] = diameter; this.setState(&#123; [stateName]: diameter, &#125;); const &#123; left, top, zoomValue, &#125; = this.state; this.calMovedPosition(&#123; left, top, &#125;, zoomValue); &#125;/*&lt;img src=&#123;imageBlob&#125; style=&#123;imageStyle&#125; draggable=&quot;false&quot; ref=&#123;node =&gt; &#123; this.image = node; &#125;&#125; onLoad=&#123;this.loadedImage&#125;/&gt;*/ 結論到這邊，整個功能已經算是介紹的差不多，剩下的就是把前面所講過的程式碼拼湊起來，需要的話請到這邊看demo 在這邊我用的是兩個image搭配出來的效果，但其實也有另一個作法是用canvas直接畫，如果有需要的話可以研究一下怎麼做，但我想作法應該是不會差太多 在這整個系列中，最麻煩的一定就是跟scale扯上關係，一有關係以後整個計算就變得麻煩，不斷的在做轉換的動作，其實這功能不難，只是在於一些小細節上要注意，踩過了就知道XD 範例中的Crop這個component沒寫的很好，做太多事情，如果有什麼好的建議歡迎告訴我喔🥂","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"React","slug":"Frontend/React","permalink":"http://jiaming0708.github.io/categories/Frontend/React/"}],"tags":[{"name":"crop","slug":"crop","permalink":"http://jiaming0708.github.io/tags/crop/"},{"name":"React","slug":"React","permalink":"http://jiaming0708.github.io/tags/React/"}]},{"title":"[crop系列] 4 drag實作","slug":"crop-drag","date":"2019-01-08T14:37:11.000Z","updated":"2023-03-09T14:18:38.663Z","comments":true,"path":"2019/01/08/crop-drag/","link":"","permalink":"http://jiaming0708.github.io/2019/01/08/crop-drag/","excerpt":"crop系列之第n篇，這篇要來說怎麼用rxjs來實作drag並且要支援手機的touch行為","text":"crop系列之第n篇，這篇要來說怎麼用rxjs來實作drag並且要支援手機的touch行為 如果還沒看過系列其他篇的麻煩這邊請 [crop系列] 1 scale和position的糾葛、[crop系列] 2 canvas drawimage應用、[crop系列] 3 圖片mask 所有的範例都會是以react為主，angular版本改天再出 mouseDrag的操作行為分為desktop和mobile兩種，在desktop上面大家都很清楚就是用mouse，但是在mobile上面則用touch，基本上兩個的概念是差不多，只是差在事件上面的不同，那就讓我們先用mouse的event來做 event參數首先要先了解drag的行為模式，點在一個物件上(down)，然後移動(move)，最後放開(up)，那物件要根據移動的位移量來跟著移動，所以要計算位移量的話就會是跟x, y軸有關係，因此我們先來看看MDN有哪些參數可以使用 clientX、clientYReturns the coordinate of the mouse pointer, relative to the current window, when the mouse event was triggered movementX、movementYReturns the coordinate of the mouse pointer relative to the position of the last mousemove event offsetX、offsetYReturns the coordinate of the mouse pointer relative to the position of the edge of the target element pageX、pageYReturns the coordinate of the mouse pointer, relative to the document, when the mouse event was triggered screenX、screenYReturns the coordinate of the mouse pointer, relative to the screen, when an event was triggered 上面這些講的很漏漏等，還是用一張圖來呈現比較明確 圖片來源 看完圖片有沒有比較清楚知道每一個的用途，那最好用的應該會是movement這個參數，但這個不支援部分瀏覽器，所以我們要改用其他的參數，而其中client這個會比offset還要好，等一下我們來實作看看兩個的差異 非rx實作那我們先來用傳統的addEventListener來實作看看，首先我們用一個component叫做dragable，裡面只有一個div作為可以被拖拉的element，那我們第一步就是註冊各個事件 當然不要忘記在componentWillUnMount取消註冊 12345componentDidMount () &#123; this.dragNode.addEventListener(&#x27;mousedown&#x27;, this.mouseDown); this.dragNode.addEventListener(&#x27;mouseup&#x27;, this.mouseUp); this.dragNode.addEventListener(&#x27;mousemove&#x27;, this.mouseMove);&#125; mouseDown透過全域變數來記當下的座標以及開始拖拉 123456789mouseDown = event =&gt; &#123; this.setState(&#123; isDrag: true, lastPoint: &#123; left: event.clientX, top: event.clientY, &#125;, &#125;);&#125; mouseUp取消拖拉狀態 12345mouseUp = event =&gt; &#123; this.setState(&#123; isDrag: false, &#125;);&#125; mouseMove將目前所在位置 減掉 前一次移動的值 再加上 目前element所在位置，最後將計算的結果寫入到element 12345678910111213141516171819202122mouseMove = event =&gt; &#123; const &#123; isDrag, top, left, lastPoint, &#125; = this.state; if(!isDrag)&#123; return; &#125; const newLeft = event.offsetX - lastPoint.left + left; const newTop = event.offsetY - lastPoint.top + top; this.setState(&#123; left: newLeft, top: newTop, lastPoint: &#123; left: event.offsetX, top: event.offsetY, &#125; &#125;);&#125; 寫完以上的程式實際操作一下，發現會有點卡卡的，尤其是滑鼠會跑超過drag的框，但又希望dragable的物件能跟著走，因此在監聽的地方要改一下，mouseup、mousemove要改成document的全域監聽 12345componentDidMount () &#123; this.dragNode.addEventListener(&#x27;mousedown&#x27;, this.mouseDown); document.addEventListener(&#x27;mouseup&#x27;, this.mouseUp); document.addEventListener(&#x27;mousemove&#x27;, this.mouseMove);&#125; 這樣改完再跑一次，發現還是跑的不順，這時候我們改用client來取代offset，再跑一次會發現整個順暢了，非常完美！完整的範例如下 ## rx版本實作 那接著我們就要來使用rx的方法實作同樣的功能，首先一樣先定義事件 12345componentDidMount()&#123; const down$ = fromEvent(this.dragNode, &#x27;mousedown&#x27;); const up$ = fromEvent(document, &#x27;mouseup&#x27;); const move$ = fromEvent(document, &#x27;mousemove&#x27;);&#125; 事件組合接著要來開始把這些事件組合，首先我們是透過mousedown作為起點，然後mousemove接著再mouseup的時候結束 12345678910componentDidMount()&#123; const down$ = fromEvent(this.dragNode, &#x27;mousedown&#x27;); const up$ = fromEvent(document, &#x27;mouseup&#x27;); const move$ = fromEvent(document, &#x27;mousemove&#x27;); down$.pipe( mergeMap(down =&gt; move$.pipe( )), takeUntil(up$), );&#125; 這時候將up$的事件當做結束，但是這樣會有一個問題，因為takeUntil是有值進來的時候會觸發complete，因此只要mouseup過一次以後這個流程就結束了 但期望的應該是每次mousedown的時候都要能夠被觸發，因此我們應該要將takeUntil(up$)放在move$的身上，讓流程只斷移動，而不會影響到down$ 12345678910componentDidMount()&#123; const down$ = fromEvent(this.dragNode, &#x27;mousedown&#x27;); const up$ = fromEvent(document, &#x27;mouseup&#x27;); const move$ = fromEvent(document, &#x27;mousemove&#x27;); down$.pipe( mergeMap(down =&gt; move$.pipe( takeUntil(up$), )), );&#125; 計算位移事件的流程搞定以後就可以開始的來針對位移量做計算，概念會跟前面有點類似，但又會有點不同，直接來說說不同的點，不是每次的偏移量，而是這次位置和初始位置的偏移量 12345678910111213141516171819down$.pipe( mergeMap(down =&gt; move$.pipe( takeUntil(up$), map(move =&gt; (&#123; deltaX: down.clientX - move.clientX, deltaY: down.clientY - move.clientY, &#125;)), )),).subscribe(point =&gt; &#123; const &#123; left, top, &#125; = this.state; this.setState(&#123; left: point.deltaX + left, top: point.deltaY + top, &#125;);&#125;); 很開心的寫完執行，發現怎麼跑的飛快，原因是delta的量是重新計算後跟一開始的偏移量，但我們卻拿最新的位置做計算，那當然會跑的飛快，這邊要微調一下，從down$的時候要就拿到state的資料 123456789101112131415161718192021down$.pipe( mergeMap(down =&gt; of(this.state).pipe( map(state =&gt; (&#123; down, state, &#125;)), )), mergeMap((&#123;down, state&#125;) =&gt; move$.pipe( takeUntil(up$), map(move =&gt; (&#123; deltaX: move.clientX - down.clientX, deltaY: move.clientY - down.clientY, &#125;)), map(delta =&gt; (&#123; left: delta.deltaX + state.left, top: delta.deltaY + state.top, &#125;)), ))).subscribe(point=&gt;&#123; this.setState(point);&#125;); 在執行看看，跟前面的效果是一樣，完美！完整範例如下 # touch 做完滑鼠的接著當然就是要處理mobile上面的行為，跟mouse的差不多主要都是由touch的事件做處理，一樣先來了解MDN的參數內容 event參數 touches targetTouches changedTouches 在mobile有多點觸控的功能，所以會是一個陣列，所以在寫的時候必須要注意一下目前的觸控數有多少，那在上面的兩個屬性中，有的參數其實跟mouse一樣 screen client page 實作了解完參數以後就可以開始動工啦，這邊我就不用傳統的寫法而是直接採用rx 1234567891011componentDidMount()&#123; const start$ = fromEvent(this.dragNode, &#x27;touchstart&#x27;); const end$ = fromEvent(document, &#x27;touchend&#x27;); const move$ = fromEvent(document, &#x27;touchmove&#x27;); start$.pipe( filter(event =&gt; event.touches.length === 1), mergeMap(start =&gt; move$.pipe( takeUntil(end$), )), );&#125; 這邊有兩個地方要注意一下 要記得filter個數，不然會發生跟預期不一樣的行為 這邊的邏輯好像跟上面mouse的差不多 重構1234567891011121314151617181920componentDidMount()&#123; const start$ = fromEvent(this.dragNode, &#x27;touchstart&#x27;).pipe(this.parseTouchEvent); const end$ = fromEvent(document, &#x27;touchend&#x27;); const move$ = fromEvent(document, &#x27;touchmove&#x27;).pipe(this.parseTouchEvent); start$.pipe( filter(event =&gt; event.touches.length === 1), mergeMap(start =&gt; move$.pipe( takeUntil(end$), )), );&#125;parseTouchEvent = obs =&gt; obs.pipe( tap(event =&gt; event.preventDefault()), filter(event =&gt; event.touches.length === 1), map(event =&gt; (&#123; x: event.touches[0].clientX, y: event.touches[0].clientY, &#125;)),); 因為已經過濾掉只有一個觸控點的情況下會往後，因此直接拿陣列的第一個物件中client資料來使用，這樣在後面的資料都統一用&#123;x, y&#125;的物件做處理 記得要加上*preventDefault*，但千萬記得不要加在end上面，會死的不明不白… 結合touch、mouse前面有看到兩個的相似之處，而且在touch的時候我們也針對資料做了處理，接著就是要把這兩段的程式做結合，主要要進行串接的有兩個地方 資料的處理將mouse的事件也加上前置處理 1234567parseMouseEvent = obs =&gt; obs.pipe( tap(event =&gt; event.preventDefault()), map(event =&gt; (&#123; x: event.clientX, y: event.clientY, &#125;)),); 事件對事件的串接先把move加上end/up的結束處理，再來就是兩個相同類型的事件做merge 1234567891011121314151617const start$ = fromEvent(this.dragNode, &#x27;touchstart&#x27;).pipe(this.parseTouchEvent);const end$ = fromEvent(document, &#x27;touchend&#x27;);const touchMove$ = fromEvent(document, &#x27;touchmove&#x27;).pipe( this.parseTouchEvent, takeUntil(end$),);const down$ = fromEvent(this.dragNode, &#x27;mousedown&#x27;).pipe( this.parseMouseEvent, merge(start$),);const up$ = fromEvent(document, &#x27;mouseup&#x27;);const move$ = fromEvent(document, &#x27;mousemove&#x27;).pipe( this.parseMouseEvent, takeUntil(up$), merge(touchMove$),); 最後就是針對新的物件把邏輯做個微調 12345678910111213141516171819down$.pipe( takeUntil(this.destory$), mergeMap(down =&gt; of(this.state).pipe( map(state =&gt; (&#123; down, state, &#125;)), )), mergeMap((&#123;down, state&#125;) =&gt; move$.pipe( map(move =&gt; (&#123; deltaX: move.x - down.x, deltaY: move.y - down.y, &#125;)), map(delta =&gt; (&#123; left: delta.deltaX + state.left, top: delta.deltaY + state.top, &#125;)), ))) 物件只能在區域內最後來點進階的，要把dragable的物件限制在一個區域內，也就是左上、左下、右上、右下 但是要判斷四個資料寫起來也很煩，漏漏等，因此換個角度思考看看，如過只判斷一邊在一個範圍值之內是不是就可以，例如左邊只能在0100，上面只能在0200 首先一定要取出外框以及dragable的width、height，接著就要把外框的width、height扣掉dragable的width、height，這樣就能知道物件不超出的最大值是多少 123const parent = this.dragNode.parent;const maxLeft = parent.offsetWidth - this.dragNode.offsetWidth;const maxTop = parent.offsetHeight = this.dragNode.offsetHeight; 接著就是要來判斷最大最小值，然後這邊用個公式目前值和最小值的較大者，然後再和最大值取較小者 1validValue = (value, min, max) =&gt; Math.min(Math.max(value, min), max) 最後直接來看一下完整的程式 # 結論 先說一下，原本打算這篇就要給他全部結束，但後來發現很難，因為太多程式碼要交代 Rx真的是我們的好朋友，尤其是在這種情況下使用，你可以發現很多邏輯都可以被抽出去，而且可以合併來合併去，我們就只要關注真正的邏輯面就好（要算算看我總共用了哪些operator嗎？其實答案就在程式的最上面，有沒有覺得使用的類型不多） 下一篇就會是更進階的zoom，會搭配上比較多的計算，希望下篇能夠完結！ 參考 touch event mouse event","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"React","slug":"Frontend/React","permalink":"http://jiaming0708.github.io/categories/Frontend/React/"}],"tags":[{"name":"RxJS","slug":"RxJS","permalink":"http://jiaming0708.github.io/tags/RxJS/"},{"name":"crop","slug":"crop","permalink":"http://jiaming0708.github.io/tags/crop/"},{"name":"React","slug":"React","permalink":"http://jiaming0708.github.io/tags/React/"}]},{"title":"[crop系列] 3 圖片mask","slug":"css-mask","date":"2018-12-25T12:26:43.000Z","updated":"2023-03-09T14:18:38.659Z","comments":true,"path":"2018/12/25/css-mask/","link":"","permalink":"http://jiaming0708.github.io/2018/12/25/css-mask/","excerpt":"crop系列文之3，今天要來說一下怎麼用css的方式做一個四周有遮罩中間一個50*50的圓是亮的功能","text":"crop系列文之3，今天要來說一下怎麼用css的方式做一個四周有遮罩中間一個50*50的圓是亮的功能 還沒看前面兩篇嗎？趕快來這邊看[crop系列] 1 scale和position的糾葛、[crop系列] 2 canvas drawimage應用 目標 這是我們要達成的目標，一開始看到的時候覺得很簡單，不就是一張圖，然後給他一個寬高跟圖相同的div然後background是有顏色且透明，再來就是… ㄟ都，再來…怎麼再來阿，都已經被蓋上background了，怎麼中間挖洞給他QQ 思路 background的區域繞過中間的圓 - 完全沒想法怎麼做（如果你知道請告訴我&lt;(_ _)&gt;） 用第二張圖來顯示中間的圓 這個方法比較好理解，那我們來嘗試一下看看 1234&lt;div class=&quot;imageBlock&quot;&gt; &lt;img src=&quot;https://mdn.mozillademos.org/files/5397/rhino.jpg&quot; style=&quot;background:white;opacity:0.6;&quot; /&gt; &lt;img src=&quot;https://mdn.mozillademos.org/files/5397/rhino.jpg&quot; style=&quot;position:absolute;width:50px;height:50px;left:50%;transform:translateX(-50%);&quot;/&gt;&lt;/div&gt; 寫完了上面這段以後，覺得完工了，這功能實在太簡單了嘛～但偏偏風漸漸把距離吹的好遠，圖怎麼變小了！根本沒有達到我們想要的阿….. 解法還好在css有一個有趣的屬性叫做clip-path，可以先來看一下MDN的說明 The clip-path CSS property creates a clipping region that sets what part of an element should be shown. Parts that are inside the region are shown, while those outside are hidden. 然後再看一下範例，完全就是我們要的效果阿，太棒了！馬上來套用屬性到功能上 1234&lt;div class=&quot;imageBlock&quot;&gt; &lt;img src=&quot;https://mdn.mozillademos.org/files/5397/rhino.jpg&quot; style=&quot;background:white;opacity:0.6;&quot; /&gt; &lt;img src=&quot;https://mdn.mozillademos.org/files/5397/rhino.jpg&quot; style=&quot;position:absolute;top:0;left:0;bottom:0;right:0;clip-path:circle(50px at center 25px)&quot;/&gt;&lt;/div&gt; 功能完成，可以交差囉！那我們就要來看一下這個屬性的詳細內容circle(radius at position) radius一定不要設定錯，給了直徑就變成兩倍大 關於position的部份可以參考這篇 結論這個屬性目前的支援度也不錯，至少在chrome、safari、ios手機上都是正常的，有了這個屬性可以降低很多的麻煩，不然光搞這個可能就又要多花時間… 慢慢的把核心功能以外的都介紹的差不多了，最後就是drag和zoom的囉，comming soon!","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"http://jiaming0708.github.io/categories/Frontend/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://jiaming0708.github.io/tags/CSS/"},{"name":"crop","slug":"crop","permalink":"http://jiaming0708.github.io/tags/crop/"}]},{"title":"[crop系列] 2 canvas drawimage應用","slug":"canvas-drawimage","date":"2018-12-22T02:32:17.000Z","updated":"2023-03-09T14:18:38.659Z","comments":true,"path":"2018/12/22/canvas-drawimage/","link":"","permalink":"http://jiaming0708.github.io/2018/12/22/canvas-drawimage/","excerpt":"這是接續前一篇[crop系列] 1 scale和position的糾葛的系列之二，前面有提到說要做圖片剪裁，經過了drag和scale後，只要留下一個區塊是我們要的，這時候canvas就出現啦","text":"這是接續前一篇[crop系列] 1 scale和position的糾葛的系列之二，前面有提到說要做圖片剪裁，經過了drag和scale後，只要留下一個區塊是我們要的，這時候canvas就出現啦 首先我們會把圖片先放在img的element中，然後再讓使用者drag和scale後，只裁切圓形所顯示的部份，但我們不會真的裁切成圓形，而是方形作為儲存 不是你以為的樣子首先我們有一個img的elment，實際大小是300*227，指定寬度為200，下面是實際呈現出來的樣式 1&lt;img src=&quot;https://mdn.mozillademos.org/files/5397/rhino.jpg&quot; width=&quot;200&quot; id=&quot;image&quot; /&gt; 接著我們要開始使用canvas，把圖片放進去，直接先指定畫布大小是200*200 123456const img = document.querySelector(&#x27;#image&#x27;);const canvas = document.createElement(&#x27;canvas&#x27;);canvas.width = 200;canvas.height = 200;const ctx = canvas.getContext(&#x27;2d&#x27;);ctx.drawImage(img, 0, 0); 你可以發現到一件事情，圖被切割了！！畫出來的大小竟然不是跟image的元件所產生的是一樣大，而是根據原始檔案 # 指定區域截取 接下來，就是要開始做截取圖片，在drawImage有提供override可以使用，要使用的是其中最多參數的那個，那要先知道每個參數的意義，可以參考一下這篇的說明 放一個50*50的紅框，在畫面上，作為識別我們預期要截取的地方 12345678.block&#123; width: 50px; height: 50px; border: 1px solid red; position: absolute; top: 10px; left: 100px;&#125; 在draw的地方改一下參數 1ctx.drawImage(img, 10, 100, 50, 50, 0, 0, 50, 50); 完蛋了！取到的地方跟我們預期完全不一樣，其實這跟上面所提到的canvas是用實際大小有關係，所以這時候就要來做一點運算，讓位置是符合我們的預期 原圖是300*227，實際是200*151，因此位置要跟著等比例放大，因此先將比例算出來，再拿來計算 1234567891011121314const &#123; offsetWidth, naturalWidth,&#125; = img;const ratio = naturalWidth / offsetWidth;const &#123; offsetTop, offsetLeft,&#125; = document.querySelector(&#x27;.block&#x27;);const realTop = offsetTop * ratio;const realLeft = oofsetLeft * ratio;const realWidth = blockWidth * ratio;const realHeight = blockHeight * ratio;ctx.drawImage(img, realLeft, realTop, realWidth, realHeight, 0, 0, 50, 50); 耶，終於成功啦！拿到我們要的區域，那我們就可以匯出成圖片囉 匯出圖片我們要把截取出來的區域變成blob，最簡單的方法可以使用toBlob，但是要注意在safari是不支援的，那這邊有兩個方法，一個是用polyfill，那另一個就是用toDataURL的作法 這邊介紹的我用的方法toDataURL轉成blob以後丟給api給後端處理 12345678910111213// 先輸出成為base64的字串const image = canvas.toDataURL();// 將base64的資料還原成arrayconst byteString = atob(image.split(&#x27;,&#x27;)[1]);// 轉換成byteconst ab = new ArrayBuffer(byteString.length);const ia = new Uint8Array(ab);for (let i = 0; i &lt; byteString.length; i += 1) &#123; ia[i] = byteString.charCodeAt(i);&#125;const newBlob = new Blob([ib], &#123; type: &#x27;image/jpeg&#x27;,&#125;); 結論一開始弄的時候被size問題困擾好久，因為還加上了scale的功能，然後怎麼拿到的圖片都不對，後來才發現原來又要拿數學來做計算，然後後來又被一個toBlob搞到，所以才又生出一段轉換的動作 參考 MDN base64 to blob","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"canvas","slug":"Frontend/canvas","permalink":"http://jiaming0708.github.io/categories/Frontend/canvas/"}],"tags":[{"name":"crop","slug":"crop","permalink":"http://jiaming0708.github.io/tags/crop/"},{"name":"canvas","slug":"canvas","permalink":"http://jiaming0708.github.io/tags/canvas/"}]},{"title":"[crop系列] 1 scale和position的糾葛","slug":"css-scale-position","date":"2018-12-20T14:27:56.000Z","updated":"2023-03-09T14:18:38.659Z","comments":true,"path":"2018/12/20/css-scale-position/","link":"","permalink":"http://jiaming0708.github.io/2018/12/20/css-scale-position/","excerpt":"最近剛做完一個功能是圖片上傳剪裁(要支援drag和scale)，晚點會把全部整理起來，先來分享一個小東西當我們有一個block要做scale，那這時候的position會是？","text":"最近剛做完一個功能是圖片上傳剪裁(要支援drag和scale)，晚點會把全部整理起來，先來分享一個小東西當我們有一個block要做scale，那這時候的position會是？ 範例 使用angular作為樣本，只是因為懶得寫insert值到element中XD 先來看看一開始還沒做scale前，我們的外框距離top是50px並且水平置中，裡面的話是距離外框top是31px，left是21px 根據這樣的條件，我們可以先來想像一下，當內框用`transform`放大的時候，我們要拿到的offset、client各會是多少？ 可以再editor中改app.component.scss的.scale，已經有先放了一個transform: scale(1)在裡面 答案其實答案不難，首先要知道[transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform)是屬於效果，而並不是實際element的width、height放大，所以offset是不會改變！ 但是client呢？就可以透過getBoundingClientRect這個方法，拿到我們所預期的值！ 進階但你也許會跟我一樣疑惑，client跟offset是完全不一樣的資料，難道我沒有辦法拿到scale後的offset是多少嗎？當然也還是有辦法，這時候我們要透過公式去計算他（一定要寫一點程式，不然有點難過XD） 拿到原始的width、height，並且乘上scale值 12345const widtd = 100;const height = 100;const scale = 1.5;const realWidth = width * scale; // 150const realHeight = height * scale; // 150 因為scale是以中心等比縮放，所以這邊要將計算後和計算前的數值相減除以2 12const diffX = (realWidth - width) / 2; // 25const diffY = (realHeight - height) / 2; // 25 這個數值就會是top和left的偏移量，只要將原始的座標減掉偏移量即可 12345678910// beforelet position = &#123; left: 50, top: 10,&#125;;// afterposition = &#123; left: position.left - diffX, top: psoition.top - diffY,&#125;; 那來總結一下這個算式，(scale - 1) / 2 * value這就是取得偏移量的公式！ 2018&#x2F;12&#x2F;22調整title和第一段描述","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"http://jiaming0708.github.io/categories/Frontend/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://jiaming0708.github.io/tags/CSS/"},{"name":"crop","slug":"crop","permalink":"http://jiaming0708.github.io/tags/crop/"}]},{"title":"[AngularJS] 使用es6開發-grunt+webpack+babel","slug":"angularjs-es6","date":"2018-11-28T01:35:17.000Z","updated":"2023-03-09T14:18:38.659Z","comments":true,"path":"2018/11/28/angularjs-es6/","link":"","permalink":"http://jiaming0708.github.io/2018/11/28/angularjs-es6/","excerpt":"在前一篇[AngularJS] ng-admin介紹中，有提到要使用es6來撰寫，但是angularJS預設是es5，讓我們看一下該怎麼進行整合，使用更強更好用的es6來快樂的開發angularJS","text":"在前一篇[AngularJS] ng-admin介紹中，有提到要使用es6來撰寫，但是angularJS預設是es5，讓我們看一下該怎麼進行整合，使用更強更好用的es6來快樂的開發angularJS 開始之前要開始整合編譯工具之前，應該要先知道架構面的事情，原本在寫angularJS時，每個controller或是directive還是會拆分檔案來進行開發，像是下面這樣 -src–directive.js–directive2.js–controller.js–controller2.js-index.html 上線到server的時候，會將所有的js變成一個檔案，並且進行ugly，大概會是像這樣 -disc.js-index.html 所以在整合es6的時候，我們就要先改變一下寫法，將directive、controller等寫成一個標準export的js檔案，像是下面的寫法 12345678910111213141516171819// duplicate.jsfunction duplicate (Restangular) &#123; return &#123; restrict: &#x27;E&#x27;, scope: &#123; &#125;, template: &#x27;&lt;span class=&quot;fa fa-clone&quot; aria-hidden=&quot;true&quot;&gt;Duplicate post&lt;/span&gt;&#x27;, link: function (scope, element, attrs) &#123; //do something &#125;, &#125;;&#125;duplicate.$inject = [ &#x27;Restangular&#x27;,];export default duplicate; 12345// app.jsimport duplicate from &#x27;./duplicate&#x27;;angular.module(&#x27;app&#x27;).direcitive(&#x27;duplicate&#x27;, duplicate); 這時候呢，我們只要針對app.js這個檔案做編譯，其他被引用到的就會被編譯到同一個檔案中，那之前所用到把各個檔案集中到一個的作法也就不用 編譯工具現在有兩個方法可以將es6編譯成es5，接下來就來詳細的介紹一下這些工具 typescripttypescript是一個超集合，所以可以單純的用ts的檔案但內容全部是一般js的寫法，在angular裡面就開始全部使用ts，所以採用這個也是一個很好的選擇 要注意一下，typescript本身是一個語言，支援js所以有編譯的功能，但絕對比單純的編譯器還強 babel這套算是目前最多人使用的吧，基本上使用react的人幾乎都是用這個工具在進行編譯，官方也提供讓你在線上可以觀看輸出結果，現在babel的版本已經來到7，也跟之前有一些不一樣，所以要注意一下 整合在這次的整合中，我是使用 grunt + webpack + babel作為最後的選擇，先說一下之前嘗試的歷程 因為很少這樣整合，所以在測試上花了很多時間orz typescript在angular中使用過ts，當然想到的第一個整合會是這個，但是在整合的時候發現輸出的結果跟預期的不同，例如import一個檔案進去，但還是有require之類的存在，導致在處理上更加麻煩 建議可以的話還是使用ts，應該會是最佳選擇 babel使用babel本身是非常正常的，但是一跟grunt會編譯失敗，一直找不到真正的原因，時間上的問題，所以只好放棄 “grunt”: “^1.0.3”“grunt-cli”: “^1.2.0” webpack大家最常見的方法，使用webpack+babel的設定，然後再跟grunt整合，這邊來看一下怎麼操作 “webpack”: “^4.23.1”“@babel&#x2F;core”: “^7.1.2” 12345678910111213//將webpack的設定寫在另一個檔案中const webpackConfig = require(&#x27;./webpack.config.js&#x27;);grunt.initConfig(&#123; webpack: &#123; options: &#123; stats: true, &#125;, prod: webpackConfig, //預設mode是prod，所以在開發時就不用特別給 dev: Object.assign(&#123; mode: &#x27;none&#x27; &#125;, webpackConfig), &#125;,&#125;); 結論建議有在繼續寫angularJS的都應該要使用編譯工具，讓開發上更加輕鬆（因為使用angularJS已經夠辛苦），時間除了花在找工具外，也有一部分是在把原本寫不好的code修好，這種整合的期間很痛苦，但弄好的時候真的很爽，都可以使用es6的語法，輕鬆寫code","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"AngularJS","slug":"Frontend/AngularJS","permalink":"http://jiaming0708.github.io/categories/Frontend/AngularJS/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://jiaming0708.github.io/tags/AngularJS/"}]},{"title":"[AngularJS] ng-admin介紹","slug":"ng-admin","date":"2018-11-12T14:26:59.000Z","updated":"2023-03-09T14:18:38.659Z","comments":true,"path":"2018/11/12/ng-admin/","link":"","permalink":"http://jiaming0708.github.io/2018/11/12/ng-admin/","excerpt":"介紹當我們要寫一個後台系統的時候，也就兩種方法可以選，一種是全部自己來，一種是拿著別人寫好的樣板來套，今天要來介紹的就是基於angularjs的一套後台系統ng-admin","text":"介紹當我們要寫一個後台系統的時候，也就兩種方法可以選，一種是全部自己來，一種是拿著別人寫好的樣板來套，今天要來介紹的就是基於angularjs的一套後台系統ng-admin 選擇一個系統當然要看看有沒有什麼好處囉，所以我們來看一下有些什麼功能 restful api CRUD，透過設定的方式來完成 editor 其實非常基本的功能，但還是要介紹下去…已經在這個系統上花了不少時間orz 初始首先要先知道這套系統，基本上不太需要寫太多複雜的程式，只要透過類似設定的方法，就可以做到CRUD，下面來看看該怎麼做 12345678910111213141516171819202122232425262728293031angular.module(&#x27;app&#x27;, [&#x27;ng-admin&#x27;]).config([&#x27;NgAdminConfigurationProvider&#x27;, function(nga)&#123; // application:網站名稱 // baseApiUrl:api end-point var admin = nga.application(&#x27;My First Admin&#x27;) .baseApiUrl(&#x27;http://jsonplaceholder.typicode.com/&#x27;); var user = nga.entity(&#x27;users&#x27;); //定義list畫面要顯示的欄位 user.listView().fields([ nga.field(&#x27;name&#x27;), nga.field(&#x27;username&#x27;), nga.field(&#x27;email&#x27;) ]) //刪除和編輯的功能 .listActions([&#x27;edit&#x27;, &#x27;delete&#x27;]); //定義create畫面要輸入的欄位 user.creationView().fields([ nga.field(&#x27;name&#x27;), nga.field(&#x27;username&#x27;), nga.field(&#x27;email&#x27;) ]); //定義edit畫面要輸入的欄位 user.editionView().fields([ nga.field(&#x27;username&#x27;), nga.field(&#x27;email&#x27;) ]); admin.addEntity(user); nga.configure(admin);&#125;]); 前面有說到這是一個引用restful的admin，所以我們要先定義基本的end-point，接著就是定義要顯示的欄位以及真正的資料來源entity，可以透過上面這個範例看到，非常的簡單，我們其實只是用定義欄位的方法就完成了CRUD end-point基本上打出去的api會是這個模式，當然這套也提供客製request或是response的功能，在這邊我就不特別提到，需要的可以去翻一下參考文件 name type end-point listView GET &#x2F;users creationView POST &#x2F;users showView GET &#x2F;users&#x2F;:id editionView PUT &#x2F;users&#x2F;:id deletionView DELETE &#x2F;users&#x2F;:id 欄位資料關連在admin中很常見到的是要關連另一個資料，例如post中要選擇user，這時候我們可以透過field的關聯欄位來完成 123456789101112131415var user = nga.entity(&#x27;users&#x27;);var post = nga.entity(&#x27;posts&#x27;);post.creationView().fields([ nga.field(&#x27;name&#x27;), //使用reference nga.field(&#x27;userId&#x27;, &#x27;reference&#x27;) //定義關連的資料 .targetEntity(user) //定義要顯示的欄位，預設對應欄位是userId=id .targetField(nga.field(&#x27;username&#x27;)) //顯示的label .label(&#x27;user&#x27;), nga.field(&#x27;email&#x27;),]); 欄位型態#客製 基本的功能在參考資料中可以找到很多，其實官方也寫了很多的說明，告訴你要怎麼使用，以下是官方所支援的所有類型，詳細的使用方法就到各個詳細連結中看囉 string text wysiwyg password email date datetime number float boolean choice and choices json file reference referenced_list embedded_list reference_many 但你一定會有那種需求是上面都做不到的（我就有一個T_T，那我們要怎麼來自定義這些功能呢 自定欄位型態首先的首先，就是這邊一定要用es6的寫法了，所以當你看到這邊，趕快把你的專案加上babel的編譯吧！在這邊我要做的是當另一個欄位值改變時，要將下拉選單的清單更新，這邊我會使用reference作為基底去進行實作一個叫做relate的型態 這邊總共會寫三個檔案 relateField.js，定義可以在nga.field()後面接續的欄位名稱 就是這裡必須要用es6的class寫法 12345678910111213141516171819import ReferenceField from &#x27;admin-config/lib/Field/ReferenceField&#x27;;class RelateField extends ReferenceField &#123; constructor(name) &#123; super(name); //必須要跟config中定義的名稱一樣 this._type = &quot;relate&quot;; this._referenceField = null; &#125; referenceField(field) &#123; if (!arguments.length) return this._referenceField; this._referenceField = field; return this; &#125;&#125;export default RelateField; relateFieldView.js，定義在各種情況下要怎麼呈現，我只在write的情況下改成自己的directive 123456export default &#123; getReadWidget: () =&gt; &#x27;&lt;ma-reference-column field=&quot;::field&quot; value=&quot;::value&quot; datastore=&quot;::datastore&quot;&gt;&lt;/ma-reference-column&gt;&#x27;, getLinkWidget: () =&gt; &#x27;&lt;ma-reference-link-column entry=&quot;::entry&quot; field=&quot;::field&quot; value=&quot;::value&quot; datastore=&quot;::datastore&quot;&gt;&lt;/ma-reference-link-column&gt;&#x27;, getFilterWidget: () =&gt; &#x27;&lt;ma-reference-field field=&quot;::field&quot; value=&quot;value&quot; datastore=&quot;::datastore&quot;&gt;&lt;/ma-reference-field&gt;&#x27;, getWriteWidget: () =&gt; &#x27;&lt;relate field=&quot;::field&quot; value=&quot;value&quot; datastore=&quot;::datastore&quot; entry=&quot;::entry&quot;&gt;&lt;/relate&gt;&#x27;,&#125;; relate.directive.js，定義directive的行為 1234567891011121314151617181920212223242526272829303132333435363738394041function relate (ReferenceRefresher, locale) &#123; return &#123; scope: &#123; &#x27;field&#x27;: &#x27;&amp;&#x27;, &#x27;value&#x27;: &#x27;=&#x27;, &#x27;entry&#x27;: &#x27;=?&#x27;, &#x27;datastore&#x27;: &#x27;&amp;?&#x27;, &#125;, restrict: &#x27;E&#x27;, template: &#x27;&lt;ma-choice-field field=&quot;field()&quot; datastore=&quot;datastore()&quot; refresh=&quot;refresh($search)&quot;&#x27; + &#x27; value=&quot;value&quot;&gt;&lt;/ma-choice-field&gt;&#x27;, link: function (scope) &#123; const field = scope.field(); const referenceFieldId = field.referenceField().name(); scope.name = field.name(); scope.v = field.validation(); //主要的功能所在，監聽參考欄位是否變更 scope.$watch(&#x27;entry.values.&#x27; + referenceFieldId, function (val) &#123; if (!val) &#123; scope.value = undefined; return; &#125; const search = &#123; [referenceFieldId]: scope.entry.values[referenceFieldId], &#125;; //這邊要特別注意，search的物件會直接變成query string //像是這樣 _filters: &#123;&quot;name&quot;:&#123;&quot;region_id&quot;:2&#125;&#125; ReferenceRefresher.refresh(field, scope.value, search) .then(function (formattedResults) &#123; scope.$broadcast(&#x27;choices:update&#x27;, &#123; choices: formattedResults &#125;); &#125;); &#125;); &#125;, &#125;;&#125;relate.$inject = [&#x27;ReferenceRefresher&#x27;, &#x27;locale&#x27;];export default relate; 都寫好以上的程式以後，只要在一開始的config宣告就可以使用 12345678910111213141516angular.module(&#x27;app&#x27;, [&#x27;ng-admin&#x27;]).config([&#x27;NgAdminConfigurationProvider&#x27;, &#x27;FieldViewConfigurationProvider&#x27;, function(nga, fvp)&#123; nga.registerFieldType(&#x27;relate&#x27;, RelateField); fvp.registerFieldView(&#x27;relate&#x27;, RelateFieldView); post.creationView().fields([ nga.field(&#x27;name&#x27;), nga.field(&#x27;userId&#x27;, &#x27;relate&#x27;) .targetEntity(user) .targetField(nga.field(&#x27;username&#x27;)) //name欄位值變更時，要引發這邊的選單變更 .referenceField(nga.field(&#x27;name&#x27;)) .label(&#x27;user&#x27;), ]); &#125;); 但是這邊稍微實驗一下，可以發現在directive中datastore是無法在一開始拿到users的資料，跟reference的行為有一點點的不一樣，追了一下source code以後，發現這是被包起來定義好的，所以沒辦法有相同的行為，但還好的是我不需要一開始就有資料，而是要等到referenceField變更以後再取得 結論今天的介紹就到這邊，這套admin是一個蠻不一樣的架構，不希望你寫太多程式，而是透過設定的模版來達到需求，但是當今天功能越來越複雜，這套的限制就會越來越大，再客製上會有很大的侷限，如果已經知道未來會有很多變化（不管是欄位或是api），那建議就是不要使用這套，而是採用其他模版透過寫程式的方式最沒有侷限 參考 gitbook github","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"AngularJS","slug":"Frontend/AngularJS","permalink":"http://jiaming0708.github.io/categories/Frontend/AngularJS/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://jiaming0708.github.io/tags/AngularJS/"}]},{"title":"[AngularJS] Provider探究","slug":"angularjs-provider","date":"2018-11-07T04:44:39.000Z","updated":"2023-03-09T14:18:38.659Z","comments":true,"path":"2018/11/07/angularjs-provider/","link":"","permalink":"http://jiaming0708.github.io/2018/11/07/angularjs-provider/","excerpt":"介紹 此篇是AngularJS 1.x，不是2+以上的喔！ 在AngularJS中提供一個很好用的機制叫做DI(Dependecy Injection 依賴注入)，這是一個design pattern，可以降低測試及宣告的程度，想要了解更完整的觀念可以參考一下燈哥的文章，這邊就不探討。","text":"介紹 此篇是AngularJS 1.x，不是2+以上的喔！ 在AngularJS中提供一個很好用的機制叫做DI(Dependecy Injection 依賴注入)，這是一個design pattern，可以降低測試及宣告的程度，想要了解更完整的觀念可以參考一下燈哥的文章，這邊就不探討。 官方也專門寫了一篇來介紹整個的機制，但其實真的很容易搞混，所以特別寫了這篇文章來記錄。首先先來看看有哪些是可以被inject的 provider constant value factory service decorator filter DI時機這麼多的類型，他們可以被inject的時機也會有所不同，可以參考官方文件，在使用上要注意一下要寫的service是屬於什麼層級 區塊 限制 run 除了provider以外的都可以用 config 除了provider、constant以外的都不能用 provider 除了provider、constant以外的都不能用，如果inject其他provider要注意順序 Provider那到底什麼是provider，為什麼會有這麼多限制在，其實前面所提到的類型基本上都是透過provider來實作出來的，我們先來看一下怎麼寫一個provider 12345678910111213141516171819202122//providerangular.module(&#x27;app&#x27;).provider(&#x27;first&#x27;, function()&#123; function console (str) &#123; console.log(str); &#125;; // $get一定要有的 this.$get = function()&#123; return &#123; console: console, &#125; &#125;;&#125;)//config.config([&#x27;firstProvider&#x27;, function(firstProvider)&#123; //呼叫getData firstProvider.$get().console(&#x27;config&#x27;);&#125;])//directive.directive(&#x27;myDirective&#x27;, [&#x27;first&#x27;, function(first)&#123; first.console(&#x27;directive&#x27;);&#125;]); 可以發現到firstProvider在兩個地方是完全不一樣的表現 在大部分的使用情況下inject都會直接拿到$get的function內容 只能使用provider的地方，一定要在使用時必須要像這樣&#123;name&#125;Provider，而且只能自己呼叫 provider.$get()去拿到裡面的內容 也就是說今天我們有一個provider只打算提供給config、provider使用的話，可以直接寫在provider的object中，但$get還是必須要有的，但我們可以不回傳任何東西 12345678910//providerangular.module(&#x27;app&#x27;).provider(&#x27;first&#x27;, function()&#123; this.console = function (str) &#123; console.log(str); &#125;; // $get一定要有的 this.$get = function()&#123; &#125;;&#125;); 實作類型constant、value、factory、service都是透過provider來實作的，那實際上到底是怎麼運作的呢，我們可以來看一下這段在官方的範例 1234567891011angular.module(&#x27;myModule&#x27;, []). value(&#x27;a&#x27;, 123). factory(&#x27;a&#x27;, function() &#123; return 123; &#125;).// is same asangular.module(&#x27;myModule&#x27;, []). config(function($provide) &#123; $provide.value(&#x27;a&#x27;, 123); $provide.factory(&#x27;a&#x27;, function() &#123; return 123; &#125;); &#125;); 可以發現到其實都是透過$provider來做註冊，所以我們當然也能夠透過provider來完成實作，各個的詳細範例可以看一下官方文件 結論講了那麼多，主要就是要知道provider的使用上一些要注意的點，當然你一定會想說既然provider這麼強大，基本上都可以用，那為什麼我們不要全部都寫provider就好呢？其實當然可以，但是寫起來會比較麻煩一點阿，沒事還要自己寫那些$get的內容，不如直接用已經提供的服務不是更好！","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"AngularJS","slug":"Frontend/AngularJS","permalink":"http://jiaming0708.github.io/categories/Frontend/AngularJS/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://jiaming0708.github.io/tags/AngularJS/"}]},{"title":"Rx真實案例展示","slug":"rx-sample","date":"2018-08-20T12:21:01.000Z","updated":"2023-03-09T14:18:38.659Z","comments":true,"path":"2018/08/20/rx-sample/","link":"","permalink":"http://jiaming0708.github.io/2018/08/20/rx-sample/","excerpt":"今天要來帶大家看三個我實際有使用過的案例，並且一個步驟一個步驟的走過，當然我們會從簡單到複雜…","text":"今天要來帶大家看三個我實際有使用過的案例，並且一個步驟一個步驟的走過，當然我們會從簡單到複雜… AutoComplete這是一個常見的需求，而且這個功能絕對是非常好使用Rx的一個情境，搭配Angular Reactive Form效果更好 先來描述一下這個案例 監聽input的keyup 呼叫API 取得資料顯示 循環步驟1 監聽input首先我們先寫一個套用Reactive Form的input 使用async可以加上$用來區隔變數 12345678&lt;form [formGroup]=&quot;form&quot;&gt; &lt;input formControlName=&quot;keyword&quot;&gt; &lt;ul&gt; &lt;li *ngFor=&quot;let item of wastes$ | async as wastes&quot;&gt; &#123;&#123;item.OrgName&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/form&gt; 1234567891011121314151617181920212223242526import &#123; Component, OnInit &#125; from &#x27;@angular/core&#x27;;import &#123; FormBuilder, FormGroup &#125; from &#x27;@angular/forms&#x27;;import &#123; Observable &#125; from &#x27;rxjs&#x27;;@Component(&#123; selector: &#x27;app-root&#x27;, templateUrl: &#x27;./app.component.html&#x27;, styleUrls: [&#x27;./app.component.css&#x27;]&#125;)export class AppComponent implements OnInit &#123; keyword$: Observable&lt;string&gt;; form: FormGroup; wastes$: any; ngOnInit() &#123; this.form = this.fb.group(&#123; keyword: [&#x27;&#x27;] &#125;); this.form.get(&#x27;keyword&#x27;) .valueChanges .subscribe(p=&gt;console.log(&#x27;input&#x27;, p)); &#125; constructor(private fb: FormBuilder) &#123;&#125;&#125; 透過FormGroup的valueChanges就能夠監聽input的變動了(484很簡單!!) 呼叫API這邊我們使用環保署的API，並且先不做server的filter，而是採用client的 最好的作法應該是用server做filter 1234567891011121314[ &#123; &quot;County&quot;: &quot;宜蘭縣&quot;, &quot;OrgType&quot;: &quot;清除&quot;, &quot;Grade&quot;: &quot;甲&quot;, &quot;OrgName&quot;: &quot;境庭有限公司&quot;, &quot;RegistrationNo&quot;: &quot;G3004187&quot;, &quot;OrgAddress&quot;: &quot;宜蘭縣宜蘭市文昌路一九八之六號一樓&quot;, &quot;TreatMethod&quot;: &quot;&quot;, &quot;GrantDeadline&quot;: &quot;2022/7/18 上午 12:00:00&quot;, &quot;OrgTel&quot;: &quot;03-9356440&quot;, &quot;OperatingAddress&quot;: &quot;宜蘭縣宜蘭市文昌路一九八之六號一樓&quot; &#125;] 可以看到輸出的資料是一個物件的陣列，所以我們要宣告一個interface來做為資料model 等等將採用OrgName來做為搜尋條件 123456789101112export interface Waste &#123; County: string; OrgType: string; Grade: string; OrgName: string; RegistrationNo: string; OrgAddress: string; TreatMethod: string; GrantDeadline: string; OrgTel: string; OperatingAddress: string;&#125; 12345678910111213141516171819202122import &#123; Injectable &#125; from &#x27;@angular/core&#x27;;import &#123; environment &#125; from &#x27;src/environments/environment&#x27;;import &#123; HttpClient &#125; from &#x27;@angular/common/http&#x27;;import &#123; map &#125; from &#x27;rxjs/operators&#x27;;import &#123; Waste &#125; from &#x27;@app/models/waste&#x27;;@Injectable(&#123; providedIn: &#x27;root&#x27;&#125;)export class EnvAPIService &#123; public wasteAPI$ = this.http.jsonp(this.generatorUrl(&#x27;355000000I-001154&#x27;), &#x27;callback&#x27;) .pipe( map((p: any) =&gt; p.result.records as Waste[]) ); generatorUrl(resouceId: string, params?: any[]): string &#123; const queryParam = !params ? &#x27;&#x27; : `&amp;$&#123;params.join(&#x27;&amp;&#x27;)&#125;`; return `$&#123;environment.envAPIEndpoint + resouceId&#125;?format=json&amp;toekn=$&#123;environment.envToken&#125;$&#123;queryParam&#125;`; &#125; constructor(private http: HttpClient) &#123; &#125;&#125; 接著我們要跟service做一個串接，這邊先來解析一下會怎麼思考使用的operator API取得資料是一個陣列，但我們要用OrgName作為過濾條件，所以需要要先將陣列拆開(switchMap) 過濾OrgName(filter) 將拆開的陣列組合回去(toArray) 1234567891011121314151617181920212223242526272829303132333435363738import &#123; Component, OnInit &#125; from &#x27;@angular/core&#x27;;import &#123; filter, mergeMap, switchMap, toArray, debounceTime, map &#125; from &#x27;rxjs/operators&#x27;;import &#123; FormBuilder, FormGroup &#125; from &#x27;@angular/forms&#x27;;import &#123; Observable, combineLatest &#125; from &#x27;rxjs&#x27;;import &#123; Waste &#125; from &#x27;@app/models/waste&#x27;;import &#123; EnvAPIService &#125; from &#x27;@app/service/env-api.service&#x27;;@Component(&#123; selector: &#x27;app-root&#x27;, templateUrl: &#x27;./app.component.html&#x27;, styleUrls: [&#x27;./app.component.css&#x27;]&#125;)export class AppComponent implements OnInit &#123; keyword$: Observable&lt;string&gt;; form: FormGroup; wastes$: Observable&lt;Waste[]&gt;; hasKeyword = (keyword: string) =&gt; &#123; return (waste: Waste) =&gt; waste.OrgName.indexOf(keyword) &gt; -1; &#125; ngOnInit() &#123; this.form = this.fb.group(&#123; keyword: [&#x27;&#x27;] &#125;); this.keyword$ = this.form.get(&#x27;keyword&#x27;).valueChanges; this.wastes$ = this.keyword$.pipe( mergeMap(keyword =&gt; this.envAPI.wasteAPI$.pipe( switchMap(p =&gt; p), filter(this.hasKeyword(keyword)), toArray() )) ); &#125; constructor(private envAPI: EnvAPIService, private fb: FormBuilder) &#123;&#125;&#125; 這邊必須注意service或是input事件的先後順序，因為input會是持續發生，所以必須要以keyword$為主 如果是es5作法呢？ 123456var result = [];array.forEach(p =&gt; &#123; if(p.OrgName.indexOf(keyword) &gt; -1)&#123; result.push(p); &#125;&#125;); 優化 原本使用mergeMap還要考慮先後順序，可以改成combineLatest 加上輸入的間隔時間debounceTime，避免一直呼叫API 1234567this.wastes$ = combineLatest( this.keyword$.pipe( debounceTime(200) ), this.envAPI.wasteAPI$).pipe( map(([keyword, wastes]) =&gt; wastes.filter(this.hasKeyword(keyword)))); 資料整理轉換先來看一下資料，一樣有個陣列裡面有著日期和兩種等級 12345678910111213141516171819202122232425[ &#123; modifyTime: &#x27;2018/03/27&#x27;, criticalLevel: 4, oddsLevel: 4 &#125;, &#123; modifyTime: &#x27;2018/02/27&#x27;, criticalLevel: 3, oddsLevel: 3 &#125;, &#123; modifyTime: &#x27;2018/01/27&#x27;, criticalLevel: 2, oddsLevel: 2 &#125;, &#123; modifyTime: &#x27;2018/04/27&#x27;, criticalLevel: 3, oddsLevel: 3 &#125;, &#123; modifyTime: &#x27;2018/03/22&#x27;, &#125; ] 看一下預期目標 沒有criticalLevel或是oddsLevel的忽略 輸出資料1，將每一筆資料組合成以下的格式，日期排序 1234567[ &#123; id: `$&#123;oddsLevel&#125;-$&#123;criticalLevel&#125;`, date: &#x27;&#x27;, order: 0 &#125;] 輸出資料2，計算相同id的total數並組成以下的格式 1234567[ &#123; id: `$&#123;oddsLevel&#125;-$&#123;criticalLevel&#125;`, total: 0, current: 0 &#125;] 實作這邊分兩個部分來做，會比較輕鬆一點，不然整段會漏漏等 第一組資料一樣來拆執行步驟 將陣列拆成資料流(switchMap) 過濾沒有criticalLevel和oddsLevel(filter) 重新組合物件&#123;id, date&#125;(map) 合成陣列(toArray) 排序(map、sort) 加上order(map、map) 12345678910111213getPointList() &#123; return obs =&gt; obs.pipe( switchMap((p: HistoryRecord[]) =&gt; p), filter((p: HistoryRecord) =&gt; !!p.criticalLevel &amp;&amp; !!p.oddsLevel), map((p: HistoryRecord) =&gt; (&#123; id: `$&#123;p.oddsLevel&#125;-$&#123;p.criticalLevel&#125;`, date: p.modifyTime &#125; as PointData)), toArray(), map((p: PointData[]) =&gt; p.sort((a, b) =&gt; Date.parse(b.date) - Date.parse(a.date))), map((p: PointData[]) =&gt; p.map((data, idx) =&gt; (&#123; ...data, order: idx &#125;))) );&#125; 第二組資料透過第一組資料來組合成第二組，其實步驟很簡單，但是資料從前面來輸出成新的物件，所以我們要把第二步驟的行為視為一個observer 再來拆步驟 直接把陣列拆開(from) 統計每個id的數量(reducer) 重新產生新的物件(map) 1234567891011121314151617getPointCount() &#123; return obs =&gt; obs.pipe( mergeMap((pointList: PointData[]) =&gt; from(pointList) .pipe( reduce((acc, value: PointData) =&gt; &#123; const id = value.id; if (!acc[id]) &#123; acc[id] = &#123; total: 0, current: 0 &#125; as PointCount; &#125; acc[id].total++; return acc; &#125;, [] as PointCount[]), map(counts =&gt; (&#123; pointList: pointList, pointCount: counts &#125;)) )) );&#125; 組合將第一組和第二組資料做結合，然後輸出成為最終需要的資料 12345this.api.dataApi$.pipe( filter(p =&gt; !!p &amp;&amp; p.length &gt; 0), this.getPointList(), this.getPointCount()).subscribe(p =&gt; console.log(p)); 動態資料監聽這個需求比較特別一點，資料流是從API下來（也就是前一個範例的處理），經過component處理後輸出，然後我們要監聽這些經過component處理後的資料。格式如下： 123456789101112131415161718192021222324// 1&#123; top: 10, left: 10, order: 0&#125;// 2&#123; top: 20, left: 20, order: 1&#125;// 3&#123; top: 30, left: 30, order: 2&#125;// 4&#123; top: 40, left: 40, order: 3&#125; 最後我們期望得到的是這樣一組一組的資料集 1[[1, 2], [2, 3], [3, 4]] 所以這邊我們要先思考一下怎麼解析這個問題… 監聽component送出的資料 確認要取得的資料筆數 根據資料做排序 組成兩兩一組的資料(pairewise) 思維是這樣，但其實我在寫這個功能的時候為了解決第2、4點，嘗試了很多的方法 問題一，使用pairewise資料必須要有終點(complete)，不然不會有任何結果出來 根據問題一延伸問題二，怎麼知道資料已經取完 最後最後，我使用了bufferCount這個operator來解決這個問題，但是又會延伸新問題 當前面重新取得資料，subject中還有前面舊的資料，這時候buffer會拿不到最新的資料，所以又必須讓buffer重新定位 這問題我找了很多的方法，而且也找人一起討論，重要的是pairwise很難debug…TAT 1234567891011this.api.pointList$ .pipe( mergeMap(pointList =&gt; this.api.elementPoint$ .pipe( bufferCount(pointList.length), switchMap(p =&gt; p.sort((a, b) =&gt; a.order - b.order)), pairwise(), bufferCount(pointList.length - 1, 1), ))) .subscribe(p =&gt; console.log(p)); Conculsion 在不熟的情況下，先使用最熟悉的作法，再來開始想裡面的步驟如何被拆出來 不用試著對每個operator都很熟悉，百分之七十以上的情況都在寫常用的那幾個 最後就是用問的看有沒有更好的寫法 Reference AutoComplete完整範例 進階範例","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"},{"name":"RxJS","slug":"RxJS","permalink":"http://jiaming0708.github.io/tags/RxJS/"}]},{"title":"[Angular] 使用AngularCli搭配ng-packagr建立元件","slug":"angular-cli-packagr","date":"2018-06-13T12:09:31.000Z","updated":"2023-03-09T14:18:38.659Z","comments":true,"path":"2018/06/13/angular-cli-packagr/","link":"","permalink":"http://jiaming0708.github.io/2018/06/13/angular-cli-packagr/","excerpt":"平常我們都用Angular Cli來建立專案，但如果有需要製作元件給別人使用，這時候應該怎麼做比較好 今天會示範如何使用Angular Cli來建立一個元件並且發佈到npm","text":"平常我們都用Angular Cli來建立專案，但如果有需要製作元件給別人使用，這時候應該怎麼做比較好 今天會示範如何使用Angular Cli來建立一個元件並且發佈到npm 產生Component 使用cli產生一個專案 1ng new my-component 建立一個獨立的module叫做first 1ng g m first 給別人的元件一定是獨立的module，除非你要將AppModule當做給人import的module，但一般我們不會這樣做，而是弄一個相對有意義的名稱 產生一個component叫做red 1ng g c first/red 這個功能我們就先讓component的字顏色變成紅色 123&lt;p style=&quot;color:red&quot;&gt; &lt;ng-content&gt;&lt;/ng-content&gt;&lt;/p&gt; 接著我們先用一般的方式來看看有沒有如我們預期 1&lt;app-red&gt;this is my first component&lt;/app-red&gt; 封裝這邊我們使用ng-packagr的套件來協助我們達到這件事情 npm i ng-packagr –save-dev 接著我們要產生兩個檔案，首先是ng-package.json，要注意一定要有whitelistedNonPeerDependencies將一些angular已經包含的東西都過濾掉不打包 123456789&#123; &quot;$schema&quot;: &quot;./node_modules/ng-packagr/ng-package.schema.json&quot;, &quot;lib&quot;: &#123; &quot;entryFile&quot;: &quot;public_api.ts&quot; &#125;, &quot;whitelistedNonPeerDependencies&quot;: [ &quot;.&quot; ]&#125; 再來要產生public_api.ts，這個檔案會描述所有要對外開放的module 1export * from &#x27;./src/app/first/first.module&#x27;; 這些前置作業都做完後，我們就可以來進行編譯，那這邊可以偷懶一點在package.json加上指令 123456&#123; &quot;scripts&quot;:&#123; &quot;start&quot;: &quot;ng serve&quot;, &quot;packagr&quot;: &quot;ng-packagr -p ng-package.json&quot; &#125;&#125; 執行完npm run packagr的指令後，就可以看到增加了一個dist的目錄 測試上面的動作都執行完以後，我們可以先進行個簡單的測試，用另一個專案將剛剛打包的東西引入 首先要先產生一個可以被npm認識的tgz檔案，所以要先切換到dist的目錄，並且執行指令npm pack，就可以看到dist目錄中會多出my-component-0.0.0.tgz的檔案，這就是要放到另一個專案中被install的檔案 0.0.0是根據package.json的version而來 建立了一個新的專案ng new test-component然後把剛剛產生的檔案放到根目錄，並且執行npm install my-component-0.0.0.tgz，就可以開始使用 首先在AppModule加上我們所建立的Module 12345678910111213141516171819import &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; BrowserModule &#125; from &#x27;@angular/platform-browser&#x27;;import &#123; FirstModule &#125; from &#x27;my-component&#x27;;import &#123; AppComponent &#125; from &#x27;./app.component&#x27;;@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, FirstModule //我們所建立的module ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 再來就是在app.component.html中加上app-red 1&lt;app-red&gt;hello component&lt;/app-red&gt; 執行起來就可以看到畫面上出現hello component並且呈現紅色，那這個功能就是沒問題 當然也可以把這個步驟放到發佈之後，直接從npm上面下載下來 發佈這個地方就很簡單啦，只要在dist的目錄下執行npm publish就可以發布到npm中囉！ 只要跟平常我們安裝新的套件方式一樣，執行npm install my-component就可以 記得先要有npm的帳號，並且在本機登入 參考Building an Angular 4 Component Library with the Angular CLI and ng-packagr 另一個套件的資料也可以參考 How to build and publish an Angular module 補充2018&#x2F;06&#x2F;20 在線上讀書會中分享，kevin也提到angular cli 6的版本已經包含這個功能 1ng g library jimmy-demo 執行後，可以看到整個目錄中多了一個projects的目錄，可以看到是一個完整的專案，編譯的話就要特別指定 1ng build jimmy-demo 一樣可以在dist中看到一個目錄jimmy-demo，只要切到這個目錄底下就可以做npm publish","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"如何再Wallaby取得package.json檔案","slug":"wallaby-packagejson","date":"2018-05-28T12:21:12.000Z","updated":"2023-03-09T14:18:38.659Z","comments":true,"path":"2018/05/28/wallaby-packagejson/","link":"","permalink":"http://jiaming0708.github.io/2018/05/28/wallaby-packagejson/","excerpt":"最近看到 Kevin 的一篇文章，說到有用到alias就必須在wallaby另外設定，想說很久沒有弄前陣子上線的專案，開啟來設定看看，沒想到設定後完全沒有用","text":"最近看到 Kevin 的一篇文章，說到有用到alias就必須在wallaby另外設定，想說很久沒有弄前陣子上線的專案，開啟來設定看看，沒想到設定後完全沒有用 後來檢查發現到，竟然是因為當初為了要拿到package.json的version而在environment加上require直接取值，像下面這樣 1234export const environment = &#123; production: false, appVersion: require(&#x27;../../package.json&#x27;).version&#125;; 因為wallaby根本不認識package.json的檔案，因此我們必須要先讓wallaby認識，加上兩個地方的設定 12345678910111213module.exports = function (wallaby) &#123; return &#123; files: [ &#x27;package.json&#x27; //... ], middleware: function (app, express) &#123; var path = require(&#x27;path&#x27;); app.use(&#x27;/package.json&#x27;, express.static(path.join(__dirname, &#x27;package.json&#x27;))); //... &#125; &#125;&#125; 這樣就可以打完收工，繼續使用wallaby啦 附帶一提，如果有用到chart.js，也一樣要寫進files","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"},{"name":"Wallaby","slug":"Wallaby","permalink":"http://jiaming0708.github.io/tags/Wallaby/"}]},{"title":"Vue初體驗","slug":"vue-first-time","date":"2018-05-21T14:04:31.000Z","updated":"2023-03-09T14:18:38.659Z","comments":true,"path":"2018/05/21/vue-first-time/","link":"","permalink":"http://jiaming0708.github.io/2018/05/21/vue-first-time/","excerpt":"最近朋友要做一個公司的官網，身為前端人（自己說XD），怎麼可以用wix&#x2F;wordpress那些啦一啦而已呢當然要玩一下沒玩過的東西，一直聽說Vue不錯用，因此就來玩玩看囉","text":"最近朋友要做一個公司的官網，身為前端人（自己說XD），怎麼可以用wix&#x2F;wordpress那些啦一啦而已呢當然要玩一下沒玩過的東西，一直聽說Vue不錯用，因此就來玩玩看囉 建立專案起手式，當然要先來個vue-cli 1npm install -g @vue/cli 接著就是要建立專案 1vue create my-project 這邊提供兩種方式建立專案，個人建議用manually，原因等一下可以看到 defaul首先來看一下default，就是一個很簡單的內容，沒有route沒有scss，但我們通常會希望有route、scss這些基本的東西吧，因此還是要用進階的設定 manually這時候我們可以選擇一些想要使用在這個專案中的功能，像是TypeScript、Router、SCSS，這些是我基本會用到的，其他就是要看專案的性質囉 接著會根據你的選擇，會有不同的設定，像是這樣 產生出來的專案就會是這樣，是不是比較符合我們要的結果了，可以開工囉！ 開始享受Vue的整個生命週期是從main.ts開始，從這邊可以看到透過render的方式將App這個內容產生出來，然後替換#app&#96;的dom 12345678import Vue from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import router from &#x27;./router&#x27;;new Vue(&#123; router, render: (h) =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;); 順著內容看下去，接著來看看App.vue是在做什麼的，.vue這個副檔名就是component的宣告內容，其中分為三塊 template 一個component必須要有一個element作為root，可以參考下面的範例 123456789&lt;!--correct--&gt;&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;!--error--&gt;&lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt; 透過大括號的方式&#123;&#123;title&#125;&#125;把model的資料放進畫面中 使用v-*開頭對element做變化的語法，例如v-for就是重複element的指令；其他指令就去官網查詢囉 script 一個component不一定要有這段，但如果需要有model或是引用其他component就必須要加上script 要被引用的component必須要被放在components中，而且是用物件的方式來撰寫 在這個component自己宣告的model必須要用data宣告，而且必須是一個function 12345678910111213141516import Vue from &#x27;vue&#x27;;import Header from &#x27;@/components/Header.vue&#x27;;import Footer from &#x27;@/components/Footer.vue&#x27;;export default Vue.extend(&#123; name: &#x27;app&#x27;, components: &#123; Header, Footer, &#125;, data: () =&gt; &#123; return &#123; title: &#x27;Hello&#x27; &#125;; &#125;,&#125;); style有兩個方法可以來定義css的範圍 向下繼承，像是App這個component的定義就會是這種模式，但其他地方不建議使用，很容易污染（這邊我不太喜歡比較喜歡把這種全域的另外拉出去一個檔案，然後直接被index.html引用，但要自己去寫webpack處理….懶） component限定，編譯的時候會加上一個id之類的在所有的css，來確保是只有這個component使用到 1234&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 在這邊我喜歡把scss另外開檔案寫，比較乾淨一點 router看完了.vue的檔案結構以後，已經有些了解，接著就是來看看SPA一定會遇到的route是怎麼定義和使用 首先必須要先new一個Router的物件，然後再裡面定義path、name、component還記得App.vue中有import一個router嗎？其實就是引入這個地方的設定 123456789101112131415161718192021import Vue from &#x27;vue&#x27;;import Router from &#x27;vue-router&#x27;;import Home from &#x27;./views/Home.vue&#x27;;import About from &#x27;./views/About.vue&#x27;;Vue.use(Router);export default new Router(&#123; routes: [ &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: Home, &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;about&#x27;, component: About, &#125;, ],&#125;); 接著在template使用router-link就可以 to也就是url，前面檔案所定義的path active-class當目前url跟目前route一樣時，就會套上這個class，預設class是router-link-active exact是為了讓active-class運作更正確一點，當目前到/about的路徑，則/和/about都會被套上class，但我們預期應該是只有一個被套用，因此要將這個屬性設定上去（簡單說就是完全符合path） 12&lt;router-link to=&quot;/about&quot; active-class=&quot;selected&quot; exact&gt;&lt;/router-link&gt; 結論用一個簡單的網站練習一下vue，其實內容整體來說不差，真的不能否認小專案用vue上手還蠻快速的，如果真的要到專案&#x2F;產品中使用，還有很多東西需要摸索 因此對我來說Angular更適合一點，兩個的寫法上差異真的沒有很大，但是cli的方便性或是檔案的分離，都讓我更加的喜歡（拜託不要來戰我～～） 另外有幾個地方想請教一下大家為什麼要這樣用 使用export default而不是給一個實際名稱 把template、script、style都寫在一起，這樣如果這個功能稍微複雜一點，不就會很「漏漏等」，還是說這應該算是component的設計失敗?","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Vue","slug":"Frontend/Vue","permalink":"http://jiaming0708.github.io/categories/Frontend/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://jiaming0708.github.io/tags/Vue/"}]},{"title":"[Angular] PrimeNG開發兩三事","slug":"primeng","date":"2018-03-26T14:06:00.000Z","updated":"2023-03-09T14:18:38.659Z","comments":true,"path":"2018/03/26/primeng/","link":"","permalink":"http://jiaming0708.github.io/2018/03/26/primeng/","excerpt":"前陣子公司的一個產品算是告一段落，這次使用PrimeNG作為元件的基底，但是在使用的過程中，也是有遇到一些值得記錄的事項，因此特別寫了這篇。","text":"前陣子公司的一個產品算是告一段落，這次使用PrimeNG作為元件的基底，但是在使用的過程中，也是有遇到一些值得記錄的事項，因此特別寫了這篇。 Message物件的格式是這樣&#123;severity:string, summary:string, details:string&#125;，但每次都要重複寫那些屬性有點多餘，因此我將這個封裝成service，直接提供success、error、info、warn四個方法。 然後把message的物件用subject傳送，這樣就能在app.component.html直接用async的方式接起來。 另外IE11要特別注意一下，details如果沒給值，畫面上會出現null的字，然後就會被殺了orz這個issue確定會在5.2.4改掉 1234567891011121314151617181920212223import &#123; Injectable &#125; from &#x27;@angular/core&#x27;;import &#123; Message &#125; from &#x27;primeng/primeng&#x27;;import &#123; Subject &#125; from &#x27;rxjs/Subject&#x27;;@Injectable()export class MessageService &#123; messages$ = new Subject&lt;Message[]&gt;(); constructor() &#123;&#125; success(content: string) &#123; this.messages$.next([&#123; severity: &#x27;success&#x27;, summary: content, detail: &#x27;&#x27; &#125;]); &#125; error(content: string) &#123; this.messages$.next([&#123; severity: &#x27;error&#x27;, summary: content, detail: &#x27;&#x27; &#125;]); &#125; info(content: string) &#123; this.messages$.next([&#123; severity: &#x27;info&#x27;, summary: content, detail: &#x27;&#x27; &#125;]); &#125; warn(content: string) &#123; this.messages$.next([&#123; severity: &#x27;warn&#x27;, summary: content, detail: &#x27;&#x27; &#125;]); &#125;&#125; 1&lt;p-growl [value]=&quot;msgService.messages$ | async&quot;&gt;&lt;/p-growl&gt; Menu&#x2F;Bread這邊提供一個小tip，如果說route有很相似的，但在menu&#x2F;bread上面不想要被同時選取，這時候可以加上routerLinkActiveOptions: &#123; exact: true &#125;，這個在angular官網有被提到過。 route的情境像是這樣，沒有加上exact的情況，進入產品頁面的時候，是三個都會被反白，但這基本上不是我們要的效果，因此就要加上，讓他要完整路徑都對才會反白。 12345menuList: MenuItem[] = [ &#123;label: &#x27;產品&#x27;, routerLink: [&#x27;/product&#x27;], routerLinkActiveOptions: &#123; exact: true &#125;&#125;, &#123;label: &#x27;特賣&#x27;, routerLink: [&#x27;/product/special&#x27;], routerLinkActiveOptions: &#123; exact: true &#125;&#125;, &#123;label: &#x27;團購&#x27;, routerLink: [&#x27;/product/together&#x27;], routerLinkActiveOptions: &#123; exact: true &#125;&#125;]; Dialog包在Component中如果你也有把dialog整個包進去component的需求，那這個方法就很適合你！ dialog的開啟是透過boolean來控制，當寫成component的時候，參數並不會被改變，這時候dialog就不會再次被開啟，因此我們的好朋友subject出現啦！ 首先child component可以這樣寫 123&lt;p-dialog [(visible)]=&quot;displayFlag&quot; [modal]=&quot;true&quot;&gt; show something&lt;/p-dialog&gt; 12345678910export class YourComponent implements OnInit&#123; @Input() data: Subject&lt;boolean&gt;; displayFlag: boolean; ngOnInit() &#123; this.data.subscribe(value =&gt; &#123; this.displayFlag = true; &#125;); &#125;&#125; 再來parent component的地方，就直接把宣告好的subject放進去，然後每次要開啟就呼叫subject 12&lt;button (click)=&quot;open()&quot;&gt;open dialog&lt;/button&gt;&lt;app-your [data]=&quot;openDialog$&quot;&gt;&lt;/app-your&gt; 1234567export class ParentComponent &#123; openDialog$ = new Subject&lt;boolean&gt;(); open()&#123; //這邊傳true或false都不影響開啟，重點是要讓subject有值過去觸發 this.openDialog$.next(true); &#125;&#125; onHide我們有一個需求是表單填寫的內容放在Dialog中，如果有填寫但最後不儲存，離開前需要提示，像是下面這個範例 123456789&lt;p-dialog [(visible)]=&quot;displayDialog&quot; [modal]=&quot;true&quot;&gt; &lt;!-- 表單內容 --&gt; &lt;form [formGroup]=&quot;form&quot;&gt; &lt;/form&gt; &lt;p-footer&gt; &lt;button pButton type=&quot;button&quot; class=&quot;ui-button-secondary&quot; label=&quot;離開&quot; (click)=&quot;close()&quot;&gt;&lt;/button&gt; &lt;button pButton type=&quot;button&quot; class=&quot;ui-button-primary&quot; label=&quot;儲存&quot; (click)=&quot;save()&quot;&gt;&lt;/button&gt; &lt;/p-footer&gt;&lt;/p-dialog&gt; 12345678910@Component()export class MyComponent&#123; displayDialog: boolean; form: FormGroup; close()&#123; //show confirm this.displayDialog = false; &#125;&#125; 但是右上角有個X，按的時候也視同關閉，因此我們需要加上一個事件onHide來做控制，但是當我們像上面範例，把displayDialog改成false，這時候其實也會觸發onHide的事件，因此就要稍微注意一下順序的控制，才能避免不斷的觸發，大致的作法像是這樣。 1234567891011121314151617181920212223@Component()export class MyComponent implements OnInit&#123; displayDialog: boolean; form: FormGroup; valueChange: boolean; ngOnInit()&#123; this.form.valueChanges .subscribe(p =&gt; this.valueChange = true); &#125; close()&#123; this.displayDialog = false; &#125; hide()&#123; if(this.valueChange)&#123; // show confirm &#125; else &#123; this.displayDialog = false; &#125; &#125;&#125; 若將file之類的元件放在dialog中，開啟的時候會觸發一個dection change的錯誤，但這個其實不會真的影響功能操作，只是會讓你看起來不開心QQ，當初遇到這個問題時還有去開issue只是官方沒人理我TAT FileUpload在使用這個元件的時候，因為畫面的關係，所以採用mode=&quot;basic&quot;，但是這會引發一些狀況，像是maxFileSize上傳的檔案太大應該要提示訊息，但這種模式下不會…TAT 另外，每次上傳完都要將資料清除，不然再次按上傳的時候，會沒辦法選取直接傳前一次檔案 1234567891011121314@Component()export class MyComponent implements OnInit&#123; @ViewChild(FileUpload) fileUpload: FileUpload; ngOnInit()&#123; &#125; uploadFile(event) &#123; this.fileService.uploadFile(this.id, this.type, event.files) .subscribe(fileIds =&gt; &#123; this.fileUpload.clear(); &#125;); &#125;&#125; DataTable這邊我們用的是DataTable而不是新的TurboTable，就只是因為當時只有一個可以用沒得選XD，這個元件其實蠻多小地方要注意的，很容易萬劫不復阿QQ 官方已經不再維護DataTable這個元件了…請大家轉用TurboTable Sort在官方範例中，sort很簡單，就是在column中，加上sortable這個屬性，但如果你有搭配headerColumnGroup，那就要注意一下放的位置，除了在下面的column要放field以外，也要在header中的column加上field，這樣元件才會知道要排序data中的哪個欄位 1234567891011121314151617181920212223&lt;p-dataTable [value]=&quot;sales&quot;&gt; &lt;p-headerColumnGroup&gt; &lt;p-row&gt; &lt;p-column header=&quot;Brand&quot; rowspan=&quot;2&quot;&gt;&lt;/p-column&gt; &lt;p-column header=&quot;Sale Rate&quot; colspan=&quot;4&quot;&gt;&lt;/p-column&gt; &lt;/p-row&gt; &lt;p-row&gt; &lt;!-- 正確寫法 --&gt; &lt;p-column header=&quot;Last Year&quot; [sortable]=&quot;true&quot; field=&quot;lastYearSale&quot;&gt;&lt;/p-column&gt; &lt;!-- 錯誤寫法 --&gt; &lt;p-column header=&quot;This Year&quot; [sortable]=&quot;true&quot;&gt;&lt;/p-column&gt; &lt;p-column header=&quot;Last Year&quot;&gt;&lt;/p-column&gt; &lt;p-column header=&quot;This Year&quot;&gt;&lt;/p-column&gt; &lt;/p-row&gt; &lt;/p-headerColumnGroup&gt; &lt;p-column field=&quot;brand&quot;&gt;&lt;/p-column&gt; &lt;p-column field=&quot;lastYearSale&quot;&gt;&lt;/p-column&gt; &lt;p-column field=&quot;thisYearSale&quot;&gt;&lt;/p-column&gt; &lt;p-column field=&quot;lastYearProfit&quot;&gt;&lt;/p-column&gt; &lt;p-column field=&quot;thisYearProfit&quot;&gt;&lt;/p-column&gt;&lt;/p-dataTable&gt; 另外一個要特別注意的點，就是資料的型別要統一，不然排序也會亂掉 這邊提供一個我做出來的範例，可以發現點year那個欄位，VM這筆資料竟然獨立在那邊，其實原因很簡單，資料中有null、undefine、number三種形態，所以對元件來說會把VM那筆獨立排 123456789101112[&#123;&quot;brand&quot;: &quot;VW&quot;, year: null, &quot;color&quot;: &quot;Orange&quot;, &quot;vin&quot;: &quot;dsad231ff&quot;&#125;,&#123;&quot;brand&quot;: &quot;Audi&quot;, &quot;color&quot;: &quot;Black&quot;, &quot;vin&quot;: &quot;gwregre345&quot;&#125;,&#123;&quot;brand&quot;: &quot;Renault&quot;, &quot;year&quot;: 2005, &quot;color&quot;: &quot;Gray&quot;, &quot;vin&quot;: &quot;h354htr&quot;&#125;,&#123;&quot;brand&quot;: &quot;BMW&quot;, &quot;year&quot;: 2003, &quot;color&quot;: &quot;Blue&quot;, &quot;vin&quot;: &quot;j6w54qgh&quot;&#125;,&#123;&quot;brand&quot;: &quot;Mercedes&quot;, &quot;year&quot;: 1995, &quot;color&quot;: &quot;Orange&quot;, &quot;vin&quot;: &quot;hrtwy34&quot;&#125;,&#123;&quot;brand&quot;: &quot;Volvo&quot;, &quot;color&quot;: &quot;Black&quot;, &quot;vin&quot;: &quot;jejtyj&quot;&#125;,&#123;&quot;brand&quot;: &quot;Honda&quot;, &quot;year&quot;: 2012, &quot;color&quot;: &quot;Yellow&quot;, &quot;vin&quot;: &quot;g43gr&quot;&#125;,&#123;&quot;brand&quot;: &quot;Jaguar&quot;, &quot;color&quot;: &quot;Orange&quot;, &quot;vin&quot;: &quot;greg34&quot;&#125;,&#123;&quot;brand&quot;: &quot;Ford&quot;, &quot;year&quot;: 2000, &quot;color&quot;: &quot;Black&quot;, &quot;vin&quot;: &quot;h54hw5&quot;&#125;,&#123;&quot;brand&quot;: &quot;Fiat&quot;, &quot;year&quot;: 2013, &quot;color&quot;: &quot;Red&quot;, &quot;vin&quot;: &quot;245t2s&quot;&#125;] Edit行內編輯官方給的範例中，edit的功能只能一個欄位一個欄位的編輯，但如果想要的是整個row一起開放編輯，並且有儲存那些的功能怎麼辦？ 這樣的功能我是自己刻，用一個屬性來控制現在是編輯還是檢視 1234567891011121314&lt;p-dataTable [value]=&quot;sales&quot; [rowStyleClass]=&quot;checkHighlight&quot;&gt; &lt;p-column&gt; &lt;ng-template pTemplate=&quot;body&quot; let-row=&quot;rowData&quot;&gt; &lt;button *ngIf=&quot;!row.isEdit&quot; (click)=&quot;row.isEdit=true&quot;&gt;Delete&lt;/button&gt; &lt;button *ngIf=&quot;row.isEdit&quot; (click)=&quot;save(row)&quot;&gt;Save&lt;/button&gt; &lt;/ng-template&gt; &lt;/p-column&gt; &lt;p-column field=&quot;brand&quot; header=&quot;brand&quot;&gt; &lt;ng-template pTemplate=&quot;body&quot; let-col let-row=&quot;rowData&quot;&gt; &lt;span *ngIf=&quot;!row.isEdit&quot;&gt;&#123;&#123;row[col.field]&#125;&#125;&lt;/span&gt; &lt;input type=&quot;text&quot; *ngIf=&quot;row.isEdit&quot; pInputText [(ngModel)]=&quot;row[col.field]&quot;&gt; &lt;/ng-template&gt; &lt;/p-column&gt;&lt;/p-dataTable&gt; 編輯highlight那如果說有需要在編輯的模式中，讓row是呈現被選取的樣式，可以使用rowStyleClass，可以透過這個方法來指定class 123456@Component()export class MyComponent &#123; checkHighlight(row)&#123; return row.isEdit ? &#x27;highlight&#x27; : &#x27;&#x27;; &#125;&#125; 目前頁的rowIndex因為我們會有個需求是要新增資料，但如果用splice到第一筆，但是使用者切換到第二頁，會看不到可以編輯的那筆row，翻了文件才發現有這個屬性first，這個的值是這頁的第一筆index 依照剛剛的案例，這時候first會等於10，這時候就可以有兩種作法，第一種是把新的資料直接insert到10的位置，或者是把first改成0，在這邊我是使用第一個方法 一開始要指定first為0，不然會沒資料 Lazy在一個feature中，我不小心加上了這個設定，然後資料明明已經寫入超過一頁的量，但畫面永遠只顯示一頁（就爆炸了TAT） 去看了官方文件才發現原來是誤會他的功能，這是用來解決大量資料時透過api來取得分頁資料的功能 以這個範例來看，要使用lazy的功能就必須要套用三個屬性&#x2F;方法lazy、totalRecords、onLazyLoad，透過這樣的搭配來取得每頁的資料 12345678&lt;p-dataTable [value]=&quot;cars&quot; [lazy]=&quot;true&quot; [rows]=&quot;10&quot; [paginator]=&quot;true&quot; [rowsPerPageOptions]=&quot;[5,10,20]&quot; [totalRecords]=&quot;totalRecords&quot; (onLazyLoad)=&quot;loadCarsLazy($event)&quot;&gt; &lt;p-header&gt;List of Cars&lt;/p-header&gt; &lt;p-column field=&quot;vin&quot; header=&quot;Vin&quot;&gt;&lt;/p-column&gt; &lt;p-column field=&quot;year&quot; header=&quot;Year&quot;&gt;&lt;/p-column&gt; &lt;p-column field=&quot;brand&quot; header=&quot;Brand&quot;&gt;&lt;/p-column&gt; &lt;p-column field=&quot;color&quot; header=&quot;Color&quot;&gt;&lt;/p-column&gt;&lt;/p-dataTable&gt; 2018&#x2F;05&#x2F;23 做後續補充…拖有點久QQ Selection同事回報的問題，假設目前selectedList有三筆資料，現在重新取得model，selectedList是不會被清除的，而且還會比對不到任何資料所以就不會被選取，因為這時候的物件和前一次不同， 這個行為我不是很確定算不算問題 12&lt;p-dataTable [value]=&quot;model&quot; [(selection)]=&quot;selectedList&quot;&gt;&lt;/p-dataTable&gt; Scroll想要做到固定表頭或是固定前面欄位，可以使用這個功能，但是在設定的時候，發現很容易整個崩壞跑版，尤其是有用到group的功能情況下 目前知道必須要寫死欄位寬高才有辦法比較正常顯示，如果是希望能夠根據資料自動長大的話就… Dropdown1&lt;p-dropdown [options]=&quot;reasonList&quot; [autoWidth]=&quot;false&quot; placeholder=&quot;請選擇&quot; appendTo=&quot;body&quot; formControlName=&quot;versionReason&quot;&gt;&lt;/p-dropdown&gt; 如果資料是透過api取得，這時候因為option還沒有任何東西，所以寬度會變得很小要等到點了下拉選單才會變寬，所以要加上autoWidth=false就可以避免寬度自動縮放。 另外，如果是把dropdown放在dialog裡面，而且下拉選單會超過dialog大小，這時候會發現下拉選單被吃掉了！這時候要加上appendTo=&quot;body&quot;這個設定，讓下拉選單的z-index提高 結論其實primeng已經可以符合大部分的使用情境，只是有時候官方文件也許寫的沒有很清楚，那跑去看source code(open source 好處XD)或論壇會比較快 primeng團隊也持續的在開發新元件，也不太需要怕沒有人維護，有什麼好的想法也能提供給他們，一起來讓這個元件更好吧！ 讀書會分享時，大家的回響讓我勾起回憶，再補上一些 2018&#x2F;05&#x2F;23 再補上一些內容","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"[Angular] 自訂Validator-password format、repeat","slug":"angular-validator","date":"2018-02-17T15:08:09.000Z","updated":"2023-03-09T14:18:38.659Z","comments":true,"path":"2018/02/17/angular-validator/","link":"","permalink":"http://jiaming0708.github.io/2018/02/17/angular-validator/","excerpt":"前言在寫Angular專案時，只要遇到表單的部份，通常都會使用驗證的機制來輔助使用者輸入，並且提示訊息，Angular團隊也已經寫好一些驗證的pattern讓我們使用，但總是會有些特殊的格式，勢必要自己寫，這邊來跟大家分享一下作法。","text":"前言在寫Angular專案時，只要遇到表單的部份，通常都會使用驗證的機制來輔助使用者輸入，並且提示訊息，Angular團隊也已經寫好一些驗證的pattern讓我們使用，但總是會有些特殊的格式，勢必要自己寫，這邊來跟大家分享一下作法。 底下範例將採用reactive form的方式來介紹 範例密碼格式最簡單的寫法是直接在formControl後面加上pattern，如果只有一個用到，那這樣寫其實就可以，但如果說有重複用到這樣就不適合。 12345ngOnInit()&#123; this.form = this.fb.group(&#123; password: [&#x27;&#x27;, [Validators.required, Validators.pattern(&#x27;^(?=.*[0-9])(?=.*[a-zA-Z]).&#123;6,&#125;$&#x27;)]] &#125;);&#125; 因此我們可以將程式抽出來變成一個function，然後呼叫使用。 這邊要注意一下，當驗證成功是要回傳null，驗證失敗時可以回傳一個物件，這個物件的內容自訂，像是底下的範例，是給password=true這可以用在html決定是否提示錯誤的內容。 12345678910ngOnInit()&#123; this.form = this.fb.group(&#123; password: [&#x27;&#x27;, [Validators.required, this.password]] &#125;);&#125;password(control: AbstractControl): ValidationErrors | null &#123; const pattern = /^(?=.*[0-9])(?=.*[a-zA-Z]).&#123;6,&#125;$/; return pattern.test(control.value) ? null : &#123; &#x27;password&#x27;: true &#125;;&#125; 1234&lt;form [formGroup]=&quot;form&quot;&gt; &lt;input type=&quot;password&quot; formControlName=&quot;password&quot;&gt; &lt;span *ngIf=&quot;form.get(&#x27;password&#x27;).errors?.password&quot;&gt;密碼必須六位數且包含英數字。&lt;/span&gt;&lt;/form&gt; 確認密碼檢查這邊提供兩種方式，第一種是在formGroup，第二種是在formControl 個人偏好第一種，寫法乾淨 在formGroup加上validator，並且傳入兩個controlName，作為判別 12345678910111213141516171819export class CustomValidator&#123; static match(firstControlName: string, secondControlName: string) &#123; return (control: AbstractControl): &#123; [key: string]: any &#125; =&gt; &#123; const firstControl = control.get(firstControlName); const secondControl = control.get(secondControlName); if (firstControl.value !== secondControl.value) &#123; secondControl.setErrors(&#123; &#x27;match&#x27;: true &#125;); &#125; else &#123; return null; &#125; &#125;; &#125;&#125;this.resetForm = this.fb.group(&#123; password: [&#x27;&#x27;, Validators.required], confirmPassword: [&#x27;&#x27;, Validators.required]&#125;, &#123;validator: CustomValidator.match(&#x27;password&#x27;, &#x27;confirmPassword&#x27;)&#125;); 這邊使用另一種寫法，回傳ValidatorFn，有別於直接回傳驗證結果，是為了要能夠傳參數進去 在重複輸入formControl上，傳入比對的controlName，這邊處理上比較麻煩一點，我們要先假設一下情境 正常情況下，先輸入password，然後再輸入confirmPassword，這時的驗證就是看自己和比對有沒有一致就好。 但可能會是兩邊都輸入完而且驗證也過了，但去改了password，這時的驗證應該要重新跑過，因此我們需要監聽比對的值變更來讓自己的驗證重新執行，因此要用到updateValueAndValidity這個功能 12345678910111213141516171819202122export class CustomValidator&#123; static repeat(controlName: string): ValidatorFn &#123; let otherControl: AbstractControl; return (control: AbstractControl): &#123; [key: string]: any &#125; =&gt; &#123; if (!control.parent) &#123; return null; &#125; if (!otherControl) &#123; otherControl = control.parent.get(controlName); otherControl.valueChanges.subscribe(p =&gt; control.updateValueAndValidity()); &#125; return otherControl.value !== control.value ? &#123; &#x27;match&#x27;: true &#125; : null; &#125;; &#125;&#125;this.form = this.fb.group(&#123; password: [&#x27;&#x27;, Validators.required], confirmPassword: [&#x27;&#x27;, [Validators.required, CustomValidator.repeat(&#x27;password&#x27;)]]&#125;); 參考 官網介紹 CUSTOM VALIDATORS IN ANGULAR Advanced Validation with Angular Reactive Forms","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"[Angular] 下載image並顯示","slug":"angular-download","date":"2018-02-12T16:29:29.000Z","updated":"2023-03-09T14:18:38.655Z","comments":true,"path":"2018/02/12/angular-download/","link":"","permalink":"http://jiaming0708.github.io/2018/02/12/angular-download/","excerpt":"緣起最近公司的產品有一個需求，是要讓使用者自行更換網頁的圖片，所以就有上傳下載圖片的需求，後端API是直接看上傳什麼格式就下載什麼內容，但是這樣的資料其實在angular中是需要加工才能使用的，來記錄一下作法，廢話不多說上code","text":"緣起最近公司的產品有一個需求，是要讓使用者自行更換網頁的圖片，所以就有上傳下載圖片的需求，後端API是直接看上傳什麼格式就下載什麼內容，但是這樣的資料其實在angular中是需要加工才能使用的，來記錄一下作法，廢話不多說上code Download這種檔案的下載，後端吐回來其實是blob，所以必須要將httpclient指定類型 1this.http.get(url, &#123; responseType: &#x27;blob&#x27; &#125;); 收到blob的資料後，要轉換成圖片其實有兩種作法，我比較偏好地一種，大家可以根據自己需求來使用 url使用window的URL.createObjectURL這個api將檔案直接由瀏覽器暫存於記憶體中，只要使用一個短短的url就可以做使用，免去漏漏長的字串 限定於ie10+使用，萬惡的IE… 1234567891011this.http.get(url, &#123; responseType: &#x27;blob&#x27; &#125;) .pipe( map(data =&gt; &#123; // 避免沒檔案回傳卻還是產生url然後變成叉燒包 if (data.size &gt; 0) &#123; const urlCreator = window.URL; return this.sanitizer.bypassSecurityTrustUrl(urlCreator.createObjectURL(data)); &#125; else &#123; return undefined; &#125; &#125;)); base64這個傳統的作法其實也叫做data uri schema，就是內容會比較肥大一點，但好處就是瀏覽器都支援 1234567891011121314this.http.get(url, &#123; responseType: &#x27;blob&#x27; &#125;) .pipe( mergeMap(data =&gt; Observable.create(obs =&gt; &#123; if (data.size &gt; 0) &#123; const reader = new FileReader(); const reader = new FileReader(); reader.onload = function () &#123; obs.next(reader.result); &#125;; reader.readAsDataURL(data); &#125; else &#123; obs.next(undefined); &#125; &#125;)));","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"docker初介紹","slug":"docker-introduction","date":"2018-01-08T12:46:53.000Z","updated":"2023-03-09T14:18:38.655Z","comments":true,"path":"2018/01/08/docker-introduction/","link":"","permalink":"http://jiaming0708.github.io/2018/01/08/docker-introduction/","excerpt":"Why身為開發者的你也許常常碰到以下的情況","text":"Why身為開發者的你也許常常碰到以下的情況 每個人的電腦環境都不同，常常說在我電腦上是好的，但在production或是同事的環境就是有問題 新同事進來要重新setup一個全新的環境，然後又跟其他人不同 mac、window跑起來不同 模擬環境非常的困難 其實簡單講起來，就是因為環境的不同，很容易造成偵錯或是開發上的困擾，要解決這個問題，最簡單的作法就是把環境統一，這樣就不會那麼多的理由和藉口可以去說嘴 在以往可能會選擇使用VM來解決這個問題，但是一個vm動輒好幾G，常常光要複製就是一個困擾，而且開發上也用不到很多東西，因此我們需要更輕量的一個解決方案docker What簡單說就是虛擬機器，進階一點的說是輕量的虛擬機器；與傳統VM有什麼不同呢，可以透過下圖來做檢視，container少了一層，交由docker來實作這個部分 Howdockerg是由container、image這兩個組合起來的變形金剛（誤），那接著來介紹一下這兩個玩意 image透過指令將所需要的環境先寫好，container就可以直接使用這些所寫好的image來執行 container用來裝載image，並且每個container是獨立的不會互相影響 不可變 輕量 快速 一次性 指令式(CI!!) Use就讓我們開始進入docker的世界吧！ dockerfile除了可以直接上docker hub下載以外，當然也可以自己產生image（自己的內容自己做）指定基底的image，再來就是開始安裝我們需要的東西 12345678FROM node:8# 執行安裝RUN yarn global add @angular/cliRUN ng -v# 指定工作路徑WORKDIR /app# 複製檔案到containerADD ./src /app commanddocker是用go語言基於linux系統開發出來，所以就是滿滿的指令，而且寫的時候也要對image的環境指令有一定熟悉度，弄起來才不會一直碰壁…(苦主QQ) build寫好的dockerfile產生成為image；產生一個叫做angular的image docker build -t angular . run將container啟動並且執行指令；指定本機4000的port連接到4200，並且執行ng serve的指令 docker run -p 4000:4200 angular ng serve docker compose可以定義與執行多個container，只要用簡單的指令，來完成全部的事情(懶人專用…把指令都寫好只要呼叫就好) docker-compose up yaml透過docker-compose.yml可以事先設定好上面所輸入的那些docker指令 123456789101112version: &#x27;3&#x27;services: dev: build: . ports: - &quot;4200:4200&quot; command: ng serve -host 0.0.0.0 prod: build: . ports: - &quot;80:4200&quot; command: ng serve -host 0.0.0.0 --prod conclusiondocker是一個hen方便的工具，除了讓你快速複製環境，還能跟CI做個搭配，資源還不會吃太多，一起跳坑吧！","categories":[{"name":"Docker","slug":"Docker","permalink":"http://jiaming0708.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://jiaming0708.github.io/tags/Docker/"}]},{"title":"[AgnularJS] 與RxJS結合-監聽model變動","slug":"angularJS-rxjs","date":"2017-11-30T13:26:02.000Z","updated":"2023-03-09T14:18:38.655Z","comments":true,"path":"2017/11/30/angularJS-rxjs/","link":"","permalink":"http://jiaming0708.github.io/2017/11/30/angularJS-rxjs/","excerpt":"前情提要前陣子在公司的舊有專案有個需求，是要做AutoComplete的效果，那時候第一時間腦袋就是浮現了RxJS，用其他作法不是不行，只是剛好學了Rx就是想要用看看（其實想炫技～大誤）","text":"前情提要前陣子在公司的舊有專案有個需求，是要做AutoComplete的效果，那時候第一時間腦袋就是浮現了RxJS，用其他作法不是不行，只是剛好學了Rx就是想要用看看（其實想炫技～大誤） angularJS: 1.5.5RxJS: 5.5.2 AngularJS+RxJSRx.Angular.JS決定好要使用以後先搜尋看看這相關的資料，沒想到竟然有整合好的套件rx.angular.js，那當然就是馬上npm來用用看啦但這個套件其實已經很久沒維護，RxJS也沒有更新，所以奉勸想要用的朋友請三思！ RxJS還是直接安裝原生的最快（這邊不談論bundle大小的問題…），在使用的頁面中直接import就可以使用! npm install rxjs ngModel+RxJSRxJS可以用事件進行監聽，這作法會類似於原生js的寫法，但在angularJS的世界中，因為是用ngModel進行資料的雙向繫結，在這件事情上面就會比較麻煩一點 建立一個監聽器使用 $watch 的方式做監聽model的變化，並且將資料透過Observer發送出去 12345678910111213import Rx from &#x27;rxjs/Rx&#x27;Rx.Observable.$watch = (scope, watchExpression, objectEquality) =&gt; &#123; return Rx.Observable.create(observer =&gt; &#123; // 當model變動時，送資料給訂閱者 function listener(newValue, oldValue) &#123; observer.next(&#123; oldValue: oldValue, newValue: newValue &#125;) &#125; // 使用$watch的方式監聽model的變化 return scope.$watch(watchExpression, listener, objectEquality) &#125;)&#125; 開始監聽123Rx.Observable.$watch($scope, () =&gt; this.query.Keyword) .debounceTime(200) .subscribe(p =&gt; console.log(p)); 透過這個作法，只要開始輸入資料就會開始接收到資料，這時候在來搭配後端的api去做查詢的動作，基本上AutoComplete的功能就算是完成 結論AngularJS雖然沒有像Angular一樣完美的結合了RxJS，但要使用上還是沒有問題，而且開始用以後就會停不下來，目前公司的產品已經開始被我慢慢使用，尤其是要多個API串接，然後有順序性那種，使用起來根本就是爽！","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"AngularJS","slug":"Frontend/AngularJS","permalink":"http://jiaming0708.github.io/categories/Frontend/AngularJS/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://jiaming0708.github.io/tags/AngularJS/"},{"name":"RxJS","slug":"RxJS","permalink":"http://jiaming0708.github.io/tags/RxJS/"}]},{"title":"前端測試框架-Jasmine&Protractor介紹","slug":"jasmine-protractor","date":"2017-10-17T14:23:44.000Z","updated":"2023-03-09T14:18:38.655Z","comments":true,"path":"2017/10/17/jasmine-protractor/","link":"","permalink":"http://jiaming0708.github.io/2017/10/17/jasmine-protractor/","excerpt":"今天要來談談兩個前端的測試框架，可以被使用在任何的前端網站開發中，當然也被應用在angular-cli中，但今天的內容其實不會搭配angular來做說明，而是以可以被獨立使用的工具","text":"今天要來談談兩個前端的測試框架，可以被使用在任何的前端網站開發中，當然也被應用在angular-cli中，但今天的內容其實不會搭配angular來做說明，而是以可以被獨立使用的工具 Jasmine Protractor Jasmine一套JS的測試framework，從2009年開始到現在，是一套非常老牌的框架，就直接來看看該怎麼使用 1234# install jasminenpm install --save-dev jasmine#Initialize Jasmine in your project./node_modules/.bin/jasmine init 設定package.json 123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;jasmine&quot;&#125; 接著產生一個測試檔案spec/first.spec.js 123456describe(&#x27;first test&#x27;, () =&gt; &#123; it(&#x27;hello jasmine&#x27;, () =&gt; &#123; expect(true).toBe(true); expect(false).not.toBe(true); &#125;);&#125;); npm test 執行完上面的指令，可以得到第一次的測試成功 describe 將關連的規格做群組的功能(允許巢狀) it 描述規格內容 expect 測試的實際值 toBe 判斷是否與前面的實際值相同 not 反向指令 上面的範例就是jasmine的固定格式，只是說我們要透過不同的Matchers來做為測試的手法，接著就來介紹常用的Matchers MacherstoEqual1234it(&quot;toEqual&quot;, function () &#123; let a = 12; expect(a).toEqual(12);&#125;); toBeLessThan&#x2F;toBeGreaterThan123456it(&quot;toBeLessThan &amp; toBeGreaterThan&quot;, function () &#123; let pi = 3.1415926; let e = 2.78; expect(e).toBeLessThan(pi); expect(e).not.toBeGreaterThan(pi);&#125;); toThrow&#x2F;toThrowError12345678910it(&quot;toThrow &amp; toThrowError&quot;, function () &#123; var foo = function () &#123; throw new TypeError(&quot;foo bar baz&quot;); &#125;; expect(foo).toThrow(); expect(foo).toThrowError(&quot;foo bar baz&quot;); expect(foo).toThrowError(/bar/); expect(foo).toThrowError(TypeError); expect(foo).toThrowError(TypeError, &quot;foo bar baz&quot;);&#125;); 當然還有更多的Machers，也可以到官網文件查看，接著來看蠻常用到的功能Global功能 GlobalbeforeEach&#x2F;afterEach每個it在跑的時候都是獨立的事件，如果有些動作是要在每個it都要跑一樣的，那就可以使用這個功能例如：網站登入的動作 1234567891011121314151617181920describe(&quot;A spec using beforeEach and afterEach&quot;, function () &#123; var foo = 0; beforeEach(function () &#123; foo += 1; &#125;); afterEach(function () &#123; foo = 0; &#125;); it(&quot;is just a function, so it can contain any code&quot;, function () &#123; expect(foo).toEqual(1); &#125;); it(&quot;can have more than one expectation&quot;, function () &#123; expect(foo).toEqual(1); expect(true).toEqual(true); &#125;);&#125;); beforeAll&#x2F;afterAll類似於beforeEach的功能，但beforeAll只會在整個describe中執行一次 12345678910111213141516171819describe(&quot;A spec using beforeAll and afterAll&quot;, function () &#123; var foo = 0; beforeAll(function () &#123; foo += 1; &#125;); afterAll(function () &#123; foo = 0; &#125;); it(&quot;sets the initial value of foo before specs run&quot;, function () &#123; expect(foo).toEqual(1); &#125;); it(&quot;does not reset foo between specs&quot;, function () &#123; expect(foo).toEqual(1); &#125;);&#125;); xit&#x2F;xdescribedisable it&#x2F;describe fit&#x2F;fdescribe只執行it&#x2F;describe Spies在測試中，mock的手法蠻常用到(在jasmine中是叫做spy)，尤其是要呼叫api或是使用第三方套件時，那些function我們認為是正確的，所以不希望把那些包進來測試，就做模擬的方式取代掉真實的呼叫，專注於我們自己所要測試的功能上 1234567891011121314151617181920212223242526272829describe(&quot;A spy&quot;, function() &#123; var foo, bar = null; beforeEach(function() &#123; foo = &#123; setBar: function(value) &#123; bar = value; &#125; &#125;; spyOn(foo, &#x27;setBar&#x27;); foo.setBar(123); foo.setBar(456, &#x27;another param&#x27;); &#125;); it(&quot;tracks that the spy was called&quot;, function() &#123; expect(foo.setBar).toHaveBeenCalled(); &#125;); it(&quot;tracks all the arguments of its calls&quot;, function() &#123; expect(foo.setBar).toHaveBeenCalledWith(123); expect(foo.setBar).toHaveBeenCalledWith(456, &#x27;another param&#x27;); &#125;); it(&quot;stops all execution on a function&quot;, function() &#123; expect(bar).toBeNull(); &#125;);&#125;); toHaveBeenCalled 檢查是否真的有被呼叫過，toHaveBeenCalledWith() 是否符合呼叫function的參數列表 透過spyOn將setBar這個function做模擬，因此在這段的測試中，bar的值依舊是null，這個作法是完全攔截，而且沒有任何回傳結果，但我們通常應該會有一些輸出結果，就可以採用and.returnValue或是and.callFake 12345678910111213141516171819202122232425262728293031323334353637describe(&quot;A spy, when configured to fake a return value&quot;, function() &#123; var foo, bar, fetchedBar; beforeEach(function() &#123; foo = &#123; setBar: function(value) &#123; bar = value; &#125;, getBar: function() &#123; return bar; &#125;, getBar1: function() &#123; return bar; &#125; &#125;; spyOn(foo, &quot;getBar&quot;).and.returnValue(745); spyOn(foo, &quot;getBar1&quot;).and.callFake(function() &#123; return 1001; &#125;); foo.setBar(123); fetchedBar = foo.getBar(); &#125;); it(&quot;should not effect other functions&quot;, function() &#123; expect(bar).toEqual(123); &#125;); it(&quot;when called returns the requested value&quot;, function() &#123; expect(fetchedBar).toEqual(745); &#125;); it(&quot;when called returns the requested value&quot;, function() &#123; expect(foo.getBar1()).toEqual(1001); &#125;);&#125;); Protractor由angular官方出的一套end-to-end(e2e)的framework，測試期間會開啟一個瀏覽器去執行所要測試的項目，如果是使用angular-cli所產生的專案，預設就已經包含，設定放在根目錄底下的protractor.conf.js 但今天說好不管angular-cli的，因此我們要自己安裝 1234npm install -g protractorwebdriver-manager updatewebdriver-manager start#http://localhost:4444/wd/hub 接著必須要有一個設定檔conf.js，並且寫好測試檔spec.js 123456//conf.jsexports.config = &#123; framework: &#x27;jasmine&#x27;, seleniumAddress: &#x27;http://localhost:4444/wd/hub&#x27;, specs: [&#x27;spec.js&#x27;]//測試規格檔&#125; framework 在這邊我使用了jasmine，但如果有其他習慣的框架也是能夠使用的 Mocha Cucumber Serenity&#x2F;JS 12345678// spec.jsdescribe(&#x27;Protractor Demo App&#x27;, function() &#123; it(&#x27;should have a title&#x27;, function() &#123; browser.get(&#x27;http://juliemr.github.io/protractor-demo/&#x27;); expect(browser.getTitle()).toEqual(&#x27;Super Calculator&#x27;); &#125;);&#125;); protractor conf.js 好的，做完上面的動作，已經得到第一次的測試，也可以看到protractor開啟了網頁，並且拿到網頁上的內容做測試，這就是這套工具所提供的功能! browser.get 載入網頁 browser.getTitle 取得網站title 到這邊做過第一次測試，但這種不是我們平常會做的測試，因此我們拿上面的網站，來進行內容的測試，首先要取得畫面中的輸入框，並且填入數字 12345678910describe(&#x27;Protractor Demo App&#x27;, function () &#123; beforeEach(() =&gt; &#123; browser.get(&#x27;http://juliemr.github.io/protractor-demo/&#x27;); &#125;) it(&#x27;first input&#x27;, () =&gt; &#123; let first = element(by.css(&#x27;.input-small&#x27;)); first.sendKeys(&#x27;2&#x27;); expect(first.getAttribute(&#x27;value&#x27;)).toEqual(&#x27;2&#x27;); &#125;);&#125;); sendKeys(&#39;2&#39;) 模擬鍵盤並且送出2，getAttribute(&#39;value&#39;) 取得value的屬性 顯然我們只取得第一個輸入框，但畫面中有兩個輸入框，接著調整一下作法 123456789it(&#x27;two input&#x27;, () =&gt; &#123; let els = element.all(by.css(&#x27;.input-small&#x27;)); let first = els.get(0); // let first = els.first(); same as get(0) first.sendKeys(&#x27;2&#x27;); let sec = els.get(1); // let sec = els.last(); same as get(1) sec.sendKeys(&#x27;4&#x27;);&#125;); element.all 取得所有符合條件的element，get(0)、first()、last() 取得指定的element 填入兩個輸入框的值後，就可以按下按鈕，並且取得結果 123456789101112it(&#x27;calculate&#x27;, () =&gt; &#123; let els = element.all(by.css(&#x27;.input-small&#x27;)); let first = els.get(0); // let first = els.first(); same as get(0) first.sendKeys(&#x27;2&#x27;); let sec = els.get(1); // let sec = els.last(); sec.sendKeys(&#x27;4&#x27;); element(by.id(&#x27;gobutton&#x27;)).click(); expect($(&#x27;h2&#x27;).getText()).toEqual(&#x27;6&#x27;);&#125;) by.id(&#39;gobutton&#39;) id&#x3D;’gobutton’的選擇器，click() 產生click行為，$(&#39;h2&#39;) 使用jquery的寫法取得特定tag name的element，getText() 取得element的內文 執行完上面的測試案例，結果跟預期的一樣，恭喜測試完成！🥂接著回過頭來看一下在protractor中比較重要的幾個物件 browser 透過WebDriver操作瀏覽器，像是開啟網頁 element 存取網頁的element by 選擇器 今天的demo程式github連結 參考 angular test guide jasmine protractor","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Testing","slug":"Frontend/Testing","permalink":"http://jiaming0708.github.io/categories/Frontend/Testing/"}],"tags":[{"name":"Testing","slug":"Testing","permalink":"http://jiaming0708.github.io/tags/Testing/"},{"name":"Jasmine","slug":"Jasmine","permalink":"http://jiaming0708.github.io/tags/Jasmine/"},{"name":"Protractor","slug":"Protractor","permalink":"http://jiaming0708.github.io/tags/Protractor/"}]},{"title":"[Angular] ViewChild遇上ngIf","slug":"angular-viewchild-ngif","date":"2017-09-14T07:20:01.000Z","updated":"2023-03-09T14:18:38.655Z","comments":true,"path":"2017/09/14/angular-viewchild-ngif/","link":"","permalink":"http://jiaming0708.github.io/2017/09/14/angular-viewchild-ngif/","excerpt":"當我們有一個child component想要用ViewChild的方法在parent component取得物件，但如果在上面加上ngIf的時候，取得物件的這個動作就會發現根本取不到!!!","text":"當我們有一個child component想要用ViewChild的方法在parent component取得物件，但如果在上面加上ngIf的時候，取得物件的這個動作就會發現根本取不到!!! 在app.component中，使用todo.component，並且加上ngIf作為控制是否顯示 1234&lt;button (click)=&quot;setFlag(!flag)&quot;&gt;toggle flag&lt;/button&gt;&lt;app-todo *ngIf=&quot;flag&quot;&gt;&lt;/app-todo&gt; 在component中，使用ViewChild的方法並且在setFlag中印出物件，就可以發現在這個時候是取不到todo這個物件的，就算是用angularJS常用的setTimeout也是一樣 這個問題應該就是變數還沒反應到html，所以導致根本還沒拿到這個物件 1234567891011export class AppComponent &#123; @ViewChild(TodoComponent) todo: TodoComponent; setFlag(flag) &#123; this.flag = flag; console.log(&#x27;a&#x27;, this.todo); setTimeout(function() &#123; console.log(&#x27;b&#x27;, this.todo); &#125;, 10); &#125;&#125; 解決方案但這樣根本不能拿到物件要怎麼往後處理，那這邊有兩個作法 在child component使用事件作為觸發，當物件被ngIf啟動後，就可以拋出事件 1234567export class TodoComponent implements AfterViewInit &#123; @Output() onInit = new EventEmitter(); ngAfterViewInit() &#123; this.onInit.emit(this); &#125;&#125; 在parent component收到事件後再去操作ViewChild的物件，就可以正常使用 1234&lt;button (click)=&quot;setFlag(!flag)&quot;&gt;toggle flag&lt;/button&gt;&lt;app-todo (onInit)=&quot;trigerTodo($event)&quot; *ngIf=&quot;flag&quot;&gt;&lt;/app-todo&gt; 1234567891011export class AppComponent &#123; @ViewChild(TodoComponent) todo: TodoComponent; setFlag(flag) &#123; this.flag = flag; &#125; trigerTodo(event) &#123; console.log(&#x27;component&#x27;, event); &#125;&#125; ViewChild使用setter，當物件被建立時，就可以在裡面進行操作 123456789export class AppComponent &#123; @ViewChild(TodoComponent) set todo(content: ViewContainerRef) &#123; console.log(&#x27;setter&#x27;, content); &#125; setFlag(flag) &#123; this.flag = flag; &#125;&#125; 結論其實在使用ViewChild的時候，使用ngIf其實是不好的應用，但如果真的要用就必須要繞路一下，也要去了解一下各種使用方法，上面的兩個方法，我個人比較喜歡setter的作法，簡單乾淨! 如果有其他作法或想法歡迎來討論喔!!","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"設定Reverse Proxy在Windows、Mac","slug":"reserve-proxy","date":"2017-09-02T02:26:37.000Z","updated":"2023-03-09T14:18:38.651Z","comments":true,"path":"2017/09/02/reserve-proxy/","link":"","permalink":"http://jiaming0708.github.io/2017/09/02/reserve-proxy/","excerpt":"前言因為測試的需要，protrator-recorder是在local環境中架設走的是http，但公司的測試環境是在https底下，因此會導致無法將protrator-recorder掛載到測試環境中進行錄製，就開始找方法去解決","text":"前言因為測試的需要，protrator-recorder是在local環境中架設走的是http，但公司的測試環境是在https底下，因此會導致無法將protrator-recorder掛載到測試環境中進行錄製，就開始找方法去解決 錯誤訊息是mixed content，讓我一開始找的方向就是把工具架成https，錄製工具總共要起兩個網站，第一個是webdriver，第二個是recorder本身 第一個想法就是針對recorder本身改成https，原生程式是用node的express+http，只要改成https即可，但是問題來了，webdriver這個工具該怎麼架成https，這部份我沒找到資料(如果有人知道麻煩告訴我)，在經過幾番詢問後，kevin給了一個新的方向 reverse proxy Reverse Proxy在開始之前，要先複習一下一般的Proxy功能(也就是Forward Proxy) 透過proxy可以直接連線到無法直接連線的網站，還蠻常應用在要連國外的網站只允許自己國家內的ip；或者是在公司內部不允許對外，就必須要透過proxy來做對外的接口 複習完Proxy後，我們要來看看什麼是Reverse Proxy 從字面上來看就是反向，我們連線到一個網站，但是他透過ReverseProxy去連線到背後真實的網站，那對使用者來說其實沒有影響，因為還是可以連到對的網站進行瀏覽 架設本身有兩個開發環境，mac、windows，底下就針對這兩個環境下怎麼架設來說明一下 Mac在mac環境下可以使用 mitmdump ，照著官方安裝即可 安裝好後，要設定reverse proxy，可以參考這篇，只要在後面加上-r並且給目標https網站即可那我們瀏覽的時候只要連http://localhost即可 mitmdump -R https://httpbin.org -p 80 Windows在mac所用的mitmdump這套軟體，很可惜的在windows只剩下UI版本，沒有command mode，那我們所需要reverse proxy就不知道該怎麼設定，因此要改其他方法 還好強大的微軟(XDDD)在IIS已經先埋好這個功能，要在IIS上使用，必須要先安裝兩個套件 ARR(Application Request Routing) URL Rewrite 系統環境為:(其他環境的操作畫面可能不同!)Win 10IIS 10 安裝完畢後，先進行ARR的設定，將Proxy啟用 接著就可以設定URL Rewrite的設定 這邊要注意一下，重寫URL後面帶的參數，如果錯誤就無法正確導入可以使用測試模式，確認一下內容 參考Microsoft - Reverse Proxy with URL Rewrite v2 and Application Request Routing Microsoft - Creating Rewrite Rules for the URL Rewrite Module Reverse Proxy","categories":[{"name":"IIS","slug":"IIS","permalink":"http://jiaming0708.github.io/categories/IIS/"}],"tags":[{"name":"IIS","slug":"IIS","permalink":"http://jiaming0708.github.io/tags/IIS/"}]},{"title":"[Design Pattern] Observer(觀察者)、Decoractor(裝飾器)","slug":"design-pattern-observer-decorator","date":"2017-08-29T12:17:54.000Z","updated":"2023-03-09T14:18:38.651Z","comments":true,"path":"2017/08/29/design-pattern-observer-decorator/","link":"","permalink":"http://jiaming0708.github.io/2017/08/29/design-pattern-observer-decorator/","excerpt":"今天要來談談不一樣的東西，關於Design Pattern的兩三事，在程式開發中應用了這些模式在撰寫上可以更輕鬆一點，那我們先來看看其中的兩個 Observer 觀察者 Decoractor 裝飾器","text":"今天要來談談不一樣的東西，關於Design Pattern的兩三事，在程式開發中應用了這些模式在撰寫上可以更輕鬆一點，那我們先來看看其中的兩個 Observer 觀察者 Decoractor 裝飾器 Observer Pattern當我們今天要去確認一個目標有沒有新的資料，我們必須要不斷的詢問，不只詢問的人很煩，被問的人也要花費力氣去回應(儘管這可能很輕鬆)，但很多人跟他詢問的時候就會佔用太多時間 那這時候其實我們可以反過來思考，請求者跟目標說，你有新的資料就通知我，這種情況下雙方都會比較輕鬆，那這種模式其實就是Observer Pattern 那我們最常聽到的範例就是跟報社訂報紙，訂戶跟報社訂閱報紙，只要報社一出版就會送到訂戶手上，也就是說訂戶是被動而報社是主動 根據上述的內容，我們來試著實作看看 A new course!!from listener1A new course!!from listener2 Decoractor Pattern今天買了一台摩托車，很帥的想要去把妹，但是缺少了點個性化，所以我們可以加上一些商家已經做好的套件裝上去，例如換沖天排氣管、翹牌器這個精神可以稱作修飾(decoractor) 那接著來實作看看吧 f(): evaluatedg(): evaluatedg(): calledf(): called","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://jiaming0708.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://jiaming0708.github.io/tags/Design-Pattern/"}]},{"title":"[FrontEnd] e2e錄製工具","slug":"e2e-tools","date":"2017-08-17T06:45:54.000Z","updated":"2023-03-09T14:18:38.651Z","comments":true,"path":"2017/08/17/e2e-tools/","link":"","permalink":"http://jiaming0708.github.io/2017/08/17/e2e-tools/","excerpt":"記錄一下，最近找的幾套測試錄製工具","text":"記錄一下，最近找的幾套測試錄製工具 Ranorex UI操作簡單 產生C# code 單價高 TestComplete UI操作不方便 不知道如何產生腳本 Selenium IDE firefox套件，只支援34.*版本(目前5x版) testrec 還在beta 無法產生腳本 protractor-recorder 可以產生protactor腳本 使用IDE錄製，可以在加工","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"e2e","slug":"Frontend/e2e","permalink":"http://jiaming0708.github.io/categories/Frontend/e2e/"}],"tags":[{"name":"e2e","slug":"e2e","permalink":"http://jiaming0708.github.io/tags/e2e/"}]},{"title":"[Angular] Directive介紹","slug":"angular-directive","date":"2017-08-16T02:32:42.000Z","updated":"2023-03-09T14:18:38.651Z","comments":true,"path":"2017/08/16/angular-directive/","link":"","permalink":"http://jiaming0708.github.io/2017/08/16/angular-directive/","excerpt":"為什麼要用Directive，可以幫助我們做到什麼事情?","text":"為什麼要用Directive，可以幫助我們做到什麼事情? directive是一個可以擴充element的行為或是呈現，最常使用的component則是繼承了directive加上template的部份， 這時候我們可以使用directive來幫助我們，把重複的東西抽離出來，並且能夠讓element變得精簡 directive有三種類型 Component Structural Directive Attribute Directive Structural Directive對HTML的結構進行操作，像是隱藏、顯示或是迴圈等的動作。常用的功能有ngIf、ngFor、ngSwitch。 *ngIf代表著是否要顯示dom，這邊隱藏的話是不會去真正的產生element 123456&lt;div *ngIf=&quot;true&quot;&gt;this is show&lt;/div&gt;&lt;div *ngIf=&quot;false&quot;&gt;this is hide&lt;/div&gt;&lt;!--template bindings=&#123; &quot;ng-reflect-ng-if&quot;: null&#125;--&gt; *ngFor迴圈顯示，被包在裡面的html可以自行定義 這邊要注意，當變數是null則會死掉，這時候外面可以包一個*ngIf 123&lt;div *ngFor=&quot;let todo of todoList&quot;&gt; &#123;&#123;todo.name&#125;&#125;&lt;/div&gt; ngSwith樣板有多種需要動態決定顯示哪個時可以使用 123456&lt;div [ngSwitch]=&quot;hero?.emotion&quot;&gt; &lt;happy-hero *ngSwitchCase=&quot;&#x27;happy&#x27;&quot; [hero]=&quot;hero&quot;&gt;&lt;/happy-hero&gt; &lt;sad-hero *ngSwitchCase=&quot;&#x27;sad&#x27;&quot; [hero]=&quot;hero&quot;&gt;&lt;/sad-hero&gt; &lt;confused-hero *ngSwitchCase=&quot;&#x27;confused&#x27;&quot; [hero]=&quot;hero&quot;&gt;&lt;/confused-hero&gt; &lt;unknown-hero *ngSwitchDefault [hero]=&quot;hero&quot;&gt;&lt;/unknown-hero&gt;&lt;/div&gt; 使用*做為前置詞，用來跟其他功能做區隔當然也可以用其他的寫法 12345&lt;div template=&quot;ngIf hero&quot;&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt;&lt;ng-template [ngIf]=&quot;hero&quot;&gt; &lt;div&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt;&lt;/ng-template&gt; Attribute Directive可以改變element的行為或是樣式 ngClass改變element的class，使用陣列的方式或用物件的方式來決定要哪些class要被引用 123456&lt;div [ngClass]=&quot;&#x27;selected&#x27;&quot;&gt;&lt;/div&gt;&lt;div [ngClass]=&quot;[&#x27;selected&#x27;]&quot;&gt;&lt;/div&gt;&lt;div [ngClass]=&#123;&#x27;selected&#x27;:true&#125;&gt;&lt;/div&gt; ngStyle改變element的style內容，與ngClass的用法相同 動手做 現在可以來試試看寫個attribute directive 12345678import &#123; Directive, ElementRef, Input &#125; from &#x27;@angular/core&#x27;;@Directive(&#123; selector: &#x27;[myTodo]&#x27; &#125;)export class TodoDirective &#123; constructor(el: ElementRef) &#123; el.nativeElement.classList.add(&#x27;completed&#x27;); &#125;&#125; selector用法 element-name .class [attribute] [attribute=value] :not(sub_selector) selector1, selector2 @Input&#x2F;@Ouputcomponent之間或是和directive要互相傳遞資料的時候，我們能夠透過input和output的方式來做傳遞。接著來看看如何使用 12345678@Directive(&#123;select: &#x27;[myTodo]&#x27; &#125;)export class TodoDirective&#123; //這是相同的意思 @Input() todo:string; @Input(&#x27;status&#x27;) _status:boolean; //Output只能拋出event喔! @Output() onEventChange = new EventEmitter();&#125; 像上面的例子，如果希望把傳進來的status來改變style狀態，可以這樣做 123456789101112@Directive(&#123;select: &#x27;[myTodo]&#x27; &#125;)export class TodoDirective&#123; @Input(&#x27;status&#x27;) _status:boolean; constructor(el: ElementRef)&#123; if(this._status)&#123; el.nativeElement.classList.add(&#x27;complete&#x27;); &#125; else &#123; el.nativeElement.classList.remove(&#x27;complete&#x27;); &#125; &#125;&#125; 但其實這樣很麻煩，而且只有第一次產生物件時會執行，可以改成用HostBinding的方法來做 1234567@Directive(&#123;select: &#x27;[myTodo]&#x27; &#125;)export class TodoDirective&#123; @Input(&#x27;status&#x27;) @HostBinding(&#x27;class.completed&#x27;) _status:boolean; constructor(el: ElementRef)&#123; &#125;&#125; @HostBinding是用來變更directive所在的那個element的一些屬性，例如：style、class等，那你也許會問可以變更屬性，那能不能監聽element的事件呢？答案是可以的，我們可以來用用@HostListener 12345678910111213@Directive(&#123;select: &#x27;[myTodo]&#x27; &#125;)export class TodoDirective&#123; @Input(&#x27;status&#x27;) @HostBinding(&#x27;class.completed&#x27;) _status:boolean; //Output只能拋出event喔! @Output() onEventChange = new EventEmitter(); @HostListener(&#x27;click&#x27;) onHostClick()&#123; this.el.nativeElement.classList.toggle(&#x27;complete&#x27;); this.onEventChange.emit(); &#125;; constructor(private el: ElementRef)&#123; &#125;&#125; 參考資料官網Jeff筆記","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"[Angular/AngularJS] Exception Handle","slug":"angular-exception","date":"2017-07-24T14:00:20.000Z","updated":"2023-03-09T14:18:38.651Z","comments":true,"path":"2017/07/24/angular-exception/","link":"","permalink":"http://jiaming0708.github.io/2017/07/24/angular-exception/","excerpt":"今天來看一下Angular和AngularJS如何去handle在網站中任一個地方發生的exception想要把這種資料回寫到後端，我們可以怎麼去實作他","text":"今天來看一下Angular和AngularJS如何去handle在網站中任一個地方發生的exception想要把這種資料回寫到後端，我們可以怎麼去實作他 Angular作法在Angular可以攔截在全域未handle到的exception，可以看一下官方文件 只要照著寫一個class implements ErrorHandler就可以最簡單的錯誤就是在呼叫api的時候沒有去handle exception(想辦法讓api呼叫失敗)這時候就會進入到自己寫的那個class中 12345678import &#123; ErrorHandler &#125; from &quot;@angular/core&quot;;export class MyErrorHandler implements ErrorHandler &#123; handleError(error) &#123; //call backend api console.log(`this is my error handle, $&#123;error&#125;`); &#125;&#125; AngularJS作法因為工作上還有用到AngularJS，同事就問到有沒有這種東西於是查詢了一下官方文件 作法跟Angular蠻像的，果然是前後代XD 同樣的照著官方文件做，寫一個factory叫做$exceptionHandler，overwrite原生的handler一樣可以輕鬆的搞定需求 1234567angular.module(&#x27;exceptionModule&#x27;) .factory(&#x27;$exceptionHandler&#x27;, [&#x27;$log&#x27;, function ($log) &#123; return function myExceptionHandler(exception, cause) &#123; //call Backend api $log.error(`my error handler, $&#123;exception&#125;`, cause) &#125; &#125;]);","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://jiaming0708.github.io/tags/AngularJS/"},{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"ReactiveX介紹","slug":"rx","date":"2017-07-05T12:52:33.000Z","updated":"2023-03-09T14:18:38.651Z","comments":true,"path":"2017/07/05/rx/","link":"","permalink":"http://jiaming0708.github.io/2017/07/05/rx/","excerpt":"今天要來探討ReactiveX(底下簡稱Rx)，這個已經紅很久的概念，各語言有各自的實作ex:RxJS、RxJava…我們先來看看Rx是什麼東西，官方給了一個定義composing asynchronous and event-based programs by using observable sequences","text":"今天要來探討ReactiveX(底下簡稱Rx)，這個已經紅很久的概念，各語言有各自的實作ex:RxJS、RxJava…我們先來看看Rx是什麼東西，官方給了一個定義composing asynchronous and event-based programs by using observable sequences 以下範例都將以RxJS為主 從上面的範例中可以看到Rx將事件或是資料的處理方式統一了作法將陣列的資料拆開，然後跟事件一樣一筆一筆的發送出去event-based、sequence 從這邊我們也看到範例中，有Observable、subscribe這兩個東西，到底是什麼 Observable我們用個例子來解釋一下…今天到了一間無菜單料理的餐廳，你坐下來後，服務生就開始陸續的把菜送上來套回Rx上面，Subscribe也就是身為客戶的你，餐廳的廚房就是Observable，廚師變化料理也就是Operator 請忽視價格問題:) 從這個例子能看到一件事情，其實很重要，也就是當沒有客人(Subscribe)來，廚房(Observable)是不會動作的 還是要回歸正提XDD，Rx提供了多種產生的方式，這邊列舉幾個常用的 create產生Observable，可以自行控制資料 其實不常用 透過next不斷的發送資料出去，當要讓subscribe知道已經結束則使用complete若是錯誤則是使用throwcomplete、throw對於observable來說都是結束的意思，後面的動作就不會繼續觸發了 of輸出陣列資料 from將陣列資料拆解，sequence的將資料拋出 fromEvent監聽事件 OperatorOperator就像是煮飯一樣，搭配的好就像是阿基師，搭配不好吃起來就會…(遠目Rx已經準備好許多的配料，可以讓我們自行搭配，底下用幾個來做範例吧 map filter concat merge mergeMap等於merge+map的合體技 看完了上面的介紹，也許有人就會開始想說，那可不可以有多個訂閱者那多個訂閱者收到的資料會是什麼 答案是全部的人收到一模一樣的資料 那這樣一定會有人說，我只想要從訂閱之後的資料就好，我不想要全部的資料subject粉墨登場~~ Subjectsubject是繼承Observable，同時擁有Observable以及Observer兩個特性，並且記錄了狀態，不再每次從頭收到，而是從subscribe之後的值 有時候會需要subscribe時就拿到值，這時候可以用BehaviorSubject 或者是需要拿到最後幾次的輸出，可以使用ReplaySubject 總結Rx是透過Observable實作的一套Library，但他有兩個我認為很重要的特點 沒有subscribe就沒有執行(沒有買賣就沒有傷害…XDD)其他很多程式都是一開始就先執行，如果後面有callback就做，沒有就結束 透過functional programming把每個動作獨立，讓程式閱讀性變高 Operator可以寫的很漂亮也可以寫的很可怕，只能透過練習拆解去學習，才會知道要怎麼用才是適合的 當然還有其他更強大的應用，但我目前都沒有用到，所以只能感受到這樣歡迎大家一起來討論! Reference官網Jerry-30 天精通 RxJSRxMarblesRxJS API Document","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"RxJS","slug":"Frontend/RxJS","permalink":"http://jiaming0708.github.io/categories/Frontend/RxJS/"}],"tags":[{"name":"RxJS","slug":"RxJS","permalink":"http://jiaming0708.github.io/tags/RxJS/"}]},{"title":"[C#] Win Form的DataGridView的button事件","slug":"csharp-datagridview-buttonevent","date":"2017-06-01T12:44:00.000Z","updated":"2023-03-09T14:18:38.651Z","comments":true,"path":"2017/06/01/csharp-datagridview-buttonevent/","link":"","permalink":"http://jiaming0708.github.io/2017/06/01/csharp-datagridview-buttonevent/","excerpt":"說明新公司剛好需要先寫一個winform只好先硬幹了習慣了web form的很多東西，其實win form並沒有像web那樣的方便，或者說他其實更加的彈性很多行為模式都不一樣因此要熟悉一下","text":"說明新公司剛好需要先寫一個winform只好先硬幹了習慣了web form的很多東西，其實win form並沒有像web那樣的方便，或者說他其實更加的彈性很多行為模式都不一樣因此要熟悉一下 其中有個行為其實我們很常用到，那就是在Grid中放了一些元件，然後要觸發事件，像是button的click在DataGridView中，其實沒有那些事件可以直接使用，因此我們要繞點路使用CellContentClick這個事件 來看看MSDN的說明吧 按一下儲存格內的內容時發生。 非常簡短，也非常好懂，就是當儲存格被按到時會觸發也許你會問到，這樣不是目標被按到的時候不就也會進去事件？是的，這也很無奈╮(－_－)╭ 範例讓我們來看一下範例吧 12345678private void DataGridView1_CellContentClick(object sender, DataGridViewCellEventArgs e)&#123; var colname = DataGridViewLicenseList.Columns[e.ColumnIndex].Name if (colname.ToLower() == &quot;edit&quot;) &#123; //do something &#125;&#125; 相似文章關於DataGridView的其他操作，之前也有寫過其他篇 WinForm的DataGridView類似Web的GridView_DataRowBound事件","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[Angular] i18n由淺入深","slug":"angular-i18n","date":"2017-04-24T11:22:15.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2017/04/24/angular-i18n/","link":"","permalink":"http://jiaming0708.github.io/2017/04/24/angular-i18n/","excerpt":"大綱一個要提供給國際使用的網站，一定會遇到多國語系的問題，Angular已經幫我們想好解決方案，i18n，一起進入這個世界探索吧!","text":"大綱一個要提供給國際使用的網站，一定會遇到多國語系的問題，Angular已經幫我們想好解決方案，i18n，一起進入這個世界探索吧! 入門多國語系是網頁必定會遇到的問題，在開始之前，我們先來看一下預期的目標 我們希望畫面上的字能根據語系來做相對應的呈現i18n!!!粉墨登場 首先要在component中加上i18n這個directive 1&lt;h1 i18n&gt;Hello world&lt;/h1&gt; 接著我們要取得檔案，來維護內容，執行這段指令，將檔案放到src底下的locale這個目錄中 ng xi18n –output-path src&#x2F;locale messages.xlf 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;xliff version=&quot;1.2&quot; xmlns=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; &lt;file source-language=&quot;en&quot; datatype=&quot;plaintext&quot; original=&quot;ng2.template&quot;&gt; &lt;body&gt; &lt;trans-unit id=&quot;5816217f424111ae4c91dd72ee1db0ae252763b5&quot; datatype=&quot;html&quot;&gt; &lt;source&gt;Hello World!&lt;/source&gt; &lt;target&gt;世界你好!&lt;/target&gt; &lt;/trans-unit&gt; &lt;/body&gt; &lt;/file&gt;&lt;/xliff&gt; 得到產生的檔案後，就可以來實驗看看囉，執行下面的指令 ng serve –aot –i18n-file&#x3D;src&#x2F;locale&#x2F;messages.xlf –locale&#x3D;en –i18n-format&#x3D;xlf 就可以發現到剛剛的Hello World!被替換成世界你好! 試著用建立另一個語言檔看看 進階讓我們換個指令，來輸出成檔案看看他的運作模式 ng build –prod –i18n-file&#x3D;src&#x2F;locale&#x2F;messages.zh-TW.xlf –locale&#x3D;zh-TW –i18n-format&#x3D;xlf 可以發現到，其實他是直接把html的內容給替換掉了！那這樣是不是說，要產生不同語系，就必須重新編譯一次…!? 這樣的作法不可能應用到網站中，因此我們需要改變一下如果只要架一個網站，就要想辦法將檔案動態載入 首先使用system.import的方式載入檔案，並且載入要在bootstrap之前所以我們可以來看看下面這段，先用固定的語系 接著要在main.ts中載入進來，可以看到的是先把由上面先把檔案載入後，再來bootstrap 但上面我們是用固定的語系，接著我們要做的事情就是動態的語系這邊使用的方法是在網址列加上語系切換下拉選單時，就讓網頁整個重新載入 app.component.html 1234&lt;select (ngModelChange)=&quot;changeLocale($event)&quot; [(ngModel)]=&quot;locale&quot;&gt; &lt;option value=&quot;en&quot;&gt;English&lt;/option&gt; &lt;option value=&quot;zh-tw&quot;&gt;中文&lt;/option&gt;&lt;/select&gt; app.component.ts 123changeLocale(event: string) &#123; window.location.href = `/$&#123;event&#125;/`;&#125; 那我們就可以在getTranslationProviders這個裡面，去解析網址，來取得目前的語系 這時候我們就可以下拉選單來切換語系了!i18n demo 參考Angular i18n introductionDeploying an i18n Angular app with angular-cliAngular 2 internationalization explained: i18n + Angular CLI + AOTLost in Translation - Oliver Combe @ ng-confg 2017","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"ReactNative初體驗","slug":"react-native-note","date":"2017-03-30T07:13:06.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2017/03/30/react-native-note/","link":"","permalink":"http://jiaming0708.github.io/2017/03/30/react-native-note/","excerpt":"最近要和朋友一起寫個app，他們提出了要用react native但完全沒有經驗，只好邊寫邊摸囉分享一下下自己的一點點經驗囉","text":"最近要和朋友一起寫個app，他們提出了要用react native但完全沒有經驗，只好邊寫邊摸囉分享一下下自己的一點點經驗囉 element在native中，不能使用html中的element而是要改使用Text、View、Image這些… Text其實就是span或是label View就是div Image就img TextInput也就是input囉 cssnative中我們一樣是使用css來作為樣式的設定但寫法有點不一樣，是採用駝峰式的命名，數字以外的都要用單引號包起來而且有的是有限制的，不是每個都能像是css那樣給值喔還是要查一下官方文件，才能確定怎麼使用 12backgroundColor: &#x27;rgba(0, 0, 0, 0.6)&#x27;margin: 2 /*number only*/ if在react中，要動態決定哪些內容要不要呈現可以用if去判斷來撰寫，但在native中，這個語法會報錯?因此可以用三元運算子(?:)來實作囉 123456789this.props.data.publice_date ? ( &lt;View style=&#123;styles.dateBlock&#125;&gt; &lt;Text style=&#123;styles.articleDate&#125;&gt;&#123;this.props.data.publice_date + &#x27; by &#x27; + this.props.data.author&#125;&lt;/Text&gt; &lt;/View&gt;) : ( &lt;View style=&#123;styles.dateBlock&#125;&gt; &lt;Text style=&#123;styles.eventDurtion&#125;&gt; &#123;&#x27;日期:&#x27; + this.props.data.s_date + &#x27;~&#x27;this.props.data.e_date&#125;&lt;/Text&gt; &lt;/View&gt; ) 或是可以用更簡單的方法&amp;&amp; 12345this.props.data.category &amp;&amp; ( &lt;View style=&#123;styles.categoryBlock&#125;&gt; &lt;Text style=&#123;styles.category&#125;&gt;&#123;this.props.data.town&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.category&#125;&gt;&#123;this.props.data.category&#125;&lt;/Text&gt; &lt;/View&gt;) 不管哪種方法，記得都要用()包起來，然後只能有一個root節點也就是說不能像下面這樣 123this.props.data.category &amp;&amp; ( &lt;Text style=&#123;styles.category&#125;&gt;&#123;this.props.data.town&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.category&#125;&gt;&#123;this.props.data.category&#125;&lt;/Text&gt;) for那如果說要用迴圈去把資料呈現出來，有兩個方法react native有提供ListView，但這個只能row的方式呈現如果需要往橫向發展的，千萬不能用 那我們要怎麼用勒，可以使用陣列自有的map這個operator裡面有個key的屬性，記得要加，不然執行測試時也會看到他的提示不過還不是很清楚這個功能的作用 123this.props.data.tagList.map((tag, key) =&gt; &#123; return &lt;Text style=&#123;styles.tag&#125; key=&#123;key&#125;&gt;&#123;tag&#125;&lt;/Text&gt;&#125;) 排版在這邊你能夠盡情的使用flex來協助你排版完全不用考慮到瀏覽器的問題v(￣︶￣)y 12flex:1,flexDirection: &#x27;row&#x27;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"ReactNative","slug":"Frontend/ReactNative","permalink":"http://jiaming0708.github.io/categories/Frontend/ReactNative/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://jiaming0708.github.io/tags/ReactNative/"}]},{"title":"[Angular] HostBinding&HostListener","slug":"angular-hostbinding-listener","date":"2017-03-27T09:33:00.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2017/03/27/angular-hostbinding-listener/","link":"","permalink":"http://jiaming0708.github.io/2017/03/27/angular-hostbinding-listener/","excerpt":"介紹今天要來講講HostBinding和HostListener，原本官網還能找到文章，但最近才發現他已經被殺了…但還是要來說一下，誰叫我自己挖洞給自己跳了o(〒﹏〒)o","text":"介紹今天要來講講HostBinding和HostListener，原本官網還能找到文章，但最近才發現他已經被殺了…但還是要來說一下，誰叫我自己挖洞給自己跳了o(〒﹏〒)o 目標來做一個highlight的功能，顏色可以自定，當游標進入時變色，離開則回復如果是寫jquery，你會怎麼做? 使用on監聽事件 1234567let color = &#x27;red&#x27;;$(document).on(&#x27;mouseenter&#x27;, &#x27;.class&#x27;, function()&#123; $(this).style(&#x27;background-color&#x27;, color);&#125;);$(document).on(&#x27;mouseleave&#x27;, &#x27;.class&#x27;, function()&#123; $(this).style(&#x27;background-color&#x27;, &#x27;&#x27;);&#125;); 但我們現在是寫angular，當然要想辦法變成directive並且能做到像jquery的事情一樣 建立directive首先，先建立一個directive，並且傳入顏色 123456789101112131415161718192021222324import &#123; Directive, ElementRef, Input, Component &#125; from &#x27;@angular/core&#x27;;@Directive(&#123; selector: &#x27;[highlight]&#x27;&#125;)export class HighlightDirective &#123; private _defaultColor: string = &#x27;red&#x27;; constructor(private el:ElementRef) &#123; &#125; @Input(&#x27;color&#x27;) color: string;&#125;@Component(&#123; selector: &#x27;app-root&#x27;, template: ` &lt;div class=&quot;highlight&quot;&gt; Highlight Me!! &lt;/div&gt; `&#125;)export class AppComponent &#123;&#125; HostListener接著開始監聽事件，但是要怎麼做到，從一個element的屬性去監聽他的行為這時候我們需要用到HostListener，從字面其實可以猜的出來，他就是用來監聽來自element(host) 12345678910111213141516171819202122import &#123; Directive, ElementRef, Input, HostListener &#125; from &#x27;@angular/core&#x27;;@Directive(&#123; selector: &#x27;.highlight&#x27;&#125;)export class HighlightDirective &#123; private _defaultColor: string = &#x27;red&#x27;; constructor(private el:ElementRef) &#123; &#125; @Input(&#x27;color&#x27;) color: string; @HostListener(&#x27;mouseenter&#x27;) onEnter() &#123; this.el.nativeElement.style.backgroundColor = this.color || this._defaultColor; &#125; @HostListener(&#x27;mouseleave&#x27;) onLeave() &#123; this.el.nativeElement.style.backgroundColor = null; &#125;&#125; 補充說明:beta版本時(遙遠的古代…)，是在directive那邊的描述中加上一個host的來使用 123456@Directive(&#123; selector: &#x27;[highlight]&#x27;, host: &#123; &#x27;(mouseenter)&#x27;: &#x27;onMouseEnter()&#x27;, &#125;&#125;) HostBinding可是上面那樣寫還是不夠漂亮，還要在事件內去控制，為什麼不能用model去控制呢\b因此angular有提供HostBinding的功能，讓你可以直接用model來影響element屬性 12345678910111213141516171819202122import &#123; Directive, ElementRef, Input, HostListener, HostBinding &#125; from &#x27;@angular/core&#x27;;@Directive(&#123; selector: &#x27;.highlight&#x27;&#125;)export class HighlightDirective &#123; private _defaultColor: string = &#x27;red&#x27;; constructor(private el:ElementRef) &#123; &#125; @Input(&#x27;color&#x27;) color: string; @HostBinding(&#x27;style.backgroundColor&#x27;) bgColor: string; @HostListener(&#x27;mouseenter&#x27;) onEnter() &#123; this.bgColor = this.color || this._defaultColor; &#125; @HostListener(&#x27;mouseleave&#x27;) onLeave() &#123; this.bgColor = null; &#125;&#125; 哇屋～這樣的code看起來是不是更為清楚，而且好操作 這個範例是變更style的屬性，那如果要變更class的話，可以用下面的方法使用boolean來控制class是否被引用 1@HostBinding(&#x27;class.draging&#x27;) isDraging: boolean = false; 來點進階的內容，input和hostBinding合在一起有沒有搞頭答案是，絕對有搞頭 123@Input(&#x27;color&#x27;)@HostBinding(&#x27;style.backgroundColor&#x27;)bgColor: string; 外面的element用color這個屬性來傳入顏色，放入到bgColor這個變數，然後來影響backgroundColor這樣可以讓變數減少，並且整合在一起，閱讀起來也很清楚 加上Output上面的應用其實非常的簡單，但通常不會有這麼簡單的應用，那接著我們來加點料吧在進入時，我們需要拋出event，讓component呈現計數滑動次數吧！ 12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; Directive, ElementRef, Input, HostListener, HostBinding, Output, EventEmitter &#125; from &#x27;@angular/core&#x27;;@Directive(&#123; selector: &#x27;.highlight&#x27;&#125;)export class HighlightDirective &#123; private _defaultColor: string = &#x27;red&#x27;; constructor(private el:ElementRef) &#123; &#125; @Input(&#x27;color&#x27;) color: string; @Output() onColorChange = new EventEmitter; @HostBinding(&#x27;style.backgroundColor&#x27;) bgColor: string; @HostListener(&#x27;mouseenter&#x27;) onEnter() &#123; this.bgColor = this.color || this._defaultColor; this.onColorChange.emit(); &#125; @HostListener(&#x27;mouseleave&#x27;) onLeave() &#123; this.bgColor = null; &#125;&#125;@Component(&#123; selector: &#x27;app-root&#x27;, template: ` &lt;div class=&quot;highlight&quot; (onColorChange)=&quot;onColorChange()&quot;&gt; Highlight Me!! &lt;/div&gt; &lt;div&gt; &#123;&#123;enteryCount&#125;&#125; &lt;/div&gt; `&#125;)export class AppComponent &#123; enteryCount = 0; onColorChange()&#123; this.enteryCount++; &#125;&#125; Referencehttps://ng2.codecraft.tv/custom-directives/hostlistener-and-hostbinding/https://angular.io/docs/ts/latest/guide/cheatsheet.htmlhttps://angular.io/docs/ts/latest/guide/attribute-directives.html","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"RX初體驗(?)","slug":"rxjs-firsttime","date":"2017-03-16T14:10:52.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2017/03/16/rxjs-firsttime/","link":"","permalink":"http://jiaming0708.github.io/2017/03/16/rxjs-firsttime/","excerpt":"前情提要其實也不算是初體驗啦因為之前就有把promise的程式改成用rx，但那時候還是非常不了解","text":"前情提要其實也不算是初體驗啦因為之前就有把promise的程式改成用rx，但那時候還是非常不了解 最近在跟人一起寫angular的workshop，飲料維護及訂購的功能就開始用一些之前沒用到的功能rx、form control等… 嗯～還是不要太多廢話XD 從promise改成rx從ng1的時候，就都是寫promise，所以剛轉到二的時候，看到官網寫rx，就沒有想要去寫他o.0（年少不懂事…一開始的promise 1234567891011121314151617getStepListByProjectId(id: number) &#123; return this._http.post(this.url + &quot;GetStepListByProjectId&quot;, &#123; projectId: id &#125;) .toPromise() .then(res =&gt; &#123; var data = res.json(); if (data.Result) &#123; //轉換為前端使用物件 data.StepList = this.parseStepDataList(data.StepList); //預設值第一個選取 if (data.StepList.length &gt; 0) &#123; data.StepList[0].SelectedFlag = true; &#125; return data; &#125;) .catch(this.handleError);&#125; 改寫成rx後，在重新整理過，是不是感覺更精簡了但這時候其實還沒什麼感覺，因為比較算是轉換而已，對於rx還是很不熟… 123456789101112131415getStepListByProjectId(id: number) &#123; return this._http.post(this.url + &quot;GetStepListByProjectId&quot;, &#123; projectId: id &#125;) .switchMap(this.checkResult) .map(this.parseStepDataList) .catch(this.handleError);&#125;private checkResult(res: any): Observable&lt;any&gt; &#123; var data = res.json(); if (!data.Result) &#123; Observable.throw(data.ErrorMessage); &#125; return Observable.of(data.StepList);&#125; rx進一步的應用concatMap、toArray這次的需求是這樣的，從api取得的資料中，沒有其中一個物件中的欄位state所以我要把取得的資料重新assign欄位值 這樣的寫法其實已經可以達到我的需求，但總覺得不是很好看這是第一版 123456789getBeverageList(): Observable&lt;BeverageData[]&gt; &#123; return this._http.get(this.beverageAPI, this.options) .map(response =&gt; response.json() as BeverageData[]) .map(item =&gt; item.map(p =&gt; &#123; p.state = StateType.None; return p; &#125;)) .catch(this.handleError);&#125; 剛好kevin介紹了一個工具Quokka.js，可以不用console.log就可以把結果呈現在旁邊於是就開始實驗怎麼寫，可以讓這段更好看先把陣列拆開，做完以後再組合起來，這樣的寫法看起來是不是更清楚一點這是第二版 123456789101112getBeverageList(): Observable&lt;BeverageData[]&gt; &#123; return this._http.get(this.beverageAPI, this.options) .map(response =&gt; response.json() as BeverageData[]) .concatMap(p =&gt; p) .map(p =&gt; &#123; p.state = StateType.None; return p; &#125;) .toArray() .catch(this.handleError);&#125; mergeMappost資料回server端後，想要重新取得全部的資料，這時候又不希望由前面再次呼叫這時候可以直接在service層一次做完 那因為是呼叫另一個已經寫好的service，所以必須要把自己的observable和另一個接起來這時候我們要使用到mergeMap 12345postBeverage(index:number, beverage: BeverageData):Observable&lt;BeverageData[]&gt; &#123; return this._http.post(this.beverageAPI + &quot;/&quot; + index, beverage, this.options) .mergeMap(resp =&gt; this.getBeverageList()) .catch(this.handleError);&#125; 後續rx這東西真的要有案例來學，才有辦法體會他的奧妙，不然看文件看多了還是不太清楚如何搭配使用","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"RxJS","slug":"Frontend/RxJS","permalink":"http://jiaming0708.github.io/categories/Frontend/RxJS/"}],"tags":[{"name":"RxJS","slug":"RxJS","permalink":"http://jiaming0708.github.io/tags/RxJS/"}]},{"title":"[Angular] DI注入環境變數","slug":"angular-di-provide","date":"2017-03-11T08:01:20.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2017/03/11/angular-di-provide/","link":"","permalink":"http://jiaming0708.github.io/2017/03/11/angular-di-provide/","excerpt":"話說最近弄了一個題目練習Angular，搭配cli使用(只有方便而已啦!!我以前是在白痴什麼orz…)自己想了一個需求，就是我的API Server有分prodction和development","text":"話說最近弄了一個題目練習Angular，搭配cli使用(只有方便而已啦!!我以前是在白痴什麼orz…)自己想了一個需求，就是我的API Server有分prodction和development 基礎應用首先衍生出來的就是要設定在哪，然後怎麼用cli中有一個environment的資料夾，底下兩個檔案，environment.ts、environment.prod.ts很簡單的就是在裡面增加一個屬性叫做apiServer，並且應用到service中 1234567891011121314export const environment = &#123; production: false, apiServer: &#x27;https://192.168.100.1&#x27;&#125;;import &#123; environment &#125; from &quot;../../environments/environment&quot;;@Injectable()export class BeverageService &#123; getBeverageList(): Observable&lt;BeverageData[]&gt; &#123; return this._http.get(environment.apiServer+ &quot;Beverage&quot;) .map(response =&gt; response.json() as BeverageData[]) .catch(this.handleError); &#125;&#125; 進階應用這樣寫其實已經滿足我們需求，但是有點low來設想一個情境，如果之後我們的apiServer名字改掉的話，是不是變成service裡面所有使用到environment.apiServer這個全部要換掉其實angular本身有提供一個東西，叫做DI那我們可以把他做一個轉換，這樣在使用上，就可以脫離environment的直接影響只要在providers放進去，並且在constructor取得就好 12345678910111213import &#123; environment &#125; from &quot;../../environments/environment&quot;;@NgModule(&#123; providers: [ &#123; provide: &#x27;apiServer&#x27;, useValue: environment.apiServer &#125; ]&#125;)@Injectable()export class BeverageService &#123; constructor(private _http: Http, @Inject(&#x27;apiServer&#x27;) private apiServer: string) &#123; this.onInit(); &#125;&#125; DI學習參考oomusou的文章，深入探討 Angular 的 DI 與 Provider","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"[Angular] 動態載入Component","slug":"angular-dynamic-component","date":"2017-03-02T16:00:00.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2017/03/02/angular-dynamic-component/","link":"","permalink":"http://jiaming0708.github.io/2017/03/02/angular-dynamic-component/","excerpt":"最近在搞一個功能，目標是可以重新設定route，看到了一個功能resetConfig覺得可以用就開始測試，沒想到一直遇到鬼，就是過不去 No component factory found for CreateComponent. Did you add it to @NgModule.entryComponents?","text":"最近在搞一個功能，目標是可以重新設定route，看到了一個功能resetConfig覺得可以用就開始測試，沒想到一直遇到鬼，就是過不去 No component factory found for CreateComponent. Did you add it to @NgModule.entryComponents? 表示系統一直不認識這個component但是看來看去ngModule我都有放進去該component 123456789101112@NgModule(&#123; imports: [ AppRoutingModule, CoreModule ], declarations: [ AppComponent, CreateComponent ], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 後來請教了Kevin Yang才發現原來是少放了一個地方entryComponents完整的如下 12345678910111213@NgModule(&#123; imports: [ AppRoutingModule, CoreModule ], declarations: [ AppComponent, CreateComponent ], bootstrap: [AppComponent], entryComponents: [CreateComponent]&#125;)export class AppModule &#123; &#125; 那entryComponents到底有什麼不一樣，首先來看看官方文件 When do I add components to entryComponents?Most application developers won’t need to add components to the entryComponents. Angular adds certain components to entry components automatically. Components listed in @NgModule.bootstrap are added automatically. Components referenced in router configuration are added automatically. These two mechanisms account for almost all entry components. If your app happens to bootstrap or dynamically load a component by type in some other manner, you must add it to entryComponents explicitly. Although it’s harmless to add components to this list, it’s best to add only the components that are truly entry components. Don’t include components that are referenced in the templates of other components. 也就是說，想要動態載入一個沒有被用到的Component就必須要放到entryComponents中這樣系統才會認識他，不會當他是壞人( ￣ c￣)y▂ξ","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"[Angular] ViewChild及ContentChild介紹","slug":"angular-viewchild-contentchild","date":"2017-02-23T14:10:58.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2017/02/23/angular-viewchild-contentchild/","link":"","permalink":"http://jiaming0708.github.io/2017/02/23/angular-viewchild-contentchild/","excerpt":"昨天參加線上angular讀書會(打個廣告)，分享的內容是ngContent之前自己在寫的時候，套用bootstrap的功能時就有應用到但那時候一直看不懂是什麼意思，在昨天就整個豁然開朗","text":"昨天參加線上angular讀書會(打個廣告)，分享的內容是ngContent之前自己在寫的時候，套用bootstrap的功能時就有應用到但那時候一直看不懂是什麼意思，在昨天就整個豁然開朗 那到底什麼是ViewChild、ContentChild，底下來看看範例吧 ViewChild app-tab這個element就是ViewChild，也就是子Component的概念這時候就會有人問，這樣做有什麼好處 可以直接引用子Component所有public事件、屬性也就是說，可以不用辛苦的用Input、Output來進行傳遞(好壞先不討論囉!) ngContent 什麼是ngContent，可以說是叫做範本引入或是內容置換也就是把那個位置的內容變成由外面傳進來，app.component.ts中app-tab的內容就是自定義 那基本上ng-content就是直接把外面傳的東西換掉放進去進階一點的應用就是有多個ngContent，需要指定每個所放的位置在ng-content中加上select並指定就可以取得父component所傳入的內容這邊有三個類型 .class tagName 沒有指定 ContentChildContentChild有兩種取得的方式，在同一個parent中，是不能有重複的#id #id className 記得要取得ContentChild必須要在AfterContentInit這個事件之後才能拿到物件你才能夠爽爽的使用，不然會鼠翹翹喔! Child vs Children差異非常的小，就是一個單數一個複數，收工@@ 參考資料線上angular讀書會 S01E03ViewChildren and ContentChildren in Angular 2","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"[Angular] 2.0.0RC5升級2.4.0的注意事項","slug":"angular-2-0to2-4-upgrade-note","date":"2017-02-19T11:25:08.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2017/02/19/angular-2-0to2-4-upgrade-note/","link":"","permalink":"http://jiaming0708.github.io/2017/02/19/angular-2-0to2-4-upgrade-note/","excerpt":"前言之前自己玩的一個小專案，是一路從beta開始開發一直到RC5後來就都沒有變，一直到把功能開發完上線","text":"前言之前自己玩的一個小專案，是一路從beta開始開發一直到RC5後來就都沒有變，一直到把功能開發完上線 最近參加線上讀書會，討論到一個算是bug的功能，kevin就說趕快更新到最新吧! *change事件，裡面取得到ngModel的參數值是舊的，導致要傳入$event進去 正文來聊聊升級的坑吧，原本以為是把package.json改一改就好，現實總是殘酷的! 1.component中移除pieps、directives兩個屬性，改成在@NgModule中宣告 2.所有使用到的pipe、directive、component都需先在@NgModule中宣告 3.route寫法改變，一律採用class方式宣告，分檔時先使用NgModule載入 1234567891011121314151617//舊的寫法export const routing = RouterModule.forRoot(appRoutes, &#123; useHash: true &#125;);export const appRoutingProviders: any[] = [];@NgModule(&#123; providers: [appRoutingProviders],&#125;)//新的寫法@NgModule(&#123; imports: [ RouterModule.forRoot(appRoutes, &#123; useHash: true &#125;) ], exports: [ RouterModule ]&#125;)export class AppRoutingModule &#123; &#125;","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"}]},{"title":"[Cordova] hooks功能-檢查、壓縮、合併","slug":"cordova-hooks","date":"2016-12-23T02:51:17.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2016/12/23/cordova-hooks/","link":"","permalink":"http://jiaming0708.github.io/2016/12/23/cordova-hooks/","excerpt":"最近才得知cordova可以在編譯輸出前做一些事情這個地方叫做hooks，可以到官網查詢","text":"最近才得知cordova可以在編譯輸出前做一些事情這個地方叫做hooks，可以到官網查詢 預計要來做幾件事情1.JSHint2.Concat files3.Uglify JSHint檢查JS語法，這個會放在before_prepare，要讓錯誤扼殺在成長之前XD所以我們要建立一個檔案，010_jshint.js hooks的運作機制，會根據js前面的號碼作為排序，來依序執行檔案有多個動作時，記得要確認一下要執行的順序為何 Concat files撰寫時，我們會將js、css根據模組或功能等需求而分開來等到我們要執行時，為了效能的優化，就會將檔案進行合併 這個動作會放在after_prepare下，這邊也要建立一個檔案012_concat_files_by_index.js這功能主要是將index.html中所宣告引用的js、css進行合併，所以index.html還是要記得先加上 做完這段以後可以發現到，index.html中已經被合併的檔案tag還是存在，那接著我們就要對於這些被合併的tag換成最後輸出的檔案那這邊需要先對index.html中加上一些東西，才能讓接下來的功能順利進行，可以參考node-useref 1234567&lt;!-- build:css css/app.min.css --&gt;&lt;link href=&quot;css/ionic.app.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;!-- endbuild --&gt;&lt;!-- build:js js/app.min.js --&gt;&lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;&lt;!-- endbuild --&gt; 一樣在after_prepare中，加上015_prepare_index.js Uglify這是裡面最簡單的好做到的功能XD，只要下個指令就可以會自動在after_prepare下增加一個uglify.js檔案，因為前面沒有順序，所以會是最後執行詳細內容一樣可以到官網中查詢 1npm install cordova-uglify --save 做完以上的動作，我們就可以下個指令確認一下 1cordova prepare [platform] --release 沒有看到任何錯誤就是成功啦可以打完收工囉 ㄟㄟㄟ～等等！mac用戶明明會遇到另一個錯誤 好吧～我只好再回來繼續因為mac用戶會有權限的問題，會只看到一個鬼一般的訊息 Error: EACCES 那這個問題不大，只要下個指令給個權限就好，針對我們在after_prepare所新增的兩個檔案012、015 1chmod +x hooks/after_prepare/[filename] 好啦，這次真的要打完收工了","categories":[{"name":"APP","slug":"APP","permalink":"http://jiaming0708.github.io/categories/APP/"},{"name":"Cordova","slug":"APP/Cordova","permalink":"http://jiaming0708.github.io/categories/APP/Cordova/"}],"tags":[{"name":"Cordova","slug":"Cordova","permalink":"http://jiaming0708.github.io/tags/Cordova/"}]},{"title":"[Cordova] camera照片大小設定","slug":"cordova-camera-size","date":"2016-11-29T09:07:11.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2016/11/29/cordova-camera-size/","link":"","permalink":"http://jiaming0708.github.io/2016/11/29/cordova-camera-size/","excerpt":"最近在用ionic1.x版的開發APP，其中需要一個拍照的功能，使用套件cordova-plugin-camera那照片會在最後一起上傳到server，但是現在的手機像素其實很高導致一兩張照片而已就已經爆掉無法傳送（當然也可能是我不懂得怎麼寫上傳照片啦，我是轉成base64後上傳）","text":"最近在用ionic1.x版的開發APP，其中需要一個拍照的功能，使用套件cordova-plugin-camera那照片會在最後一起上傳到server，但是現在的手機像素其實很高導致一兩張照片而已就已經爆掉無法傳送（當然也可能是我不懂得怎麼寫上傳照片啦，我是轉成base64後上傳） 一開始沒仔細看官方文件（這很重要記得要好好看）就去搜尋了image resize的作法，得到使用canvas轉換，這個作法另外開一篇寫好了這個作法很可怕，圖片縮小後光線強的地方直線都變成鋸齒狀 就回套件看看有沒有什麼作法 column type description targetWidth number Width in pixels to scale image. Must be used with targetHeight. Aspect ratio remains constant. targetHeight number Height in pixels to scale image. Must be used with targetWidth. Aspect ratio remains constant. 這邊有說到可以等比例，好像是我要的，但是怎麼設定才會等比例阿…看不到太懂說明，只好打開java檔來看看 1234if (targetHeight &gt; 0 &amp;&amp; targetWidth &gt; 0 &amp;&amp; targetWidth == targetHeight) &#123; intent.putExtra(&quot;aspectX&quot;, 1); intent.putExtra(&quot;aspectY&quot;, 1);&#125; 原來只要給一樣的值，就會等比例的縮放，下面就是我的範例啦 123456navigator.camera.getPicture(onSuccess, onFail, &#123; quality: 100, destinationType: Camera.DestinationType.DATA_URL, //FILE_URI、DATA_URL targetWidth: 500, targetHeight: 500&#125;);","categories":[{"name":"APP","slug":"APP","permalink":"http://jiaming0708.github.io/categories/APP/"},{"name":"Cordova","slug":"APP/Cordova","permalink":"http://jiaming0708.github.io/categories/APP/Cordova/"}],"tags":[{"name":"Cordova","slug":"Cordova","permalink":"http://jiaming0708.github.io/tags/Cordova/"},{"name":"ionic","slug":"ionic","permalink":"http://jiaming0708.github.io/tags/ionic/"}]},{"title":"[Oracle] 記憶體控制sga","slug":"oracle-sga","date":"2016-05-30T14:29:03.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2016/05/30/oracle-sga/","link":"","permalink":"http://jiaming0708.github.io/2016/05/30/oracle-sga/","excerpt":"最近在玩系統負載測試，PM說用到最新的那台server上跑看看，於是就把系統丟上去開始測試沒跑不知道，測試下去才發現，怎麼記憶體吃了96%很怕是自己的系統導致，所以趕快的確認一下是誰吃了那麼多","text":"最近在玩系統負載測試，PM說用到最新的那台server上跑看看，於是就把系統丟上去開始測試沒跑不知道，測試下去才發現，怎麼記憶體吃了96%很怕是自己的系統導致，所以趕快的確認一下是誰吃了那麼多 還好兇手不是我(乎)，是三個DB，兩個oracle各吃15G，一個MS SQL吃13G（server共47G）問了一下高手看看這種是什麼情況，原來是sga在搞鬼 先下個指令確認一下，確認現在設定多少 123show sga;show parameter sga_targetshow parameter sga_max_size; 果然是target和max_size設定一樣導致，於是將sga_target先調小，sga_max_size不變避免未來需要吃太多 1alter system set sga_target=8192M;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"Oracle","slug":"Backend/Oracle","permalink":"http://jiaming0708.github.io/categories/Backend/Oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://jiaming0708.github.io/tags/oracle/"}]},{"title":"[C#] WebAPI使用","slug":"webapi-note","date":"2015-01-08T09:35:46.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2015/01/08/webapi-note/","link":"","permalink":"http://jiaming0708.github.io/2015/01/08/webapi-note/","excerpt":"以前在寫API時，都寫在Controller，而不是ApiController這次的專案，總覺得應該要標準化改走ApiController沒想到遇到了不少問題","text":"以前在寫API時，都寫在Controller，而不是ApiController這次的專案，總覺得應該要標準化改走ApiController沒想到遇到了不少問題 1.預設的Route下，每個ApiController只允許一個Get&#x2F;Delete&#x2F;Post若要同一個ApiController底下支援多個，可以修改WebApiConfig 123456789101112131415161718192021public static class WebApiConfig&#123; public static void Register(HttpConfiguration config) &#123; // Web API 設定和服務 config.EnableCors(); // Web API 路由 config.MapHttpAttributeRoutes(); config.Routes.MapHttpRoute( name: &quot;DefaultApi&quot;, routeTemplate: &quot;api/&#123;controller&#125;/&#123;action&#125;&quot; ); //config.Routes.MapHttpRoute( // name: &quot;DefaultApiWithAction&quot;, // routeTemplate: &quot;api/&#123;controller&#125;/&#123;action&#125;&quot;, // defaults: new &#123; id = RouteParameter.Optional &#125; //); &#125;&#125; 2.ApiController的Route會認前面的字樣，呼叫的方法有限制例如，開頭為Get就不支援Get以外的呼叫若開頭都不在標準方法內，則需使用Post 123456789//使用Getpublic ReturnDataModel GetUserData()&#123;&#125;//使用Postpublic ReturnDataModel SignIn()&#123;&#125; 3.Post的傳遞參數，若為物件，則只能接受一個物件 123456789101112131415161718192021//可以多個stringpublic ReturnDataModel SignIn(string user, string password)&#123;&#125;//將user和password組合成一個物件public class UserData&#123; public string UserName&#123;get;set;&#125; public string Password&#123;get;set;&#125;&#125;//可以一個物件public ReturnDataModel SignIn(UserData data)&#123;&#125;//不可以一個物件以上，必須將這兩個參數合成一個物件public ReturnDataModel SignIn(UserData data, string device)&#123;&#125;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"},{"name":"MVC","slug":"MVC","permalink":"http://jiaming0708.github.io/tags/MVC/"}]},{"title":"[AngularJS] 第一個directive","slug":"angularjs-directive","date":"2014-11-25T11:32:03.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2014/11/25/angularjs-directive/","link":"","permalink":"http://jiaming0708.github.io/2014/11/25/angularjs-directive/","excerpt":"同事需要一個按下enter轉成tab的功能，這在JS其實蠻好做的但是在angular的$event屬性都是唯獨，導致這個功能沒有辦法直接實作","text":"同事需要一個按下enter轉成tab的功能，這在JS其實蠻好做的但是在angular的$event屬性都是唯獨，導致這個功能沒有辦法直接實作 我改用另一個想法去實作這個功能使用directive套用在element身上，並且找到下一個有宣告的element為了能在enter後去呼叫API，所以再加上call back的功能 這是第一個實作出來且符合需求的directive &lt;(￣︶￣)&gt; 得意叉腰","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"AngularJS","slug":"Frontend/AngularJS","permalink":"http://jiaming0708.github.io/categories/Frontend/AngularJS/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://jiaming0708.github.io/tags/AngularJS/"}]},{"title":"[windows] 真正關閉Windows 8的UAC","slug":"window-close-uac","date":"2014-09-17T12:43:23.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2014/09/17/window-close-uac/","link":"","permalink":"http://jiaming0708.github.io/2014/09/17/window-close-uac/","excerpt":"UAC這東西從Vista就開始存在了但以前想要把使用者變成真正的Administrator只要到「使用者帳戶」的管理下把「變更使用者帳戶控制設定」調整為最小即可","text":"UAC這東西從Vista就開始存在了但以前想要把使用者變成真正的Administrator只要到「使用者帳戶」的管理下把「變更使用者帳戶控制設定」調整為最小即可 但是在win 8開始，這個並不是真正的Administrator，還是需要手動使用系統管理員執行的方式才能擁有權限Microsoft希望讓系統的安全性更高，但是這樣對於我來說其實很大的不方便為了讓自己能夠拿真正的權限，就必須要動手做一些的修改 1.開啟regedit2.到「HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System」下找到「Enable LUA」3.將數值修改為04.歡樂使用最高權限","categories":[{"name":"Windows","slug":"Windows","permalink":"http://jiaming0708.github.io/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://jiaming0708.github.io/tags/Windows/"}]},{"title":"[C#] 使用Autofac","slug":"mvc-autofac","date":"2014-09-17T01:30:27.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2014/09/17/mvc-autofac/","link":"","permalink":"http://jiaming0708.github.io/2014/09/17/mvc-autofac/","excerpt":"最近接觸MVC…(好像也接觸一兩年了＠＠…所看到的範例程式，都是使用Interface來呼叫method","text":"最近接觸MVC…(好像也接觸一兩年了＠＠…所看到的範例程式，都是使用Interface來呼叫method 去了解後才知道這樣做有一個好處以後若要進行客製，可以直接替換成另一個class來寫該method的內容，而不用改寫呼叫該method的程式這個有一個詞叫做DI或是IoC，想要知道這塊的朋友，請搜尋一下囉 使用此作法，其實有很多的方法可以做到今天要來說的是Autofac，這類的教學其實已經很多了那我今天的重點會是在如何讓Autofac幫我們自動載入Interface到Controller的建構子中 那我們就先來準備一下Interface及實作的class 12345678910111213public interface ILotService&#123; LotData GetLotByLot(string lot); &#125;public class LotService : ILotService&#123; public LotData GetLotByLot(string lot) &#123; var data = new LotData(); return data; &#125;&#125; 那接著我們在Controller加上建構子，並用ILotService當做參數 1234567891011public class HomeController : Controller&#123; public HomeController(ILotService lotService) &#123; &#125; public ActionResult Index() &#123; return View(); &#125;&#125; 以上都好了以後，直接去跑的話，系統一定死給你看接下來我們要把Autofac加入，新增一個AutofacConfig的class到App_Start在AutofacConfig裡面加入Bootstrapper的method 123456789101112131415public class AutofaceConfig&#123; public static void Bootstrapper() &#123; var builder = new ContainerBuilder(); //直接將Services專案中的所有Interface加入，可免除後來新增的忘記加入 builder.RegisterAssemblyTypes(typeof(ILotService).Assembly).AsImplementedInterfaces(); //可直接在Controller的建構子，使用Interface的參數 builder.RegisterControllers(Assembly.GetExecutingAssembly()); //交由MVC的Dependency處理 var container = builder.Build(); DependencyResolver.SetResolver(new AutofacDependencyResolver(container)); &#125;&#125; 想要做到Controller的建構子能夠自動載入Interface，重點是在使用builder.RegisterControllers最後再Global的Application_Start裡面加上AutofaceConfig.Bootstrapper(); 123456789protected void Application_Start()&#123; AreaRegistration.RegisterAllAreas(); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); //載入autofac AutofaceConfig.Bootstrapper();&#125;","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"},{"name":"MVC","slug":"MVC","permalink":"http://jiaming0708.github.io/tags/MVC/"}]},{"title":"[CSS] 單位em pt px","slug":"css-unit","date":"2014-02-20T02:43:59.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2014/02/20/css-unit/","link":"","permalink":"http://jiaming0708.github.io/2014/02/20/css-unit/","excerpt":"最近在協助同事調整網頁的樣式發現美工提供的字型大小是用emfont-size:0.5em;","text":"最近在協助同事調整網頁的樣式發現美工提供的字型大小是用emfont-size:0.5em; 同事問了一個問題，em是什麼但我只認識px阿～～～～哀號 趕緊上網查了一下，才知道那些單位的差異 em:以瀏覽器的字型大小為基礎做百分比的縮放例:瀏覽器設定字型大小為16px，那0.5em就會產生8px的大小 pt:point印刷字體大小1 pt &#x3D; 1.333px px:像素大小","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"http://jiaming0708.github.io/categories/Frontend/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://jiaming0708.github.io/tags/CSS/"}]},{"title":"[jQuery] live改用on寫法","slug":"jquery-live","date":"2013-11-14T11:47:55.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2013/11/14/jquery-live/","link":"","permalink":"http://jiaming0708.github.io/2013/11/14/jquery-live/","excerpt":"jQuery在1.7版的時候就把live標記為deprecated，而建議改用on","text":"jQuery在1.7版的時候就把live標記為deprecated，而建議改用on 之前使用的時候都沒特別注意到差異但最近使用到了live(這樣算是老人嗎XD)，但為了要跟上潮流改用on，卻發生悲劇了，後來產生的沒有被綁上事件 1234//原本寫法$(&#x27;a.open&#x27;).live(&#x27;click&#x27;, ToggleDetail);//改用新寫法$(&#x27;a.open&#x27;).on(&#x27;click&#x27;, ToggleDetail); 仔細查了一下jQuery官網，才發現原來搞錯寫法了on()原來他們覺得原先的寫法，會讓人錯誤的以為事件的綁定方式，所以要正規化（我已經誤入歧途了orz）自動綁定所有符合條件物件的事件，應該是從body或document開始去掃描所以應該是要改成下面的寫法 1234//原本寫法$(&#x27;a.open&#x27;).live(&#x27;click&#x27;, ToggleDetail);//正確寫法$(document).on(&#x27;click&#x27;,&#x27;a.open&#x27;, ToggleDetail);","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"jQuery","slug":"Frontend/jQuery","permalink":"http://jiaming0708.github.io/categories/Frontend/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://jiaming0708.github.io/tags/jQuery/"}]},{"title":"[windows] 7/8變更使用者目錄","slug":"window-user-folder","date":"2013-09-13T15:42:33.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2013/09/13/window-user-folder/","link":"","permalink":"http://jiaming0708.github.io/2013/09/13/window-user-folder/","excerpt":"好久沒有寫點東西，來分享一個實用的東西","text":"好久沒有寫點東西，來分享一個實用的東西 win 7&#x2F;8的User資料夾會存放系統中很多暫存的東西當系統越用越久，就會越來越肥 如果系統槽很不巧的只有給一點點的空間大小那慘了，會看到系統跟你說空間不足最後可能就使用系統都有問題 接下來告訴大家一個好方法但是 but 旦夕，這招只能用在剛安裝系統時 在安裝過程中，要求輸入用戶名及密碼時（或是輸入電腦名稱時），先不輸入按「Shift+F10」呼出DOS視窗（注意的是更換的槽必須為NTFS） robocopy “C:\\Users” “X:\\Users” &#x2F;E &#x2F;COPYALL &#x2F;XJ rmdir “C:\\Users” &#x2F;S &#x2F;Q mklink &#x2F;J “C:\\Users” “X:\\Users” 關閉DOS窗口，繼續安裝至完成，這樣安裝的系統，所有「User」的內容都將設置在X槽。","categories":[{"name":"Windows","slug":"Windows","permalink":"http://jiaming0708.github.io/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://jiaming0708.github.io/tags/Windows/"}]},{"title":"[oracle] 取得時間到毫秒","slug":"oracle-millisecond","date":"2013-09-13T13:14:25.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2013/09/13/oracle-millisecond/","link":"","permalink":"http://jiaming0708.github.io/2013/09/13/oracle-millisecond/","excerpt":"記錄時間的時候，通常會用to_char(sysdate, ‘yyyy&#x2F;MM&#x2F;dd HH24:mi:ss’)但這樣只能顯示到秒，無法在顯示到更小的單位","text":"記錄時間的時候，通常會用to_char(sysdate, ‘yyyy&#x2F;MM&#x2F;dd HH24:mi:ss’)但這樣只能顯示到秒，無法在顯示到更小的單位 當想要看到毫秒的話，就不能使用sysdate要改用systimestamp，to_char(systimestamp, ‘yyyy&#x2F;MM&#x2F;dd hh24:mi:ssxff’) 就可以到這樣的資料 2013&#x2F;02&#x2F;23 21:20:32.299000就可以更精準的做想要看的資料了","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"Oracle","slug":"Backend/Oracle","permalink":"http://jiaming0708.github.io/categories/Backend/Oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://jiaming0708.github.io/tags/oracle/"}]},{"title":"[oracle] 獨立交易，不影響外層的交易行為","slug":"oracle-autonomus-transaction","date":"2013-02-23T14:57:33.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2013/02/23/oracle-autonomus-transaction/","link":"","permalink":"http://jiaming0708.github.io/2013/02/23/oracle-autonomus-transaction/","excerpt":"當要調教效能時，會採用寫log的方式但是寫log是一定要commit，但commit下去一定會影響到外面在做的事情","text":"當要調教效能時，會採用寫log的方式但是寫log是一定要commit，但commit下去一定會影響到外面在做的事情 這時候怎麼辦呢，還好同事有經驗這種功能在Oracle中，中文叫做自治事務，英文是Autonomous Transactions 要怎麼應用勒，其實很簡單在要獨立交易的Procedure中多加一行 PRAGMA AUTONOMOUS_TRANSACTION;還是看一下實際範例吧 12345678910PROCEDURE WriteLog (text IN VARCHAR2)IS PRAGMA AUTONOMOUS_TRANSACTION;BEGININSERT INTO LOG VALUES (text, SYSDATE);COMMIT;END;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"Oracle","slug":"Backend/Oracle","permalink":"http://jiaming0708.github.io/categories/Backend/Oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://jiaming0708.github.io/tags/oracle/"}]},{"title":"[oracle] 查詢正在執行的JOB及砍掉執行中的Session","slug":"oracle-query-delete-session","date":"2013-02-23T12:38:39.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2013/02/23/oracle-query-delete-session/","link":"","permalink":"http://jiaming0708.github.io/2013/02/23/oracle-query-delete-session/","excerpt":"有時候Procedure&#x2F;Package沒寫好時，會跑超級久這時候會開始寫log或其他的動作來看調教效能","text":"有時候Procedure&#x2F;Package沒寫好時，會跑超級久這時候會開始寫log或其他的動作來看調教效能 我們要先停下JOB才能夠繼續編輯，可以用以下步驟做 123456789101112131415--1.先確認一下JOB的資訊select * from dba_jobs;--2.確認正在執行的JOB資訊select * from dba_jobs_running;--3.停止JOBexec dbms_job.broken(&#x27;&amp;JOB&#x27;,true);--4.當JOB還是繼續跑的時候，刪除還在執行的Sessionselect SID,SERIAL# from V$Session where SID=&#x27;&amp;SID&#x27;;alter system kill session &#x27;&amp;SID, &amp;SERIAL&#x27;;--5.刪除JOB（需要sysdba權限）delete from dba_jobs where JOB=&#x27;&amp;JOB&#x27;; PS:&amp;JOB、&amp;SID、&amp;SERIAL，表示select出來的欄位值","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"Oracle","slug":"Backend/Oracle","permalink":"http://jiaming0708.github.io/categories/Backend/Oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://jiaming0708.github.io/tags/oracle/"}]},{"title":"[oracle] 重開機oracle無法連線的問題ORA-27101","slug":"oracle-27101","date":"2013-02-20T01:37:11.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2013/02/20/oracle-27101/","link":"","permalink":"http://jiaming0708.github.io/2013/02/20/oracle-27101/","excerpt":"每次重灌電腦後，一開始安裝oracle都可以正常連線但只要重開機，就會連線不進去","text":"每次重灌電腦後，一開始安裝oracle都可以正常連線但只要重開機，就會連線不進去 oracle會回報ORA-12514的錯誤，可參考文章ORA-12514 TNS 監聽進程不能解析在連接描述符中給出的 SERVICE_NAME這個問題解了以後，又出現另一個錯誤 ORA-01034: ORACLE not availableORA-27101: shared memory realm does not exist 天啊，這是在打魔王嗎，一關接著一關關關難過關關，還好不是只有我遇到這個問題其實是SGA_SIZE大於Memory_target，只能使用指令的方式進行修復 根據以下步驟，就可以修正問題囉 在cmd中下指令，sqlplus &#x2F; as sysdba 進入到sqlplus中執行指令，create pfile from spfile; 安裝oracle的目錄下，app[username]\\product\\ver\\dbhome_1\\database用記事本開啟INIT[dbname].ORA，找到*.memory_target和*.SGA_MAX_SIZE，將這兩個參數的值改為一樣後儲存 改完後，在到sqlplus中執行指令，create spfile from pfile; 到這邊就算是完成了，接著就是重新啟動oracle 打完收工!!","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"Oracle","slug":"Backend/Oracle","permalink":"http://jiaming0708.github.io/categories/Backend/Oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://jiaming0708.github.io/tags/oracle/"}]},{"title":"[windows] Window 7如何讀取Window NT4.0的分享資料夾","slug":"window-7-access-nt4-folder","date":"2012-11-13T01:22:18.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2012/11/13/window-7-access-nt4-folder/","link":"","permalink":"http://jiaming0708.github.io/2012/11/13/window-7-access-nt4-folder/","excerpt":"最近正在做一個專案裡面有一部分功能很簡單，就是讀取檔案然後寫入資料庫","text":"最近正在做一個專案裡面有一部分功能很簡單，就是讀取檔案然後寫入資料庫 但是沒想到遇到了困難點，有一個電腦的環境是NT4.0連到電腦要求登入時，帳號密碼怎樣輸入就是不給進還好我不是第一個遇到這樣的問題(汗 按下「開始」，在「搜尋程式與檔案」中，輸入 secpol.msc 並按下 Enter 鍵 依序展開「本機原則」、「安全性選項」 在右側窗格中的「Microsoft 網路用戶端: 傳送未加密的密碼到其他廠商的 SMB 伺服器」上，連按兩下滑鼠左鍵 於「本機安全性設定」索引標籤中，按下 啟用(E) 選項鈕 按下確定 在同一個安全性選項中「網路安全性：LAN Manager 驗證層級」，設定為「傳送 LM 和 NTLM 回應-如有交涉，使用NTLMv2工作階段安全性」 確定後即可 PS:我搜尋到的資料，其實都是說「網路安全性：LAN Manager 驗證層級」，設定為設定為「傳送 LM 和 NTLM 回應」但我實際設定後，發現這樣還是沒有辦法用，要改成上面說的那種才能使用，如果有人知道是為什麼，歡迎跟我分享","categories":[{"name":"Windows","slug":"Windows","permalink":"http://jiaming0708.github.io/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://jiaming0708.github.io/tags/Windows/"}]},{"title":"[C#] 使用Sandcastle產生文件","slug":"csharp-sandcastle","date":"2012-10-16T13:49:30.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2012/10/16/csharp-sandcastle/","link":"","permalink":"http://jiaming0708.github.io/2012/10/16/csharp-sandcastle/","excerpt":"很多人都使用過微軟的Help文件這種文件是實體檔案，不用透過網路自己寫的dll產生一個這樣的文件，可以讓其他使用這個dll的人，快速了解如何使用當然前提是dll有產生XML的註解","text":"很多人都使用過微軟的Help文件這種文件是實體檔案，不用透過網路自己寫的dll產生一個這樣的文件，可以讓其他使用這個dll的人，快速了解如何使用當然前提是dll有產生XML的註解 要產生像這樣的文件，需要先準備一些東西 Sandcastle Sandcastle Help File Builder，這有GUI可以讓我們快速設定並產生 HTML Help Document，產生.chm(HtmlHelp 1.x)檔必備 以上的東西都準備好後，開啟Sandcastle Help File Builder GUI產生新專案後，可以看到以下的畫面 通常會更改下面的幾個部分1.FrameworkVersion:dll使用的版本，預設採用電腦中安裝的最大framework versionHelpFileFormat:基本有HtmlHelp1、MSHelp2、MSHelpViewer、Website，這個部分就看需要產生哪種類型的文件囉 2.Help Title:在文件內最上方的TitleHtmlHelpName:文件的名稱 3.PresentationType:基本有hana、Prototype、vs2005、vs2010(似乎是看Builder版本)，個人比較喜歡Prototype 4.這其實才是重點的重點！Documentation Sources:要產出文件的dll、xml放在這邊References:產出文件的dll需要的額外參考，就是那種不想產出在文件內，但是沒有又一定會編譯失敗的參考dll PS:如果編譯出現「HHC6003 : error : The file Itircl.dll has not been registered correctly」的錯誤請去下載itcc.dll，並且註冊至系統中regsvr32 [c:&#x2F;windows&#x2F;system32&#x2F;itcc.dll]，[]中是檔案目錄","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[C#] TCPClient如何判斷已斷線","slug":"csharp-tcpclient","date":"2012-10-16T13:04:42.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2012/10/16/csharp-tcpclient/","link":"","permalink":"http://jiaming0708.github.io/2012/10/16/csharp-tcpclient/","excerpt":"TCPClient有一個屬性Connected可以用來判斷是否還有連線但是每次斷線後這個屬性還是沒有改變","text":"TCPClient有一個屬性Connected可以用來判斷是否還有連線但是每次斷線後這個屬性還是沒有改變 MSDN中有說明 如果最近一次的作業是將 Client 通訊端連接至遠端資源，則為 true，否則為 false。Connected 屬性會取得上次 I&#x2F;O 作業的 Client 通訊端連接狀態。當它傳回 false 時，即表示 Client 通訊端不是從未連接過，就是不再連接了。因為 Connected 屬性只反映最近一次作業的連接狀態，所以您應嘗試傳送或接收訊息，以判斷目前的狀態。訊息傳送失敗之後，這個屬性就不再傳回 true。請注意，這種行為是設計上的預期行為。您可能無法很穩定地測試連接的狀態，原因是有可能在測試和收發 (訊息) 之間就失去該連接。您的程式碼應假設該通訊端是連接的，然後再小心處理傳輸失敗的情況。 Connected是記憶最後的連線狀態，通常都是上次連線正常，然後就突然死掉這樣是要怎麼玩阿orz 可以使用socket的peek功能來試讀資料用這樣可以得知連線是否還在 123456789101112131415161718192021try&#123; client.Client.Poll(0, SelectMode.SelectRead); byte[] testRecByte = new byte[1]; while (client.Connected) &#123; if (client.Available == 0) &#123; //使用Peek，測試client是否還有連線 if (client.Client.Receive(testRecByte, SocketFlags.Peek) == 0) break; Thread.Sleep(20); continue; &#125; &#125;&#125;catch (SocketException ex)&#123;&#125; 參考資料黑暗執行續 偵測TcpClient連線狀態","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[ASP.NET] 在UpdatePanel裡使用FileUpload控制項","slug":"asp-fileupload-updatepanel","date":"2012-09-20T13:00:12.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2012/09/20/asp-fileupload-updatepanel/","link":"","permalink":"http://jiaming0708.github.io/2012/09/20/asp-fileupload-updatepanel/","excerpt":"一般使用FileUpload控制項時，只要PostBack回後台，有上傳的檔案一定取的到但是某天我在外面包了一個UpdatePanel","text":"一般使用FileUpload控制項時，只要PostBack回後台，有上傳的檔案一定取的到但是某天我在外面包了一個UpdatePanel 慘案發生了 123456&lt;asp:updatepanel id=&quot;UpdatePanel1&quot; runat=&quot;server&quot;&gt;&lt;contenttemplate&gt; &lt;asp:fileupload id=&quot;FileUpload1&quot; runat=&quot;server&quot;&gt; &lt;asp:button id=&quot;Button1&quot; runat=&quot;server&quot; text=&quot;Button&quot;&gt;&lt;/asp:button&gt;&lt;/asp:fileupload&gt;&lt;/contenttemplate&gt;&lt;/asp:updatepanel&gt; PostBack回到後台接不到上傳的檔案orz還好有同事愈過這樣的情況 同事說只要加上Trigger就可以了，馬上測試 123456789&lt;asp:updatepanel id=&quot;UpdatePanel1&quot; runat=&quot;server&quot; updatemode=&quot;Conditional&quot;&gt;&lt;contenttemplate&gt; &lt;asp:fileupload id=&quot;FileUpload1&quot; runat=&quot;server&quot;&gt; &lt;asp:button id=&quot;Button1&quot; runat=&quot;server&quot; text=&quot;Button&quot;&gt;&lt;/asp:button&gt;&lt;/asp:fileupload&gt;&lt;/contenttemplate&gt;&lt;triggers&gt;&lt;asp:postbacktrigger controlid=&quot;Button1&quot;&gt;&lt;/asp:postbacktrigger&gt;&lt;/triggers&gt;&lt;/asp:updatepanel&gt; 捷克～真的可以了原來是FileUpload一定要觸發PostBack，後台才能取得上傳的檔案MSDN中有說到，FileUpload和UpdatePanel不相容學藝不精阿～還是要多多看MSDN","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"ASP.NET","slug":"Backend/ASP-NET","permalink":"http://jiaming0708.github.io/categories/Backend/ASP-NET/"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"}]},{"title":"[C#] WinForm的DataGridView類似Web的GridView_DataRowBound事件","slug":"csharp-datagridview-datarowbound","date":"2012-05-17T12:50:37.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2012/05/17/csharp-datagridview-datarowbound/","link":"","permalink":"http://jiaming0708.github.io/2012/05/17/csharp-datagridview-datarowbound/","excerpt":"最近在寫自己的小程式不過是使用WinForm開發，跟工作時使用的Web不一樣蠻多事件都不太一樣","text":"最近在寫自己的小程式不過是使用WinForm開發，跟工作時使用的Web不一樣蠻多事件都不太一樣 其中，在Web上最好用的事件，GridView_DataRowBound在WinForm的DataGridView竟然沒有&gt;&lt;後來東找找西找找，找到了一個類似的這個方法是一個儲存格一個儲存格的處理，但Web是一個Row一起處理，還是Web好用阿~~~~ 讓我們來看看如何使用吧 1234567891011121314151617private void dgvData_CellFormatting(object sender, DataGridViewCellFormattingEventArgs e)&#123; try &#123; if (!dgvData.Columns[e.ColumnIndex].Name.Equals(&quot;Status&quot;, StringComparison.OrdinalIgnoreCase)) return; if (e.Value == &quot;Y&quot;) e.Value = &quot;是&quot;; else e.Value = &quot;否&quot;; &#125; catch (Exception ex) &#123; WriteMessage(ex); &#125;&#125;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[C#] 寫入的簡體資料變成亂碼","slug":"oracle-nls-lang","date":"2012-02-17T07:44:05.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2012/02/17/oracle-nls-lang/","link":"","permalink":"http://jiaming0708.github.io/2012/02/17/oracle-nls-lang/","excerpt":"最近用自己的DB去測試程式時，發現簡體的資料存進去都變成空白字元在網路上查詢了一下，是因為DB的一個設定導致可使用底下方法修改，資料儲存就正常了","text":"最近用自己的DB去測試程式時，發現簡體的資料存進去都變成空白字元在網路上查詢了一下，是因為DB的一個設定導致可使用底下方法修改，資料儲存就正常了 使用Regedit找到 HKEY_LOCAL_MACHINE\\SOFTWARE\\ORACLE\\KEY_ORADB11G_HOME1\\NLS_LANG原始值為TRADITIONAL CHINESE_TAIWAN.ZHT16MSWIN950修改值為AMERICAN_AMERICA.AL32UTF8","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"Oracle","slug":"Backend/Oracle","permalink":"http://jiaming0708.github.io/categories/Backend/Oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://jiaming0708.github.io/tags/oracle/"}]},{"title":"[C#] 連結MySql","slug":"csharp-mysql","date":"2012-01-13T02:12:16.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2012/01/13/csharp-mysql/","link":"","permalink":"http://jiaming0708.github.io/2012/01/13/csharp-mysql/","excerpt":"最近case是要和MySql連結，之前都沒有用過，特別記一下","text":"最近case是要和MySql連結，之前都沒有用過，特別記一下 MySql和Oracle類似，都必須先安裝Client才能夠連線MySql下載 特別要注意一下如果server版本比較舊，請考慮不要抓最新版本 我遇到的server版本是4.0.18，client裝的版本是5.1，連線後出現下面的錯誤訊息 DBS-00000 : ERROR [08001] [MySQL][ODBC 5.1 Driver]Driver does not support server versions under 4.1.1 後來client直接改裝3.X版本，連線正常 MySql的連線可採用OleDb的元件，或是採用另一個MySql元件去做連線","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[ASP.NET] 使用Tab不停留在物件上","slug":"asp-tabindex","date":"2012-01-06T06:13:07.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2012/01/06/asp-tabindex/","link":"","permalink":"http://jiaming0708.github.io/2012/01/06/asp-tabindex/","excerpt":"這個功能很單純，只是希望按Tab鍵的時候能夠跳過某些物件，按照希望的順序來切換","text":"這個功能很單純，只是希望按Tab鍵的時候能夠跳過某些物件，按照希望的順序來切換 不停留TabIndex &#x3D; -1，其他順序TabIndex&#x3D;1,2… 123456&lt;!-- Tab停留 --&gt;&lt;asp:textbox id=&quot;ttbUser&quot; runat=&quot;server&quot; tabindex=&quot;1&quot;&gt;&lt;/asp:textbox&gt;&lt;!-- Tab不停留 --&gt;&lt;asp:textbox id=&quot;ttbUserName&quot; runat=&quot;server&quot; tabindex=&quot;-1&quot;&gt;&lt;/asp:textbox&gt;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"ASP.NET","slug":"Backend/ASP-NET","permalink":"http://jiaming0708.github.io/categories/Backend/ASP-NET/"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"}]},{"title":"[C#] lambda的foreach如何使用break/continue","slug":"csharp-lambda-foreach","date":"2011-11-07T11:19:28.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2011/11/07/csharp-lambda-foreach/","link":"","permalink":"http://jiaming0708.github.io/2011/11/07/csharp-lambda-foreach/","excerpt":"在一般情況下，使用foreach時，遇到特定條件要讓他continue&#x2F;break會這樣去寫","text":"在一般情況下，使用foreach時，遇到特定條件要讓他continue&#x2F;break會這樣去寫 123456List&lt;string&gt; lstSql;foreach(var sql in lstSql)&#123; if(string.IsNullOrEmpty(sql)) continue;//break;&#125; 但是在如果我們使用lambda還這樣寫，就會error 12List&lt;string&gt; lstSql;lstSql.Foreach(p=&gt; if(stirng.IsNullOrEmpty(p)) continue;); 但我們又想要這樣做，該怎麼辦呢必須知道lambda是怎麼處理foreach的 1234public static void ForEach&lt;t&gt;(this IEnumerable&lt;t&gt; sequence, Action&lt;t&gt; action)&#123; foreach(var item in sequence) action(item);&#125; 由以上可以得知，我們下continue&#x2F;break對function來說是看不懂的我的作法是直接寫return，這樣就等於離開function 12List&lt;string&gt; lstSql;lstSql.Foreach(p=&gt; if(stirng.IsNullOrEmpty(p)) return;);","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[ASP.NET] 在UpdatePanel裡執行JavaScript II","slug":"asp-javascript-updatepanel-2","date":"2011-11-07T11:08:05.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2011/11/07/asp-javascript-updatepanel-2/","link":"","permalink":"http://jiaming0708.github.io/2011/11/07/asp-javascript-updatepanel-2/","excerpt":"上次發表這篇 在UpdatePanel裡執行JavaScript只是提到如何在UpdatePanel裡面，在後台中去執行前台的Script","text":"上次發表這篇 在UpdatePanel裡執行JavaScript只是提到如何在UpdatePanel裡面，在後台中去執行前台的Script 那如果是要每次PostBack後都需要執行呢那就必須改用這個方式 這段必須放在Body裡面，這要特別注意 12345678&lt;script&gt;function hello()&#123; alert(&#x27;hello!&#x27;);&#125;&lt;/script&gt;Sys.WebForms.PageRequestManager.getInstance().add_endRequest(hello);","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"ASP.NET","slug":"Backend/ASP-NET","permalink":"http://jiaming0708.github.io/categories/Backend/ASP-NET/"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"}]},{"title":"[oracle] EXP-00000 Message 0 not found; No message file for product=RDBMS, facility=EXP","slug":"oracle-exp00000","date":"2011-11-07T10:53:08.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2011/11/07/oracle-exp00000/","link":"","permalink":"http://jiaming0708.github.io/2011/11/07/oracle-exp00000/","excerpt":"在Server上想要進行Export時，出現了錯誤訊息 EXP-00000: Message 0 not found; No message file for product&#x3D;RDBMS, facility&#x3D;EXP","text":"在Server上想要進行Export時，出現了錯誤訊息 EXP-00000: Message 0 not found; No message file for product&#x3D;RDBMS, facility&#x3D;EXP 在自己電腦安裝oracle都沒有遇過 在網路上查詢後，發現是Server上安裝的是Oracle Client在安裝時，沒有安裝到Export的元件 為了讓Server能夠正常Export首先必須要找到一台可以正常Export的電腦，找到安裝的資料夾路徑跟無法Export的電腦比對，有少的在複製 複製exp*.exe(不能import改找imp*.exe) RMDMS\\mesg裡的expus.msb，expzhs.msb(import改impus.msb,impzhs.msb) 複製完畢，在執行一次ok了，那就打完收工","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"Oracle","slug":"Backend/Oracle","permalink":"http://jiaming0708.github.io/categories/Backend/Oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://jiaming0708.github.io/tags/oracle/"}]},{"title":"[oracle] 使用者可以查詢卻無法匯出","slug":"oracle-export-issue","date":"2011-11-07T10:46:30.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2011/11/07/oracle-export-issue/","link":"","permalink":"http://jiaming0708.github.io/2011/11/07/oracle-export-issue/","excerpt":"最近遇到了一個情況","text":"最近遇到了一個情況 客戶為了DB的安全性，將密碼做了修改改了以後執行Export和Import動作時，出現了 ORA-12154:TNS:無法解析指定的連接標示符 但是登入使用者時卻又可以登入，也可以查詢資料 改用測試帳號執行匯出，發現正常沒有問題將測試帳號的密碼改為和正式的密碼相同，也不能執行匯出發現是密碼中帶有@的特殊字元，才無法執行在oracle中，@在DBLink中會使用到","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"Oracle","slug":"Backend/Oracle","permalink":"http://jiaming0708.github.io/categories/Backend/Oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://jiaming0708.github.io/tags/oracle/"}]},{"title":"[ASP.NET] 在UpdatePanel裡執行JavaScript","slug":"asp-javascript-updatepanel","date":"2011-10-05T01:27:52.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2011/10/05/asp-javascript-updatepanel/","link":"","permalink":"http://jiaming0708.github.io/2011/10/05/asp-javascript-updatepanel/","excerpt":"昨天遇到一個問題，要在UpdatePanel裡面的某個物件PostBack後執行Script一般在按鈕觸發後回到後台執行完畢，要在執行某個Script我們會這樣寫","text":"昨天遇到一個問題，要在UpdatePanel裡面的某個物件PostBack後執行Script一般在按鈕觸發後回到後台執行完畢，要在執行某個Script我們會這樣寫 1ClientScript.RegisterStartupScript(this.GetType(), &quot;ShowMessage&quot;, &quot;alert(&#x27;hello!&#x27;)&quot;); 但是，如果按鈕被包在UpdatePanel裡面這樣的寫法無效，並不會執行這時我們換一個寫法，就可以正常執行了 1ClientScript.RegisterClientScriptBlock(UpdatePanel1.GetType(), &quot;ShowMessage&quot;, &quot;alert(&#x27;hello!&#x27;)&quot;, true);","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"ASP.NET","slug":"Backend/ASP-NET","permalink":"http://jiaming0708.github.io/categories/Backend/ASP-NET/"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"}]},{"title":"[jQuery] each迴圈的continue/break","slug":"jquery-each","date":"2011-09-30T03:54:16.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2011/09/30/jquery-each/","link":"","permalink":"http://jiaming0708.github.io/2011/09/30/jquery-each/","excerpt":"在jQuery中使用each時，要進行continue&#x2F;break只要這樣做就行了","text":"在jQuery中使用each時，要進行continue&#x2F;break只要這樣做就行了 123456$(&#x27;tag&#x27;).each(p=&gt;&#123; //continue return true; //break //return false;&#125;)","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"jQuery","slug":"Frontend/jQuery","permalink":"http://jiaming0708.github.io/categories/Frontend/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://jiaming0708.github.io/tags/jQuery/"}]},{"title":"[ASP.NET] Telerik RadGrid的GridButtonColumn修改ConfirmText","slug":"asp-telerik-gridbuttoncolumn","date":"2011-09-29T01:53:00.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2011/09/29/asp-telerik-gridbuttoncolumn/","link":"","permalink":"http://jiaming0708.github.io/2011/09/29/asp-telerik-gridbuttoncolumn/","excerpt":"Telerik是第三方的元件，加強了前台和後台的一些功能並且都經過美化，讓開發者可以簡單使用又不失美觀telerik官網","text":"Telerik是第三方的元件，加強了前台和後台的一些功能並且都經過美化，讓開發者可以簡單使用又不失美觀telerik官網 我們最常使用的是RadGrid（其實就是GridView的功能）會用到的Column有GridButtonColumn、GridTemplateColumn、GridBoundColumna等 其中GridButtonColumn這樣設定 123&lt;telerik:gridbuttoncolumn headerstyle-width=&quot;20px&quot; confirmtext=&quot;Delete this contact?&quot; ConfirmDialogType=&quot;RadWindow&quot; ConfirmTitle=&quot;Delete&quot; ButtonType=&quot;PushButton&quot; CommandName=&quot;Delete&quot; Text=&quot;Delete&quot; UniqueName=&quot;DeleteColumn&quot;&gt; &lt;itemstyle horizontalalign=&quot;Center&quot;&gt;&lt;/itemstyle&gt;&lt;/telerik:gridbuttoncolumn&gt; 要修改ConfrimText的內容需要先了解另一個屬性ButtonType分為PushButton(Button)、ImageButton(ImageButton)、LinkButton(HyperlinkButton) 這邊就只用PushButton做範例先找出該物件，物件型別會根據ButtonType有所差異接著使用原始的給Atrribute作法，來進行修改 123456789101112131415protected void rgFile_ItemDataBound(object sender, Telerik.Web.UI.GridItemEventArgs e)&#123; if (e.Item is GridDataItem) &#123; GridDataItem item = e.Item as GridDataItem; Button btnDelete = item[&quot;DeleteColumn&quot;].Controls[0] as Button; if (btnDelete != null) &#123; btnDelete.Text = _UIFace.GetFaceString(&quot;btnDelete&quot;); //ANS-00002:確定要刪除？ btnDelete.Attributes[&quot;onclick&quot;] = string.Format(&quot;return confirm(&#x27;&#123;0&#125;&#x27;);&quot;, _UIMsg.GetMessageString(&quot;ANS-00002&quot;)); &#125; &#125;&#125;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"ASP.NET","slug":"Backend/ASP-NET","permalink":"http://jiaming0708.github.io/categories/Backend/ASP-NET/"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"}]},{"title":"[oracle] 11G沒有資料的Schema無法匯出","slug":"oracle-schema-export","date":"2011-08-05T00:23:44.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2011/08/05/oracle-schema-export/","link":"","permalink":"http://jiaming0708.github.io/2011/08/05/oracle-schema-export/","excerpt":"Oracle在11G開始，匯出整個使用者時，沒有資料的Schema是不會匯出的還好這是可以設定的，我們可以先用下面的語法檢查","text":"Oracle在11G開始，匯出整個使用者時，沒有資料的Schema是不會匯出的還好這是可以設定的，我們可以先用下面的語法檢查 1show parameter deferred_segment_creation 結果為true，就不會匯出空的Schema只要用下面的語法就可以讓空的Schema也匯出了 1alter system set deferred_segment_creation=false;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"Oracle","slug":"Backend/Oracle","permalink":"http://jiaming0708.github.io/categories/Backend/Oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://jiaming0708.github.io/tags/oracle/"}]},{"title":"[JS] 在Reload頁面時，保持ScrollBar的位置","slug":"js-keep-scroll","date":"2011-03-31T01:58:31.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2011/03/31/js-keep-scroll/","link":"","permalink":"http://jiaming0708.github.io/2011/03/31/js-keep-scroll/","excerpt":"最近的案子有一個需求要在頁面Reload時保持ScrollBar的位置","text":"最近的案子有一個需求要在頁面Reload時保持ScrollBar的位置 作法其實很簡單就是在ScrollBar移動時將位置記住每次Reload時去抓取存放的位置 我的作法是用一個暫存位置用的TextBox做儲存 123456789101112131415$(document).ready(function()&#123; var ttbScroll = $(&#x27;#ttbScroll&#x27;); var divMenu = document.getElementById(&#x27;divMenu&#x27;); if(ttbScroll.val() != &#x27;&#x27;) &#123; var split = ttbScroll.val().split(&#x27;,&#x27;); divMenu.scrollLeft = split[0]; divMenu.scrollTop = split[1]; &#125; $(&#x27;#divMenu&#x27;).scroll(function()&#123; ttbScroll.val(divMenu.scrollLeft + &#x27;,&#x27; + divMenu.scrollTop); &#125;);&#125;);","categories":[{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"JavaScript","slug":"Frontend/JavaScript","permalink":"http://jiaming0708.github.io/categories/Frontend/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiaming0708.github.io/tags/JavaScript/"}]},{"title":"[oracle] ORA-12514 TNS 監聽進程不能解析在連接描述符中給出的 SERVICE_NAME","slug":"oracle-12514","date":"2011-01-31T15:09:57.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2011/01/31/oracle-12514/","link":"","permalink":"http://jiaming0708.github.io/2011/01/31/oracle-12514/","excerpt":"重灌系統後，安裝了11G的Oracle…安裝完後進去SYS的user都沒問題…但把service改為手動啟動…再次開啟時，卻出現了ORA-12514的錯誤訊息…","text":"重灌系統後，安裝了11G的Oracle…安裝完後進去SYS的user都沒問題…但把service改為手動啟動…再次開啟時，卻出現了ORA-12514的錯誤訊息… 原本以為有service沒啟動到…但去查了一下才發現…是listener.ora的內容需要加上一些東西… 找到oracle安裝的資料夾底下/network/admin/listener.ora 更改完畢後，將service重啟…就可以連線到了… 123456789101112131415SID_LIST_LISTENER = (SID_LIST = (SID_DESC = (SID_NAME = CLRExtProc) (ORACLE_HOME = D:\\app\\[username]\\product\\11.2.0\\dbhome_1) (PROGRAM = extproc) (ENVS = &quot;EXTPROC_DLLS=ONLY:D:\\app\\[username]\\product\\11.2.0\\dbhome_1\\bin\\oraclr11.dll&quot;) ) //新增 (SID_DESC = (GLOBAL_DBNAME = [sid]) (ORACLE_HOME = D:\\app\\[username]\\product\\11.2.0\\dbhome_1) (SID_NAME = [sid]) ) )","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"Oracle","slug":"Backend/Oracle","permalink":"http://jiaming0708.github.io/categories/Backend/Oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://jiaming0708.github.io/tags/oracle/"}]},{"title":"[C#] 自己寫Event","slug":"csharp-event","date":"2010-11-14T01:36:39.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2010/11/14/csharp-event/","link":"","permalink":"http://jiaming0708.github.io/2010/11/14/csharp-event/","excerpt":"好久沒有來寫點東西了…換了工作以後被鳥客戶纏身…每天就是忙盲茫…","text":"好久沒有來寫點東西了…換了工作以後被鳥客戶纏身…每天就是忙盲茫… 廢話不多說…直接進入正題吧… 這次的需求是這樣的…想要去寫入log資訊…但又不希望每個class都要去加上寫入log的function…因此採用Event的方式… 123456789101112131415161718192021222324252627282930class Program&#123; static void Main(string[] args) &#123; EventListen.OnLoggin += new EventListen.LogHandler(EventListen_OnLoggin); EventListen el = new EventListen(); Console.ReadLine(); &#125; static void EventListen_OnLoggin(string message) &#123; Console.WriteLine(message); Console.ReadLine(); &#125;&#125;public class EventListen&#123; public delegate void LogHandler(string message); public static event LogHandler OnLoggin; public EventListen() &#123; //避免event沒有被listen if (OnLoggin != null) &#123; OnLoggin(&quot;test&quot;); &#125; &#125;&#125;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[ASP.NET] 用js開啟AJAX Accordion","slug":"asp-ajax-accordion","date":"2010-08-10T02:31:42.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2010/08/10/asp-ajax-accordion/","link":"","permalink":"http://jiaming0708.github.io/2010/08/10/asp-ajax-accordion/","excerpt":"專案有一個需求要點了某個物件以後去顯示相關內容(那內容放在Accordion的其中一個panel)我採用了js的ajax的方式去取得主管又希望能夠在點了那個物件後顯示相關內容那塊能顯示出來","text":"專案有一個需求要點了某個物件以後去顯示相關內容(那內容放在Accordion的其中一個panel)我採用了js的ajax的方式去取得主管又希望能夠在點了那個物件後顯示相關內容那塊能顯示出來 由於我都是在前台作業沒有postback到後台因此這個需求就出現了 這段必須加在form裡面，不然$get會抓不到那個物件 12345function Openpane(paneIndex) &#123; //Accordion is the ID of AJAX Accordion control var behavior = $get(&quot;&lt;%=EmsAccordion.ClientID%&gt;&quot;).AccordionBehavior; behavior.set_SelectedIndex(paneIndex);&#125;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"ASP.NET","slug":"Backend/ASP-NET","permalink":"http://jiaming0708.github.io/categories/Backend/ASP-NET/"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"}]},{"title":"[ASP.NET] DataGrid動態產生Template(更新)","slug":"asp-datagrid-dynmic","date":"2010-05-14T13:40:30.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2010/05/14/asp-datagrid-dynmic/","link":"","permalink":"http://jiaming0708.github.io/2010/05/14/asp-datagrid-dynmic/","excerpt":"這是舊的文章…但這個功能之前其實算是失敗的…在update時後想要再後台去抓取那些動態生成的欄位值…但發現都抓不到…最近都在用jQuery…就改在前台抓完值後存在某個地方…再由後台去處理…","text":"這是舊的文章…但這個功能之前其實算是失敗的…在update時後想要再後台去抓取那些動態生成的欄位值…但發現都抓不到…最近都在用jQuery…就改在前台抓完值後存在某個地方…再由後台去處理… 舊的內容為了不想要每次資料庫增加一個欄位…就要大費工夫的去改一堆程式…因此想說用動態的去產生要顯示的欄位… 這是ASP1.1的作法… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void Page_Load()&#123; TemplateColumn col = new TemplateColumn(); col.ItemTemplate = new DataItemTemplate(ListItemType.Item, colu, attr); col.EditItemTemplate = new DataItemTemplate(ListItemType.EditItem, colu, attr); datagrid.Columns.Add(col);&#125; public class DataItemTemplate:ITemplate &#123; private ListItemType mType; private string mColumnName; private string mIDName; public DataItemTemplate(ListItemType type, string colname, string idname) &#123; mType = type; mColumnName = colname; mIDName = idname; &#125; public void InstantiateIn(Control container) &#123; // TODO: 加入 DataItemTemplate.InstantiateIn 實作 switch (this.mType) &#123; case ListItemType.Item: //可自行改成別的物件 Label lb = new Label(); lb.DataBinding += new EventHandler(DataBinding); container.Controls.Add(lb); break; case ListItemType.EditItem: //可自行改成別的物件 DropDownList ddl = new DropDownList(); ddl.Items.Add(&quot;TRUE&quot;); ddl.Items.Add(&quot;FALSE&quot;); ddl.ID = &quot;ddl&quot; + this.mIDName; container.Controls.Add(ddl); break; &#125; &#125; void DataBinding(object sender, EventArgs e) &#123; //要對應Item的DataBinding Label lb = (Label)sender; DataGridItem container = (DataGridItem)lb.NamingContainer; object dataValue = DataBinder.Eval(container.DataItem, mColumnName); if(dataValue != DBNull.Value) &#123; lb.Text = dataValue.ToString(); &#125; &#125; 新的內容ASP2.0的作法請產考這篇文章…http://blog.blueshop.com.tw/hent/archive/2008/02/24/54382.aspx 前台抓取動態欄位值 123456789101112131415161718192021//在DataGrid裡面找到叫做update的元件$(&#x27;#dg_ControlStatus&#x27;).find(&#x27;a[id$=btnUpdate]&#x27;).click(function()&#123; //input Reason var tempReason = prompt(&#x27;Modify Reason?&#x27;,&#x27;&#x27;); if(tempReason != null &amp;&amp; tempReason != &#x27;&#x27;) $(&#x27;#txtReason&#x27;).val(tempReason); else return false; var data = &#x27;&#x27;; //找出該行中的所有儲存格 $(this).parents(&#x27;tr&#x27;).find(&#x27;td&#x27;).each(function()&#123; //只要CoboBox的值 if($(this).find(&#x27;select&#x27;).length &gt; 0) data += $(this).find(&#x27;select&#x27;).val() + &#x27;,&#x27;; &#125;); //儲存起來給後台處理 $(&#x27;#txtSaveData&#x27;).val(data);&#125;);","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"ASP.NET","slug":"Backend/ASP-NET","permalink":"http://jiaming0708.github.io/categories/Backend/ASP-NET/"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"}]},{"title":"[ASP.NET] ajax使用WebService","slug":"asp-ajax-webservice","date":"2010-04-13T12:25:45.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2010/04/13/asp-ajax-webservice/","link":"","permalink":"http://jiaming0708.github.io/2010/04/13/asp-ajax-webservice/","excerpt":"最近用WebService來做一些功能很奇怪的再local測試都沒問題但一放到server上就有問題","text":"最近用WebService來做一些功能很奇怪的再local測試都沒問題但一放到server上就有問題 錯誤訊息沒存起來不過大概是說傳遞格式出錯 網路找一找才發現原來要再web.config中加上這段 1234567&lt;system.web&gt;&lt;webServices&gt;&lt;protocols&gt;&lt;add name=&quot;HttpPost&quot;/&gt;&lt;add name=&quot;HttpGet&quot;/&gt;&lt;/protocols&gt;&lt;/webServices&gt;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"ASP.NET","slug":"Backend/ASP-NET","permalink":"http://jiaming0708.github.io/categories/Backend/ASP-NET/"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"}]},{"title":"[C#] 型別當變數","slug":"csharp-type","date":"2010-03-29T08:58:37.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2010/03/29/csharp-type/","link":"","permalink":"http://jiaming0708.github.io/2010/03/29/csharp-type/","excerpt":"自己再寫MDI的視窗程式時寫一個檢查子視窗是否開啟的method想傳form的型別過去當參數","text":"自己再寫MDI的視窗程式時寫一個檢查子視窗是否開啟的method想傳form的型別過去當參數 不知道該如何寫再網路上問了一下得到解答如下 就是用typeof轉成Type傳過去 1234567891011121314151617private bool CheckChildrenFormOpened(Type type)&#123; foreach (Form f in this.MdiChildren) &#123; if (f.GetType() == type) &#123; f.Activate(); return true; &#125; &#125; return false;&#125; if (!CheckChildrenFormOpened(typeof(AccountManage)))&#123;&#125;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[C#] ComboBox和ListBox如何將顯示和值分開","slug":"charp-combobox-display","date":"2009-10-08T15:12:56.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2009/10/08/charp-combobox-display/","link":"","permalink":"http://jiaming0708.github.io/2009/10/08/charp-combobox-display/","excerpt":"今天在寫AP時使用了ComboBox和ListBox想要在顯示和值是不同的發現了另一種寫法","text":"今天在寫AP時使用了ComboBox和ListBox想要在顯示和值是不同的發現了另一種寫法 一種寫法是將資料放到DataTable 123456DataTable dt = QueryTable(sql);ComboBox cmb = new ComboBox();cmb.DataSource = dt;cmb.DisplayMember = &quot;Name&quot;;cmb.ValueMember = &quot;ID&quot;; 另一種寫法，自己寫一個class去存放 12345678910111213141516171819202122232425262728293031323334public class ObjectBindItem&#123; private string mDisplay; private string mValue; public ObjectBindItem(string dis, string val) &#123; this.mDisplay = dis; this.mValue = val; &#125; public string Display &#123; get &#123; return this.mDisplay; &#125; &#125; public string Value &#123; get &#123; return this.mValue; &#125; &#125; public override string ToString() &#123; return this.mDisplay + &quot;-&quot; + this.mValue; &#125;&#125;ArrayList ary = new ArrayList();ary.Add(new ObjectBindItem(&quot;john&quot;, &quot;A123&quot;);ComboBox cmb = new ComboBox();cmb.DataSource = ary;cmb.DisplayMember = &quot;Display&quot;;cmb.ValueMember = &quot;Value&quot;;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[C#] 固定字串長度","slug":"csharp-string-pad","date":"2009-08-07T02:18:55.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2009/08/07/csharp-string-pad/","link":"","permalink":"http://jiaming0708.github.io/2009/08/07/csharp-string-pad/","excerpt":"昨天在寫一個動態生成文件的程式…寫出來了…但是格式非常不好看…因為都沒有對齊…","text":"昨天在寫一個動態生成文件的程式…寫出來了…但是格式非常不好看…因為都沒有對齊… 一開使用的方法是空白…接著換使用\\t的方式…也都不行… 後來查到可以改用….PadLeft()或是.PadRight()… 平常還真是不會去注意到這個方法阿&#x3D; &#x3D;”","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[C#] xml讀取寫入(續)","slug":"csharp-xml-continue","date":"2009-07-30T16:10:11.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2009/07/30/csharp-xml-continue/","link":"","permalink":"http://jiaming0708.github.io/2009/07/30/csharp-xml-continue/","excerpt":"前一篇來看的人很多…但應該會覺得介紹的太少了…這次來完整一點吧…算是自己的一個整理…","text":"前一篇來看的人很多…但應該會覺得介紹的太少了…這次來完整一點吧…算是自己的一個整理… xml內容…(這是我記帳程式的格式…) 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;Big5&quot;?&gt;&lt;MoneyManage&gt; &lt;UserClassification&gt; &lt;Category Name=&quot;餐飲&quot; ItemCount=&quot;8&quot; Key=&quot;1&quot;&gt; &lt;Item Name=&quot;早餐&quot; Category=&quot;1&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;101&quot; /&gt; &lt;Item Name=&quot;中餐&quot; Category=&quot;1&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;102&quot; /&gt; &lt;Item Name=&quot;晚餐&quot; Category=&quot;1&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;103&quot; /&gt; &lt;Item Name=&quot;點心宵夜&quot; Category=&quot;1&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;104&quot; /&gt; &lt;Item Name=&quot;飲料&quot; Category=&quot;1&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;105&quot; /&gt; &lt;Item Name=&quot;其他&quot; Category=&quot;1&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;119&quot; /&gt; &lt;Item Name=&quot;水果&quot; Category=&quot;1&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;151&quot; /&gt; &lt;Item Name=&quot;麵包&quot; Category=&quot;1&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;152&quot; /&gt; &lt;/Category&gt; &lt;Category Name=&quot;交通&quot; ItemCount=&quot;6&quot; Key=&quot;2&quot;&gt; &lt;Item Name=&quot;加油&quot; Category=&quot;2&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;206&quot; /&gt; &lt;Item Name=&quot;坐車&quot; Category=&quot;2&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;207&quot; /&gt; &lt;Item Name=&quot;換機油&quot; Category=&quot;2&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;208&quot; /&gt; &lt;Item Name=&quot;停車費&quot; Category=&quot;2&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;233&quot; /&gt; &lt;Item Name=&quot;過路費&quot; Category=&quot;2&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;235&quot; /&gt; &lt;Item Name=&quot;修理&quot; Category=&quot;2&quot; Type=&quot;支出&quot; Comment=&quot;&quot; Key=&quot;242&quot; /&gt; &lt;/Category&gt; &lt;/UserClassification&gt;&lt;/MoneyManage&gt; 開始運用…取得所有Category… 第一種方法12345XmlNode root = xmlDoc.SelectSingleNode(&quot;/MoneyManage/UserClassification&quot;);foreach (XmlElement elm in root.ChildNodes)&#123; Label1.Text += &quot;Category Name:&quot; + elm.GetAttribute(&quot;Name&quot;);&#125; 第二種方法XmlNodeList root &#x3D; xmlDoc.SelectNodes(“&#x2F;MoneyManage&#x2F;UserClassification”);foreach (XmlElement elm in root){ Label1.Text +&#x3D; “Category Name:” + elm.GetAttribute(“Name”);} 123456接下來是要取得名稱為&quot;停車費&quot;的Item...​``` csharpXmlElement node = (XmlElement)xmlDoc.SelectSingleNode(&quot;/MoneyManage/UserClassification/Category/Item[@Name=\\&quot;停車費\\&quot;]&quot;);Label1.Text += &quot;Category Name:&quot; + node.GetAttribute(&quot;Name&quot;); 如果要多個條件…類似SQL…[@Key &#x3D; ? and @Name &#x3D; ?] 讀取的部份算是差不多…接下來就是寫入的部份啦… 12345678910XmlNode root = xmlDoc.SelectSingleNode(&quot;/MoneyManage/UserClassification&quot;);XmlNode node = xmlDoc.CreateNode(XmlNodeType.Element, &quot;Category&quot;, null);XmlAttribute attribute = Variable.XmlDoc.CreateAttribute(&quot;Name&quot;);attribute.Value = &quot;住宿&quot;;node.Attributes.Append(attribute);root.AppendChild(node);xmlDoc.Save(&quot;jiaming.xml&quot;);","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[C#] String 轉 DateTime","slug":"csharp-string-datetime","date":"2009-07-23T11:39:28.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2009/07/23/csharp-string-datetime/","link":"","permalink":"http://jiaming0708.github.io/2009/07/23/csharp-string-datetime/","excerpt":"今天同事講到…String在轉DateTime的時候…要先轉double再轉…感覺上蠻複雜的…","text":"今天同事講到…String在轉DateTime的時候…要先轉double再轉…感覺上蠻複雜的… 其實只要簡單的兩行就可以了… 12IFormatProvider culture = new System.Globalization.CultureInfo(&quot;zh-TW&quot;, true);DateTime time = DateTime.ParseExact(&quot;20090723194530&quot;, &quot;yyyyMMddHHmmss&quot;, culture); 中間有任何變化的話…請自行搭配時間格式去設定…","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[C#] FileSystemWatcher","slug":"csharp-filesystemwatcher","date":"2009-04-09T07:47:45.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2009/04/09/csharp-filesystemwatcher/","link":"","permalink":"http://jiaming0708.github.io/2009/04/09/csharp-filesystemwatcher/","excerpt":"這是一個讓我覺得有趣的元件…他是用來監控檔案是否有新增刪除修改…詳細的介紹還是看msdn吧…來點小範例…","text":"這是一個讓我覺得有趣的元件…他是用來監控檔案是否有新增刪除修改…詳細的介紹還是看msdn吧…來點小範例… 12345678910111213141516171819void Main()&#123; FileSystemWatcher fsw = new FileSystemWatcher(); fsw.Path = @&quot;D:\\&quot;; fsw.Filter = &quot;*.txt&quot;; fsw.Created += new FileSystemEventHandler(fsw_Created); fsw.Changed += new FileSystemEventHandler(fsw_Changed); fsw.EnableRaisingEvents = true; &#125;void fsw_Changed(object sender, FileSystemEventArgs e)&#123; Console.WriteLine(&quot;File: &quot; + e.FullPath + &quot; &quot; + e.ChangeType);&#125;void fsw_Created(object sender, FileSystemEventArgs e)&#123; Console.WriteLine(&quot;File: &quot; + e.FullPath + &quot; &quot; + e.ChangeType);&#125;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[C#] OleDbTransaction","slug":"csharp-oledbtransaction","date":"2009-03-11T15:58:06.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2009/03/11/csharp-oledbtransaction/","link":"","permalink":"http://jiaming0708.github.io/2009/03/11/csharp-oledbtransaction/","excerpt":"當我要同時對資料庫做兩個刪除一個新增的動作…用一般的方法…OleDbCommand.ExecuteNonQuery當在第二個刪除失敗的時候…要去救回第一個刪除資料…會很麻煩…","text":"當我要同時對資料庫做兩個刪除一個新增的動作…用一般的方法…OleDbCommand.ExecuteNonQuery當在第二個刪除失敗的時候…要去救回第一個刪除資料…會很麻煩… 這時可以使用這個物件…OleDbTransaction它可以在有失敗時將資料救回…這還蠻方便的…省掉許多自己去寫維護的時間… 以下是MSDN的範例… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void ExecuteTransaction(string connectionString)&#123; using (OleDbConnection connection = new OleDbConnection(connectionString)) &#123; OleDbCommand command = new OleDbCommand(); OleDbTransaction transaction = null; // Set the Connection to the new OleDbConnection. command.Connection = connection; // Open the connection and execute the transaction. try &#123; connection.Open(); // Start a local transaction transaction = connection.BeginTransaction(); // Assign transaction object for a pending local transaction. command.Connection = connection; command.Transaction = transaction; // Execute the commands. command.CommandText = &quot;Insert into Region (RegionID, RegionDescription) VALUES (100, &#x27;Description&#x27;)&quot;; command.ExecuteNonQuery(); command.CommandText = &quot;Insert into Region (RegionID, RegionDescription) VALUES (101, &#x27;Description&#x27;)&quot;; command.ExecuteNonQuery(); // Commit the transaction. transaction.Commit(); Console.WriteLine(&quot;Both records are written to database.&quot;); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); try &#123; // Attempt to roll back the transaction. transaction.Rollback(); &#125; catch &#123; // Do nothing here; transaction is not active. &#125; &#125; // The connection is automatically closed when the // code exits the using block. &#125;&#125;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[ASP.NET] 登入驗證","slug":"asp-auth","date":"2009-02-16T10:58:17.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2009/02/16/asp-auth/","link":"","permalink":"http://jiaming0708.github.io/2009/02/16/asp-auth/","excerpt":"這是書上所教登入驗證的方法…","text":"這是書上所教登入驗證的方法… 123&lt;authentication mode=&quot;Forms&quot;&gt; &lt;forms loginUrl = &quot;Logon.aspx&quot; name=&quot;.ASPXCOOKIEOCS&quot; defaultUrl=&quot;Main.aspx&quot;/&gt;&lt;/authentication&gt; 改webconfig…將mode改為form並且指定登入網頁…接著再各頁面的Load加上… 12if (!User.Identity.IsAuthenticated) FormsAuthentication.RedirectToLoginPage(); 萬一忘記加了這兩行…就不會去驗證是否登入成功… 改公司網頁時發現，同事並沒有加上這兩行…但卻還是會自動轉往登入頁面…詢問後才知道是加了下面這東西… 123&lt;authorization&gt; &lt;deny users=&quot;?&quot; /&gt;&lt;/authorization&gt;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"ASP.NET","slug":"Backend/ASP-NET","permalink":"http://jiaming0708.github.io/categories/Backend/ASP-NET/"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"}]},{"title":"[C#] 參數傳遞觀念","slug":"csharp-call-by-reference","date":"2009-02-12T14:44:41.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2009/02/12/csharp-call-by-reference/","link":"","permalink":"http://jiaming0708.github.io/2009/02/12/csharp-call-by-reference/","excerpt":"這是從同事那邊得知的知識…原因是同事寫了一段程式讓我十分疑惑…","text":"這是從同事那邊得知的知識…原因是同事寫了一段程式讓我十分疑惑… 123456789101112131415161718192021class Form1&#123; public void Main() &#123; DataSet oDataSet=new DataSet(); Function.LoadDbList(DbName, oDataSet); for(int i=0;i&lt;oDataSet.Table[&quot;ALARMLIST&quot;].count;i++) &#123; //... &#125; &#125;&#125;class Function&#123; public static void LoadDbList(string DbName, DataSet oDataSet) &#123; //... dataAdapter.Fill(oDataSet); &#125;&#125; 在執行完Function.LoadDbList後，竟然就可以直接使用oDataSet這個物件但是程式中oDataSet這個物件並沒有回傳，也沒有ref或是out的用法但是就有辦法在接下的程式中使用 後來問同事後得知，原來除了基本的型態(string,int…等)其他的型態都是用reference的方式在傳遞參數 這樣就可以不必用return的方式聽同事說可以不用在new一個物件，似乎可以避免浪費資源","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[C#] 按tab+alt切換視窗時隱藏圖示","slug":"csharp-hide-icon","date":"2009-01-05T16:07:48.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2009/01/05/csharp-hide-icon/","link":"","permalink":"http://jiaming0708.github.io/2009/01/05/csharp-hide-icon/","excerpt":"用到這個的情況是在…一隻AP是不顯示在工作列的…但是卻又常駐在桌面…","text":"用到這個的情況是在…一隻AP是不顯示在工作列的…但是卻又常駐在桌面… 要讓圖示消失在切換的工作列中…其實有一個最簡單的設定…只需要兩行… 12this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;this.ShowInTaskbar = false; 但是當我設定改為… 1this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None; 圖示一樣會出現…這樣就無法達到我的需求… 同事有一隻AP擁有這樣的功能…不過他的需求不同…他是要在按下顯示桌面時…程式不會跟著縮小… 廢話就不多說了…還是來看看怎樣達到這樣的目的… 1234567891011[DllImport(&quot;USER32.DLL&quot;)]public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);[DllImport(&quot;USER32.DLL&quot;)]public static extern IntPtr FindWindowEx(IntPtr parentHandle, IntPtr childAfter, string className, IntPtr windowTitle);[DllImport(&quot;USER32.DLL&quot;)]public static extern IntPtr SetParent(IntPtr hWndChild, IntPtr hWndNewParent);IntPtr hdesk = FindWindow(&quot;Progman&quot;, &quot;Program Manager&quot;);hdesk = FindWindowEx(hdesk, IntPtr.Zero, &quot;SHELLDLL_DefView&quot;, IntPtr.Zero);hdesk = FindWindowEx(hdesk, IntPtr.Zero, &quot;SysListView32&quot;, IntPtr.Zero);SetParent(this.Handle, hdesk); 不過用了這個以後…原本所寫的top功能就消失了…這個功能還要在找尋…","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[C#] 某月的第n個星期w是幾號","slug":"csharp-cal-month-week-day","date":"2008-12-31T05:30:48.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2008/12/31/csharp-cal-month-week-day/","link":"","permalink":"http://jiaming0708.github.io/2008/12/31/csharp-cal-month-week-day/","excerpt":"得知2009&#x2F;1&#x2F;1為該月的第一個星期四…200&#x2F;1&#x2F;8為第二個星期四…以此類推…","text":"得知2009&#x2F;1&#x2F;1為該月的第一個星期四…200&#x2F;1&#x2F;8為第二個星期四…以此類推… 當有人問你2009的1月第三個星期二是幾號…平常你可以看日曆最快…但這樣的東西要怎樣用程式去算出來… 這聽起來似乎很難…因為每個月的起始都不同…有可能會有的星期w會有五個… 先講算法…首先要做的是先知道該月的1號是星期幾x…算出第一個w是幾號…判斷w是否大於等於x…大於等於時…f&#x3D;1+(w-x)小於時…f&#x3D;1+[(7-x)+w)]此時f就是第一個星期w的日期了…再來就是看需要計算第幾個星期w…ans&#x3D;f+7*(n-1) 以下是程式… 12345678910111213DateTime firstDay = DateTime.Now.AddDays(-(DateTime.Now.Day - 1));DayOfWeek queryDay = DayOfWeek.Tuesday;DateTime firstWeek, ans;int week = 3;if ((int)queryDay &gt;= (int)firstDay.DayOfWeek)&#123; firstWeek = firstDay.AddDays((int)queryDay - (int)firstDay.DayOfWeek);&#125;else&#123; firstWeek = firstDay.AddDays(7 - (int)firstDay.DayOfWeek + (int)queryDay);&#125;ans = firstWeek.AddDays(7 * (week - 1)); 上面是在說從前面算起第n個星期w…那我要算最後一個星期w呢…算法改一下…變成從月底來計算… 底下就直接看程式了… 123456789DateTime lastDay = (firstDay.AddMonths(1)).AddDays(-1);if ((int)lastDay.DayOfWeek &gt;= (int)queryDay)&#123; ans = lastDay.AddDays(-((int)lastDay.DayOfWeek - (int)queryDay));&#125;else&#123; ans = lastDay.AddDays(-(7 - (int)queryDay + (int)lastDay.DayOfWeek));&#125;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[C#] parse","slug":"csharp-parse","date":"2008-12-29T08:39:55.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2008/12/29/csharp-parse/","link":"","permalink":"http://jiaming0708.github.io/2008/12/29/csharp-parse/","excerpt":"顏色將顏色代碼”#2952A3”要轉成Color型別Color型別只有三種parseFromArgb、FromKnownColor、FromName後面兩種都是Color型別中已存在命名的顏色去做parse","text":"顏色將顏色代碼”#2952A3”要轉成Color型別Color型別只有三種parseFromArgb、FromKnownColor、FromName後面兩種都是Color型別中已存在命名的顏色去做parse 所以只能用第一種，但是他又只支援int32那這種代碼要怎麼轉換其實很明顯的，這種代碼是16進制只要將16先轉成10就可以了 1int.Parse(&quot;#2952A3&quot;.Replace(&quot;#&quot;, &quot;&quot;), System.Globalization.NumberStyles.AllowHexSpecifier) 日期將字串”20081229T120000”轉成DateTime型別DateTime的型別有兩種的parseParse、ParseExactParse適用於像這種較為明確的字串格式”2&#x2F;16&#x2F;1992 12:15:12”而所得到的字串是不明確時，要採用ParseExact 12IFormatProvider culture = new System.Globalization.CultureInfo(&quot;zh-CHT&quot;, true);DateTime.ParseExact(&quot;20081229T120000&quot;.Replace(&quot;T&quot;, &quot; &quot;), &quot;yyyyMMdd HHmmss&quot;, culture);","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[C#] 單一化執行","slug":"csharp-single-instance","date":"2008-12-26T03:33:06.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2008/12/26/csharp-single-instance/","link":"","permalink":"http://jiaming0708.github.io/2008/12/26/csharp-single-instance/","excerpt":"有的時候希望程式只單一執行，可以參考以下的程式","text":"有的時候希望程式只單一執行，可以參考以下的程式 如果你跟我一樣是一個需要登入的系統用下面的方法會在開一次登入視窗如果想要直接執行主視窗，可以用兩種方法 起始的class為主視窗，這個方法我不太會會知道這個方法是公司同事這樣寫 起始的class為登入視窗，加上已經登入與否的判斷式在 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public partial class Login : Form&#123; [STAThread] static void Main() &#123; try &#123; //Application.Run(new Login()); string[] args = Environment.GetCommandLineArgs(); SingleInstanceController controller = new SingleInstanceController(); controller.Run(args); &#125; catch &#123; &#125; &#125; public delegate void ProcessParametersDelegate(object sender, string[] args); public void ProcessParameters(object sender, string[] args) &#123; this.Visible = true; this.TopMost = true; this.TopMost = false; &#125; class SingleInstanceController : WindowsFormsApplicationBase &#123; public SingleInstanceController() &#123; // Make this a single-instance application this.IsSingleInstance = true; this.EnableVisualStyles = true; // There are some other things available in the VB application model, for // instance the shutdown style: this.ShutdownStyle = Microsoft.VisualBasic.ApplicationServices.ShutdownMode.AfterMainFormCloses; // Add StartupNextInstance handler this.StartupNextInstance += new StartupNextInstanceEventHandler(this.SIApp_StartupNextInstance); &#125; /// &lt;summary&gt; /// We are responsible for creating the application&#x27;s main form in this override. /// &lt;/summary&gt; protected override void OnCreateMainForm() &#123; // Instantiate your main application form // Create an instance of the main form and set it in the application; // but don&#x27;t try to run it. this.MainForm = new Login(); // We want to pass along the command-line arguments to this first instance Random randNum = new Random(); &#125; /// &lt;summary&gt; /// This is called for additional instances. The application model will call this /// function, and terminate the additional instance when this returns. /// &lt;/summary&gt; /// &lt;param name=&quot;eventArgs&quot;&gt;&lt;/param&gt; protected void SIApp_StartupNextInstance(object sender, StartupNextInstanceEventArgs eventArgs) &#123; // Here you get the control when any other instance is // invoked apart from the first one. // You have args here in e.CommandLine. // You custom code which should be run on other instances // Copy the arguments to a string array string[] args = new string[eventArgs.CommandLine.Count]; eventArgs.CommandLine.CopyTo(args, 0); // Create an argument array for the Invoke method object[] parameters = new object[2]; parameters[0] = this.MainForm; parameters[1] = args; // Need to use invoke to b/c this is being called from another thread. this.MainForm.Invoke(new Login.ProcessParametersDelegate(((Login)this.MainForm).ProcessParameters), parameters); &#125; &#125;&#125;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[ASP.NET] 跳出類似loading的頁面","slug":"asp-loding","date":"2008-09-12T14:46:36.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2008/09/12/asp-loding/","link":"","permalink":"http://jiaming0708.github.io/2008/09/12/asp-loding/","excerpt":"這是在改公司網頁時看到的一個小功能…感覺好像可以拿出來應用…就先把他紀錄起來了…","text":"這是在改公司網頁時看到的一個小功能…感覺好像可以拿出來應用…就先把他紀錄起來了… 12&lt;INPUT id=&quot;ReturnValueObj&quot; style=&quot;Z-INDEX: 119; LEFT: 8px; WIDTH: 16px; POSITION: absolute; TOP: 264px; HEIGHT: 16px&quot; type=&quot;hidden&quot; size=&quot;1&quot; name=&quot;Hidden1&quot; runat=&quot;server&quot;&gt; 1234567891011121314151617181920212223242526272829//全域變數protected System.Web.UI.HtmlControls.HtmlInputHidden ReturnValueObj; //呼叫methodShowDialogBox (ReturnValueObj ,&quot;WebForm1.aspx&quot;,200,50,0,0,true); //method函式private void ShowDialogBox(System.Web.UI.HtmlControls.HtmlInputHidden ReturnValueObj,string sURL ,int width ,int height, int x,int y, Boolean isCenter ) &#123; string sFeature=&quot;&quot;; string sJs=&quot;&quot;; //iCenter = false; sFeature += &quot;dialogHeight:&quot; + height + &quot;px;&quot;; sFeature += &quot;dialogWidth:&quot; + width + &quot;px;&quot;; if (isCenter == false) &#123; sFeature += &quot;dialogLeft:&quot; + x + &quot;px;&quot;; sFeature += &quot;dialogTop:&quot; + y + &quot;px;&quot;; &#125; sJs = &quot;&lt;script&gt;&quot;; sJs += &quot;Form1.&quot; + ReturnValueObj.ClientID + &quot;.value =window.showModalDialog(&#x27;WebForm2.aspx?url=&quot; + sURL + &quot;&#x27;,&#x27;&#x27;,&#x27;&quot; + sFeature + &quot;&#x27;);&quot;; sJs += &quot;&lt;/script&gt;&quot;; this.RegisterStartupScript(&quot;ShowDialogBox&quot;,sJs); //把hidden textbox 的值接回window.alert 上 string script =&quot;&lt;script&gt;&quot;; script +=&quot;if(Form1.&quot; + ReturnValueObj.ClientID + &quot;.value != \\&quot;\\&quot;) &#123; window.alert(Form1.&quot; + ReturnValueObj.ClientID + &quot;.value); &#125; &quot;; script +=&quot;&lt;/script&gt;&quot;; this.RegisterStartupScript(&quot;ShowAlert&quot;,script); &#125;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"ASP.NET","slug":"Backend/ASP-NET","permalink":"http://jiaming0708.github.io/categories/Backend/ASP-NET/"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"}]},{"title":"[ASP.NET] 無法執行要求，因為無法建立 App-Domain","slug":"asp-regiis","date":"2008-09-10T14:52:14.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2008/09/10/asp-regiis/","link":"","permalink":"http://jiaming0708.github.io/2008/09/10/asp-regiis/","excerpt":"公司的電腦要跑asp.net…但是不能執行，出現這個錯誤訊息…不過還是沒解決問題…","text":"公司的電腦要跑asp.net…但是不能執行，出現這個錯誤訊息…不過還是沒解決問題… 因為是copy過來的不能run…但開新的可以run…最後同事說直接開一個新專案…然後再把檔案copy過去就可以了… 無法執行要求，因為無法建立 App-Domain。錯誤: 0x80131902 這是安裝IIS6要跑ASP.NET 2.0時所碰到的問題解法如下 With a command window, get to the latest version of .net under C:\\Windows\\Microsoft.Net\\Framework\\ Now run the following command: “net stop w3svc” to stop web services. Then use “aspnet_regiis.exe -ua” to uninstall all instances of ASP.NET from IIS. Follow with “aspnet_regiis.exe -i” to install ASP.NET into IIS. Now restart web services with “net start w3svc”.","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"ASP.NET","slug":"Backend/ASP-NET","permalink":"http://jiaming0708.github.io/categories/Backend/ASP-NET/"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"}]},{"title":"[C#] 讀取xml檔","slug":"csharp-xml","date":"2008-07-28T03:08:09.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2008/07/28/csharp-xml/","link":"","permalink":"http://jiaming0708.github.io/2008/07/28/csharp-xml/","excerpt":"以下為xml檔案內容","text":"以下為xml檔案內容 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;big5&quot;?&gt;&lt;noval&gt; &lt;BookID&gt;001 &lt;Name&gt;天魔神譚&lt;/Name&gt; &lt;Writer&gt;手槍&lt;/Writer&gt; &lt;LastReadDate&gt;2008/07/21&lt;/LastReadDate&gt; &lt;Chapter&gt;第3部第13集第9章&lt;/Chapter&gt; &lt;Finish&gt;False&lt;/Finish&gt; &lt;/BookID&gt; &lt;BookID&gt;002 &lt;Name&gt;魔法炒手&lt;/Name&gt; &lt;Writer&gt;張君寶&lt;/Writer&gt; &lt;LastReadDate&gt;2008/07/27&lt;/LastReadDate&gt; &lt;Chapter&gt;第609章&lt;/Chapter&gt; &lt;Finish&gt;True&lt;/Finish&gt; &lt;/BookID&gt; &lt;BookID&gt;003 &lt;Name&gt;異俠&lt;/Name&gt; &lt;Writer&gt;自在&lt;/Writer&gt; &lt;LastReadDate&gt;2008/07/27&lt;/LastReadDate&gt; &lt;Chapter&gt;第25集第8章&lt;/Chapter&gt; &lt;Finish&gt;False&lt;/Finish&gt; &lt;/BookID&gt;&lt;/noval&gt; 以下為片段程式碼 123456789using System.Xml;public XmlDocument myXml = new XmlDocument();myXml.Load(strFileName);//讀取xml檔numBook = myXml.ChildNodes.Item(1).ChildNodes.Count;//總書本數for (int i = 0; i &lt; numBook; i++)&#123; cmbBook.Items.Add(myXml.ChildNodes.Item(1).ChildNodes.Item(i).ChildNodes.Item(1).InnerText);&#125;","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"}]},{"title":"[C#] 使用非ASP.NET 1.1","slug":"asp-regiis","date":"2008-06-08T02:29:17.000Z","updated":"2023-03-09T14:18:38.647Z","comments":true,"path":"2008/06/08/asp-regiis/","link":"","permalink":"http://jiaming0708.github.io/2008/06/08/asp-regiis/","excerpt":"指定的Web伺服器不是執行ASP.NET 1.1版。您將無法執行ASP.NET Web應用程式或服務。","text":"指定的Web伺服器不是執行ASP.NET 1.1版。您將無法執行ASP.NET Web應用程式或服務。 因為IIS跟.FrameWork安裝順序錯誤，導致IIS無法辨別ASP.NET 1.1，所以必須讓兩者認識得重新安裝ASP.NET 1.1 方法為 開啟「命令提示字元」視窗(按一下 [開始]、[執行]，鍵入 cmd，然後再按一下 [確定])。 瀏覽至您要使用的 Aspnet_regiis.exe 版本的目錄。請注意，.NET Framework 的每一個版本都附帶有自己的版本。這個檔案通常位於下列目錄： （可使用「檔案總管」瀏覽，查明路徑） systemroot\\Microsoft.NET\\Framework\\versionNumber（例：C:\\WINDOWS\\Microsoft.NET\\Framework\\v1.1.4322於「命令提示字元」視窗命令提示列輸入及執行cd C:\\WINDOWS\\Microsoft.NET\\Framework\\v1.1.4322C:） 於「命令提示字元」視窗命令提示列輸入及執行ASPNET_REGIIS -i","categories":[{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"ASP.NET","slug":"Backend/ASP-NET","permalink":"http://jiaming0708.github.io/categories/Backend/ASP-NET/"}],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"}]}],"categories":[{"name":"Windows","slug":"Windows","permalink":"http://jiaming0708.github.io/categories/Windows/"},{"name":"Flutter","slug":"Flutter","permalink":"http://jiaming0708.github.io/categories/Flutter/"},{"name":"Infra","slug":"Infra","permalink":"http://jiaming0708.github.io/categories/Infra/"},{"name":"Database","slug":"Database","permalink":"http://jiaming0708.github.io/categories/Database/"},{"name":"Oracle","slug":"Database/Oracle","permalink":"http://jiaming0708.github.io/categories/Database/Oracle/"},{"name":"Webform","slug":"Webform","permalink":"http://jiaming0708.github.io/categories/Webform/"},{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/categories/Frontend/"},{"name":"Blazor","slug":"Frontend/Blazor","permalink":"http://jiaming0708.github.io/categories/Frontend/Blazor/"},{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/categories/Backend/"},{"name":"Dotnet","slug":"Backend/Dotnet","permalink":"http://jiaming0708.github.io/categories/Backend/Dotnet/"},{"name":"DotnetCore","slug":"Backend/DotnetCore","permalink":"http://jiaming0708.github.io/categories/Backend/DotnetCore/"},{"name":"linq","slug":"Backend/linq","permalink":"http://jiaming0708.github.io/categories/Backend/linq/"},{"name":"nginx","slug":"nginx","permalink":"http://jiaming0708.github.io/categories/nginx/"},{"name":"Github Action","slug":"Github-Action","permalink":"http://jiaming0708.github.io/categories/Github-Action/"},{"name":"shell","slug":"shell","permalink":"http://jiaming0708.github.io/categories/shell/"},{"name":"AngularJS","slug":"Frontend/AngularJS","permalink":"http://jiaming0708.github.io/categories/Frontend/AngularJS/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://jiaming0708.github.io/categories/CI-CD/"},{"name":"nuget","slug":"nuget","permalink":"http://jiaming0708.github.io/categories/nuget/"},{"name":"Git","slug":"Git","permalink":"http://jiaming0708.github.io/categories/Git/"},{"name":"JavaScript","slug":"Frontend/JavaScript","permalink":"http://jiaming0708.github.io/categories/Frontend/JavaScript/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://jiaming0708.github.io/categories/Design-Pattern/"},{"name":"Angular","slug":"Frontend/Angular","permalink":"http://jiaming0708.github.io/categories/Frontend/Angular/"},{"name":"IIS","slug":"IIS","permalink":"http://jiaming0708.github.io/categories/IIS/"},{"name":"AWS","slug":"AWS","permalink":"http://jiaming0708.github.io/categories/AWS/"},{"name":"linux","slug":"linux","permalink":"http://jiaming0708.github.io/categories/linux/"},{"name":"React","slug":"Frontend/React","permalink":"http://jiaming0708.github.io/categories/Frontend/React/"},{"name":"Project","slug":"Frontend/Project","permalink":"http://jiaming0708.github.io/categories/Frontend/Project/"},{"name":"ElasticSearch","slug":"Backend/ElasticSearch","permalink":"http://jiaming0708.github.io/categories/Backend/ElasticSearch/"},{"name":"chrome","slug":"Frontend/chrome","permalink":"http://jiaming0708.github.io/categories/Frontend/chrome/"},{"name":"CSS","slug":"Frontend/CSS","permalink":"http://jiaming0708.github.io/categories/Frontend/CSS/"},{"name":"vscode","slug":"Frontend/vscode","permalink":"http://jiaming0708.github.io/categories/Frontend/vscode/"},{"name":"iterm","slug":"iterm","permalink":"http://jiaming0708.github.io/categories/iterm/"},{"name":"mac","slug":"mac","permalink":"http://jiaming0708.github.io/categories/mac/"},{"name":"RxJS","slug":"Frontend/RxJS","permalink":"http://jiaming0708.github.io/categories/Frontend/RxJS/"},{"name":"Debug","slug":"Debug","permalink":"http://jiaming0708.github.io/categories/Debug/"},{"name":"Postgres","slug":"Backend/Postgres","permalink":"http://jiaming0708.github.io/categories/Backend/Postgres/"},{"name":"GTM","slug":"Frontend/GTM","permalink":"http://jiaming0708.github.io/categories/Frontend/GTM/"},{"name":"Testing","slug":"Frontend/Testing","permalink":"http://jiaming0708.github.io/categories/Frontend/Testing/"},{"name":"canvas","slug":"Frontend/canvas","permalink":"http://jiaming0708.github.io/categories/Frontend/canvas/"},{"name":"Vue","slug":"Frontend/Vue","permalink":"http://jiaming0708.github.io/categories/Frontend/Vue/"},{"name":"Docker","slug":"Docker","permalink":"http://jiaming0708.github.io/categories/Docker/"},{"name":"e2e","slug":"Frontend/e2e","permalink":"http://jiaming0708.github.io/categories/Frontend/e2e/"},{"name":"C#","slug":"Backend/C","permalink":"http://jiaming0708.github.io/categories/Backend/C/"},{"name":"ReactNative","slug":"Frontend/ReactNative","permalink":"http://jiaming0708.github.io/categories/Frontend/ReactNative/"},{"name":"APP","slug":"APP","permalink":"http://jiaming0708.github.io/categories/APP/"},{"name":"Cordova","slug":"APP/Cordova","permalink":"http://jiaming0708.github.io/categories/APP/Cordova/"},{"name":"Oracle","slug":"Backend/Oracle","permalink":"http://jiaming0708.github.io/categories/Backend/Oracle/"},{"name":"jQuery","slug":"Frontend/jQuery","permalink":"http://jiaming0708.github.io/categories/Frontend/jQuery/"},{"name":"ASP.NET","slug":"Backend/ASP-NET","permalink":"http://jiaming0708.github.io/categories/Backend/ASP-NET/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://jiaming0708.github.io/tags/Windows/"},{"name":"Docker","slug":"Docker","permalink":"http://jiaming0708.github.io/tags/Docker/"},{"name":"Flutter","slug":"Flutter","permalink":"http://jiaming0708.github.io/tags/Flutter/"},{"name":"Gitea","slug":"Gitea","permalink":"http://jiaming0708.github.io/tags/Gitea/"},{"name":"Infra","slug":"Infra","permalink":"http://jiaming0708.github.io/tags/Infra/"},{"name":"Database","slug":"Database","permalink":"http://jiaming0708.github.io/tags/Database/"},{"name":"Oracle","slug":"Oracle","permalink":"http://jiaming0708.github.io/tags/Oracle/"},{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://jiaming0708.github.io/tags/ASP-NET/"},{"name":"Debug","slug":"Debug","permalink":"http://jiaming0708.github.io/tags/Debug/"},{"name":"Webform","slug":"Webform","permalink":"http://jiaming0708.github.io/tags/Webform/"},{"name":"Blazor","slug":"Blazor","permalink":"http://jiaming0708.github.io/tags/Blazor/"},{"name":"Testing","slug":"Testing","permalink":"http://jiaming0708.github.io/tags/Testing/"},{"name":"Dotnet","slug":"Dotnet","permalink":"http://jiaming0708.github.io/tags/Dotnet/"},{"name":"DotnetCore","slug":"DotnetCore","permalink":"http://jiaming0708.github.io/tags/DotnetCore/"},{"name":"SDK","slug":"SDK","permalink":"http://jiaming0708.github.io/tags/SDK/"},{"name":"dotnet","slug":"dotnet","permalink":"http://jiaming0708.github.io/tags/dotnet/"},{"name":"linq","slug":"linq","permalink":"http://jiaming0708.github.io/tags/linq/"},{"name":"nginx","slug":"nginx","permalink":"http://jiaming0708.github.io/tags/nginx/"},{"name":"reverse-proxy","slug":"reverse-proxy","permalink":"http://jiaming0708.github.io/tags/reverse-proxy/"},{"name":"ngrok","slug":"ngrok","permalink":"http://jiaming0708.github.io/tags/ngrok/"},{"name":"Github Action","slug":"Github-Action","permalink":"http://jiaming0708.github.io/tags/Github-Action/"},{"name":"Telegram","slug":"Telegram","permalink":"http://jiaming0708.github.io/tags/Telegram/"},{"name":"jq","slug":"jq","permalink":"http://jiaming0708.github.io/tags/jq/"},{"name":"shell","slug":"shell","permalink":"http://jiaming0708.github.io/tags/shell/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://jiaming0708.github.io/tags/AngularJS/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://jiaming0708.github.io/tags/CI-CD/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://jiaming0708.github.io/tags/Jenkins/"},{"name":"Backend","slug":"Backend","permalink":"http://jiaming0708.github.io/tags/Backend/"},{"name":"WCF","slug":"WCF","permalink":"http://jiaming0708.github.io/tags/WCF/"},{"name":"https","slug":"https","permalink":"http://jiaming0708.github.io/tags/https/"},{"name":"nuget","slug":"nuget","permalink":"http://jiaming0708.github.io/tags/nuget/"},{"name":"Git","slug":"Git","permalink":"http://jiaming0708.github.io/tags/Git/"},{"name":"SVN","slug":"SVN","permalink":"http://jiaming0708.github.io/tags/SVN/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiaming0708.github.io/tags/JavaScript/"},{"name":"installer","slug":"installer","permalink":"http://jiaming0708.github.io/tags/installer/"},{"name":"VS2019","slug":"VS2019","permalink":"http://jiaming0708.github.io/tags/VS2019/"},{"name":"Frontend","slug":"Frontend","permalink":"http://jiaming0708.github.io/tags/Frontend/"},{"name":"browser","slug":"browser","permalink":"http://jiaming0708.github.io/tags/browser/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://jiaming0708.github.io/tags/Design-Pattern/"},{"name":"Powershell","slug":"Powershell","permalink":"http://jiaming0708.github.io/tags/Powershell/"},{"name":"WindowTerminal","slug":"WindowTerminal","permalink":"http://jiaming0708.github.io/tags/WindowTerminal/"},{"name":"Angular","slug":"Angular","permalink":"http://jiaming0708.github.io/tags/Angular/"},{"name":"IIS","slug":"IIS","permalink":"http://jiaming0708.github.io/tags/IIS/"},{"name":"Drone","slug":"Drone","permalink":"http://jiaming0708.github.io/tags/Drone/"},{"name":"AWS","slug":"AWS","permalink":"http://jiaming0708.github.io/tags/AWS/"},{"name":"GitKraken","slug":"GitKraken","permalink":"http://jiaming0708.github.io/tags/GitKraken/"},{"name":"React","slug":"React","permalink":"http://jiaming0708.github.io/tags/React/"},{"name":"vscode","slug":"vscode","permalink":"http://jiaming0708.github.io/tags/vscode/"},{"name":"nvm","slug":"nvm","permalink":"http://jiaming0708.github.io/tags/nvm/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://jiaming0708.github.io/tags/ElasticSearch/"},{"name":"Github","slug":"Github","permalink":"http://jiaming0708.github.io/tags/Github/"},{"name":"chrome","slug":"chrome","permalink":"http://jiaming0708.github.io/tags/chrome/"},{"name":"CSS","slug":"CSS","permalink":"http://jiaming0708.github.io/tags/CSS/"},{"name":"debug","slug":"debug","permalink":"http://jiaming0708.github.io/tags/debug/"},{"name":"webpack","slug":"webpack","permalink":"http://jiaming0708.github.io/tags/webpack/"},{"name":"iterm","slug":"iterm","permalink":"http://jiaming0708.github.io/tags/iterm/"},{"name":"mac","slug":"mac","permalink":"http://jiaming0708.github.io/tags/mac/"},{"name":"RxJS","slug":"RxJS","permalink":"http://jiaming0708.github.io/tags/RxJS/"},{"name":"SVG","slug":"SVG","permalink":"http://jiaming0708.github.io/tags/SVG/"},{"name":"AI","slug":"AI","permalink":"http://jiaming0708.github.io/tags/AI/"},{"name":"Postgres","slug":"Postgres","permalink":"http://jiaming0708.github.io/tags/Postgres/"},{"name":"regex","slug":"regex","permalink":"http://jiaming0708.github.io/tags/regex/"},{"name":"GTM","slug":"GTM","permalink":"http://jiaming0708.github.io/tags/GTM/"},{"name":"Quokka","slug":"Quokka","permalink":"http://jiaming0708.github.io/tags/Quokka/"},{"name":"crop","slug":"crop","permalink":"http://jiaming0708.github.io/tags/crop/"},{"name":"canvas","slug":"canvas","permalink":"http://jiaming0708.github.io/tags/canvas/"},{"name":"Wallaby","slug":"Wallaby","permalink":"http://jiaming0708.github.io/tags/Wallaby/"},{"name":"Vue","slug":"Vue","permalink":"http://jiaming0708.github.io/tags/Vue/"},{"name":"Jasmine","slug":"Jasmine","permalink":"http://jiaming0708.github.io/tags/Jasmine/"},{"name":"Protractor","slug":"Protractor","permalink":"http://jiaming0708.github.io/tags/Protractor/"},{"name":"e2e","slug":"e2e","permalink":"http://jiaming0708.github.io/tags/e2e/"},{"name":"C#","slug":"C","permalink":"http://jiaming0708.github.io/tags/C/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://jiaming0708.github.io/tags/ReactNative/"},{"name":"Cordova","slug":"Cordova","permalink":"http://jiaming0708.github.io/tags/Cordova/"},{"name":"ionic","slug":"ionic","permalink":"http://jiaming0708.github.io/tags/ionic/"},{"name":"oracle","slug":"oracle","permalink":"http://jiaming0708.github.io/tags/oracle/"},{"name":"MVC","slug":"MVC","permalink":"http://jiaming0708.github.io/tags/MVC/"},{"name":"jQuery","slug":"jQuery","permalink":"http://jiaming0708.github.io/tags/jQuery/"}]}